<?xml version="1.0" encoding="UTF-8"?>
<tmx version="1.4"><header creationtool="OmegaT" creationtoolversion="unknown" segtype="paragraph" o-tmf="unknown" adminlang="en" srclang="en-us" datatype="unknown"></header><body>
<tu>
<tuv xml:lang="en-us"><seg>MT! The argument @var{name} should be a string.  The argument @var{expansion} is normally the desired expansion (a string), or @code{nil} to undefine the abbrev.  If it is anything but a string or @code{nil}, then the abbreviation ``expands&apos;&apos; solely by running @var{hook}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument @ var {name} doit être une chaîne. L&apos;argument @ {var} extension est normalement l&apos;expansion souhaitée (une chaîne), ou @ code {nil} pour annuler la définition du abbrev. Si il est tout sauf une chaîne ou @ code {nil}, alors l&apos;abréviation ``&apos;&apos; étend uniquement en exécutant @ var {crochet}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The argument @var{hook} is a function or @code{nil}.  If @var{hook} is non-@code{nil}, then it is called with no arguments after the abbrev is replaced with @var{expansion}; point is located at the end of @var{expansion} when @var{hook} is called.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument @ {var} crochet est une fonction ou @ code {nil}. Si @ var {crochet} est non @ code {nil}, il est alors appelé sans arguments après la abbrev est remplacé par @ var {extension}; point est situé à la fin de @ var {extension} lorsque @ var { crochet} est appelé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{no-self-insert} property</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {no-auto-insert} propriété</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{hook} is a non-@code{nil} symbol whose @code{no-self-insert} property is non-@code{nil}, @var{hook} can explicitly control whether to insert the self-inserting input character that triggered the expansion.  If @var{hook} returns non-@code{nil} in this case, that inhibits insertion of the character.  By contrast, if @var{hook} returns @code{nil}, @code{expand-abbrev} also returns @code{nil}, as if expansion had not really occurred.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {crochet} est un code non-@ {nil} symbole dont @ code {no-auto-insert} propriété est non @ code {nil}, @ var {crochet} peut contrôler explicitement si vous voulez insérer l&apos;auto- insertion caractère d&apos;entrée qui a déclenché l&apos;expansion. Si @ var {crochet} renvoie non @ code {nil} dans ce cas, qui inhibe l&apos;insertion du caractère. En revanche, si @ var {crochet} retourne @ code {nil}, @ code {expand-abbrev} renvoie également @ code {nil}, que l&apos;expansion avait pas vraiment eu lieu.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{system-flag} is non-@code{nil}, that marks the abbrev as a ``system&apos;&apos; abbrev with the @code{system-type} property.  Unless @var{system-flag} has the value @code{force}, a ``system&apos;&apos; abbrev will not overwrite an existing definition for a non-``system&apos;&apos; abbrev of the same name.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {système drapeau} est non @ code {nil}, qui marque le abbrev comme un `` système&apos;&apos; abbrev avec le code de @ {type de système} propriété. Sauf @ var {système} drapeau a la valeur @ code {} vigueur, un `` système&apos;&apos; abbrev n&apos;écrasera pas une définition existante pour un non-`` système&apos;&apos; abbrev du même nom.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Normally the function @code{define-abbrev} sets the variable @code{abbrevs-changed} to @code{t}, if it actually changes the abbrev.  (This is so that some commands will offer to save the abbrevs.)  It does not do this for a ``system&apos;&apos; abbrev, since those won&apos;t be saved anyway.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Normalement, la fonction @ code {définir-abbrev} définit la variable @ code {} abbrevs-changé à @ code {t}, si elle change réellement la abbrev. (Il en est ainsi que certaines commandes offriront pour enregistrer les abbréviations.) Il ne le fait pas pour un `` système&apos;&apos; abbrev, puisque ceux ne seront pas sauvés de toute façon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is non-@code{nil}, it means that the user plans to use global abbrevs only.  This tells the commands that define mode-specific abbrevs to define global ones instead.  This variable does not alter the behavior of the functions in this section; it is examined by their callers.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est non @ code {nil}, cela signifie que l&apos;utilisateur prévoit d&apos;utiliser abbrevs globales uniquement. Cela indique les commandes qui définissent abbrevs spécifiques au mode de définir les mondiaux à la place. Cette variable ne modifie pas le comportement des fonctions de cette section, il est examiné par les appelants.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Saving Abbrevs in Files</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Enregistrement Abbrevs dans les fichiers</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A file of saved abbrev definitions is actually a file of Lisp code.  The abbrevs are saved in the form of a Lisp program to define the same abbrev tables with the same contents.  Therefore, you can load the file with @code{load} (@pxref{How Programs Do Loading}).  However, the function @code{quietly-read-abbrev-file} is provided as a more convenient interface.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un fichier de définitions de abbrev enregistrés est en fait un fichier de code Lisp. Les abbréviations sont enregistrées sous la forme d&apos;un programme Lisp pour définir les mêmes tables de abbrev avec le même contenu. Par conséquent, vous pouvez charger le fichier de @ code {} charge (@ pxref {Comment les programmes ne Chargement}). Cependant, la fonction @ code {tranquillement lire-abbrev-file} est fourni une interface plus pratique.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! User-level facilities such as @code{save-some-buffers} can save abbrevs in a file automatically, under the control of variables described here.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>établissements de niveau de l&apos;utilisateur, tels que @ code {save-some-buffers} peuvent sauver abbrevs dans un fichier automatiquement, sous le contrôle de variables décrites ici.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the default file name for reading and saving abbrevs.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est le nom de fichier par défaut pour la lecture et l&apos;enregistrement abbrevs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! quietly-read-abbrev-file &amp;optional filename</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tranquillement lire-SIGLE fichier et option filename</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function reads abbrev definitions from a file named @var{filename}, previously written with @code{write-abbrev-file}.  If @var{filename} is omitted or @code{nil}, the file specified in @code{abbrev-file-name} is used.  @code{save-abbrevs} is set to @code{t} so that changes will be saved.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction lit abbrev définitions à partir d&apos;un fichier nommé @ var {nom}, écrit précédemment avec @ code {write-abbrev-file}. Si @ var {nom de fichier} est omis ou @ code {nil}, le fichier spécifié dans @ code {abbrev-file-name} est utilisé. @ Code {save-abbrevs} est réglé sur @ code {t} de sorte que les changements seront sauvegardés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function does not display any messages.  It returns @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction n&apos;affiche pas les messages. Il retourne @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A non-@code{nil} value for @code{save-abbrevs} means that Emacs should offer the user to save abbrevs when files are saved.  If the value is @code{silently}, Emacs saves the abbrevs without asking the user.  @code{abbrev-file-name} specifies the file to save the abbrevs in.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un non-@ code {nil} valeur de @ code {save-abbrevs} signifie que Emacs devrait offrir à l&apos;utilisateur d&apos;enregistrer abbrevs lorsque les fichiers sont enregistrés. Si la valeur est @ code {} silence, Emacs enregistre les abbrevs sans demander à l&apos;utilisateur. @ Code {abbrev-file-name} spécifie le fichier à enregistrer les abbrevs po</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable is set non-@code{nil} by defining or altering any abbrevs (except ``system&apos;&apos; abbrevs).  This serves as a flag for various Emacs commands to offer to save your abbrevs.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable est non @ code {nil} en définissant ou modifiant des abbrevs (sauf `` système&apos;&apos; abbrevs). Cela sert comme un drapeau pour diverses commandes Emacs à offrir pour enregistrer vos abbrevs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command write-abbrev-file &amp;optional filename</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande write-abbrev-file et en option filename</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Save all abbrev definitions (except ``system&apos;&apos; abbrevs), for all abbrev tables listed in @code{abbrev-table-name-list}, in the file @var{filename}, in the form of a Lisp program that when loaded will define the same abbrevs.  If @var{filename} is @code{nil} or omitted, @code{abbrev-file-name} is used.  This function returns @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Enregistrer toutes les définitions de abbrev (sauf `` système&apos;&apos; abbrevs), pour toutes les tables répertoriées dans abbrev @ code {abbrev-table-nom-liste}, dans le fichier @ var {nom}, sous la forme d&apos;un programme Lisp que lorsque chargé définira les mêmes abbrevs. Si @ var {nom de fichier} est @ code {nil} ou omis, @ code {abbrev-file-name} est utilisé. Cette fonction retourne @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Looking Up and Expanding Abbreviations</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Regarder en l&apos;air et l&apos;extension des abréviations</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Abbrevs are usually expanded by certain interactive commands, including @code{self-insert-command}.  This section describes the subroutines used in writing such commands, as well as the variables they use for communication.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Abbrevs sont généralement développés par certaines commandes interactives, y compris @ code {auto-insert-command}. Cette section décrit les sous-programmes utilisés par écrit les commandes, ainsi que les variables qu&apos;ils utilisent pour la communication.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! abbrev-symbol abbrev &amp;optional table</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>abbrev-symbole abbrev et facultatif tableau</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the symbol representing the abbrev named @var{abbrev}.  The value returned is @code{nil} if that abbrev is not defined.  The optional second argument @var{table} is the abbrev table to look it up in.  If @var{table} is @code{nil}, this function tries first the current buffer&apos;s local abbrev table, and second the global abbrev table.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le symbole représentant le abbrev nommé @ var {} abbrev. La valeur retournée est @ code {nil} si abbrev n&apos;est pas défini. L&apos;option deuxième argument @ var {table} est la table de abbrev à regarder vers le haut po Si @ var {table} est @ code {nil}, cette fonction tente première table de abbrev local du tampon courant, et la seconde le tableau global de abbrev.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! abbrev-expansion abbrev &amp;optional table</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>abbrev expansion abbrev et facultatif tableau</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the string that @var{abbrev} would expand into (as defined by the abbrev tables used for the current buffer).  If @var{abbrev} is not a valid abbrev, the function returns @code{nil}.  The optional argument @var{table} specifies the abbrev table to use, as in @code{abbrev-symbol}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne la chaîne @ {var} abbrev élargirait dans (tel que défini par les tables de abbrev utilisés pour le tampon courant). Si @ var {abbrev} n&apos;est pas un abbrev valide, la fonction renvoie @ code {nil}. L&apos;argument @ option {var table} spécifie la table de abbrev à utiliser, comme dans @ code {abbrev-symbole}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command expand-abbrev</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande expand-abbrev</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command expands the abbrev before point, if any.  If point does not follow an abbrev, this command does nothing.  The command returns the abbrev symbol if it did expansion, @code{nil} otherwise.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande étend la abbrev avant le point, le cas échéant. Si le point ne suit pas un abbrev, cette commande ne fait rien. La commande retourne le symbole de abbrev si elle ne l&apos;expansion, @ code {nil} autrement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the abbrev symbol has a hook function which is a symbol whose @code{no-self-insert} property is non-@code{nil}, and if the hook function returns @code{nil} as its value, then @code{expand-abbrev} returns @code{nil} even though expansion did occur.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le symbole de abbrev a une fonction de crochet qui est un symbole dont @ code {no-auto-insert} propriété est non @ code {nil}, et si la fonction de crochet retourne @ code {nil} comme sa valeur, alors @ code {expand-abbrev} retourne @ code {nil}, même si l&apos;expansion a eu lieu.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command abbrev-prefix-mark &amp;optional arg</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande abbrev-prefix-marque et en option arg</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command marks the current location of point as the beginning of an abbrev.  The next call to @code{expand-abbrev} will use the text from here to point (where it is then) as the abbrev to expand, rather than using the previous word as usual.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande marque l&apos;emplacement actuel du point que le début d&apos;une abbrev. Le prochain appel à @ code {expand-abbrev} utilisera le texte de signaler ici (où il est alors) que le abbrev à se développer, plutôt que d&apos;utiliser le mot précédent comme d&apos;habitude.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! First, this command expands any abbrev before point, unless @var{arg} is non-@code{nil}.  (Interactively, @var{arg} is the prefix argument.)  Then it inserts a hyphen before point, to indicate the start of the next abbrev to be expanded.  The actual expansion removes the hyphen.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tout d&apos;abord, cette commande se développe tout abbrev avant le point, à moins que @ var {arg} est non @ code {nil}. (Interactive, @ var {arg} est l&apos;argument de préfixe.) Ensuite, il insère un trait d&apos;union avant le point, pour indiquer le début de la prochaine abbrev être élargi. L&apos;expansion réelle supprime le trait d&apos;union.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When this is set non-@code{nil}, an abbrev entered entirely in upper case is expanded using all upper case.  Otherwise, an abbrev entered entirely in upper case is expanded by capitalizing each word of the expansion.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsqu&apos;il est réglé non @ code {nil}, un abbrev entré entièrement en majuscules est étendu en utilisant majuscules. Sinon, un abbrev entré entièrement en majuscules est élargi en capitalisant chaque mot de l&apos;expansion.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value of this variable is a buffer position (an integer or a marker)  for @code{expand-abbrev} to use as the start of the next abbrev to be expanded.  The value can also be @code{nil}, which means to use the word before point instead.  @code{abbrev-start-location} is set to @code{nil} each time @code{expand-abbrev} is called.  This variable is also set by @code{abbrev-prefix-mark}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable est une position de tampon (un entier ou un marqueur) pour @ code {expand-abbrev} à utiliser comme le début de la prochaine abbrev être élargi. La valeur peut aussi être @ code {nil}, ce qui signifie d&apos;utiliser le mot avant le point à la place. @ Code {abbrev-démarrage location} est réglé sur @ code {nil} chaque fois @ code {expand-abbrev} est appelé. Cette variable est également définie par @ code {abbrev-prefix-marque}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value of this variable is the buffer for which @code{abbrev-start-location} has been set.  Trying to expand an abbrev in any other buffer clears @code{abbrev-start-location}.  This variable is set by @code{abbrev-prefix-mark}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable est le tampon pour lequel @ code {abbrev-démarrage location} a été défini. Essayer de développer un abbrev dans tout autre tampon efface @ code {abbrev-démarrage location}. Cette variable est définie par @ code {abbrev-prefix-marque}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the @code{abbrev-symbol} of the most recent abbrev expanded.  This information is left by @code{expand-abbrev} for the sake of the @code{unexpand-abbrev} command (@pxref{Expanding Abbrevs,, Expanding Abbrevs, emacs, The GNU Emacs Manual}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est le code de @ {} abbrev-symbole de la abbrev plus récente élargi. Cette information est laissé par @ code {expand-abbrev} pour le bien de l&apos;{unexpand-abbrev} commande (@ de pxref {Expansion Abbrevs, Expansion Abbrevs, Les emacs, Le manuel de GNU Emacs}) @ code.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the location of the most recent abbrev expanded.  This contains information left by @code{expand-abbrev} for the sake of the @code{unexpand-abbrev} command.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ceci est l&apos;emplacement de la plus récente abrév expansé. Il contient des informations laissées par @ code {expand-abbrev} pour le bien de la commande {unexpand-de abbrev} @ code.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the exact expansion text of the most recent abbrev expanded, after case conversion (if any).  Its value is @code{nil} if the abbrev has already been unexpanded.  This contains information left by @code{expand-abbrev} for the sake of the @code{unexpand-abbrev} command.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ceci est le texte d&apos;extension exacte de la abbrev plus récente élargi, après la conversion de cas (le cas échéant). Sa valeur est @ code {nil} si la abbrev a déjà été non expansé. Il contient des informations laissées par @ code {expand-abbrev} pour le bien de la commande {unexpand-de abbrev} @ code.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is a normal hook whose functions are executed, in sequence, just before any expansion of an abbrev.  @xref{Hooks}.  Since it is a normal hook, the hook functions receive no arguments.  However, they can find the abbrev to be expanded by looking in the buffer before point.  Running the hook is the first thing that @code{expand-abbrev} does, and so a hook function can be used to change the current abbrev table before abbrev lookup happens.  (Although you have to do this carefully.  See the example below.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il s&apos;agit d&apos;un crochet normale dont les fonctions sont exécutées en séquence, juste avant toute expansion d&apos;un abbrev. @ Xref {} crochets. Puisqu&apos;il s&apos;agit d&apos;un crochet normal, les fonctions de raccordement reçoivent aucun argument. Cependant, ils peuvent trouver la abbrev à être élargi par la recherche dans la mémoire tampon avant le point. Courir le crochet est la première chose que @ code {expand-abbrev} fait, et ainsi une fonction de crochet peut être utilisé pour modifier la table de abbrev courant avant abbrev recherche arrive. (Bien que vous devez faire cela attentivement. Voir l&apos;exemple ci-dessous.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The following sample code shows a simple use of @code{pre-abbrev-expand-hook}.  It assumes that @code{foo-mode} is a mode for editing certain files in which lines that start with @samp{#} are comments.  You want to use Text mode abbrevs for those lines.  The regular local abbrev table, @code{foo-mode-abbrev-table} is appropriate for all other lines.  Then you can put the following code in your @file{.emacs} file.  @xref{Standard Abbrev Tables}, for the definitions of @code{local-abbrev-table} and @code{text-mode-abbrev-table}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;exemple de code suivant montre une utilisation simple de @ code {pré-abbrev-expand-crochet}. Il suppose que @ code {foo-mode} est un mode pour éditer certains fichiers dans les lignes qui commencent par @ samp {#} sont des commentaires. Vous souhaitez utiliser abbrevs en mode texte pour les lignes. Le tableau régulier de abbrev local, @ code {foo-mode-abbrev-table} est approprié pour toutes les autres lignes. Ensuite, vous pouvez mettre le code suivant dans votre fichier @ {. Emacs} du fichier. @ Xref {Tableaux standard Abbrev}, pour les définitions de @ code {local-abbrev-table} et @ code {text-mode-abbrev-table}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun foo-mode-pre-abbrev-expand ()<ph x="1">&lt;x0/&gt;</ph>  (when (save-excursion (forward-line 0) (eq (char-after) ?#))<ph x="2">&lt;x1/&gt;</ph>    (let ((local-abbrev-table text-mode-abbrev-table)<ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph>  ;; Avoid infinite loop.<ph x="5">&lt;x4/&gt;</ph><ph x="6">&lt;x5/&gt;</ph>  (pre-abbrev-expand-hook nil))<ph x="7">&lt;x6/&gt;</ph>      (expand-abbrev))<ph x="8">&lt;x7/&gt;</ph>    ;; We have already called `expand-abbrev&apos; in this hook.<ph x="9">&lt;x8/&gt;</ph>    ;; Hence we want the \&quot;actual\&quot; call following this hook to be a no-op.<ph x="10">&lt;x9/&gt;</ph>    (setq abbrev-start-location (point-max)<ph x="11">&lt;x10/&gt;</ph><ph x="12">&lt;x11/&gt;</ph>  abbrev-start-location-buffer (current-buffer))))<ph x="13">&lt;x12/&gt;</ph><ph x="14">&lt;x13/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun foo-mode pré-abbrev-expand () <ph x="1">&lt;x0/&gt;</ph> (Quand (save-excursion (avant-line 0) (eq (char-après)? #)) <ph x="2">&lt;x1/&gt;</ph> (Laisser ((local-abbrev table en mode texte-abbrev table) <ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph> ;; Évitez boucle infinie. <ph x="5">&lt;x4/&gt;</ph><ph x="6">&lt;x5/&gt;</ph> (Pré-abbrev-expand-crochet nil)) <ph x="7">&lt;x6/&gt;</ph> (Développez-abbrev)) <ph x="8">&lt;x7/&gt;</ph> ;; Nous avons déjà appelé `élargir-abbrev» dans ce crochet. <ph x="9">&lt;x8/&gt;</ph> ;; C&apos;est pourquoi nous voulons que le \ appel &quot;réelle \&quot; à la suite de ce crochet pour être un no-op. <ph x="10">&lt;x9/&gt;</ph> (Setq abbrev-start-lieu (point max) <ph x="11">&lt;x10/&gt;</ph><ph x="12">&lt;x11/&gt;</ph> abbrev-commencer-location-tampon (buffer courant)))) <ph x="13">&lt;x12/&gt;</ph><ph x="14">&lt;x13/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (add-hook &apos;foo-mode-hook<ph x="1">&lt;x0/&gt;</ph><ph x="2">&lt;x1/&gt;</ph>  #&apos;(lambda ()<ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph>      (add-hook &apos;pre-abbrev-expand-hook<ph x="5">&lt;x4/&gt;</ph><ph x="6">&lt;x5/&gt;</ph><ph x="7">&lt;x6/&gt;</ph><ph x="8">&lt;x7/&gt;</ph>&apos;foo-mode-pre-abbrev-expand<ph x="9">&lt;x8/&gt;</ph><ph x="10">&lt;x9/&gt;</ph><ph x="11">&lt;x10/&gt;</ph><ph x="12">&lt;x11/&gt;</ph>nil t)))<ph x="13">&lt;x12/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Add-hook &apos;foo-mode-hook <ph x="1">&lt;x0/&gt;</ph><ph x="2">&lt;x1/&gt;</ph> # &apos;(Lambda () <ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph> (Add-hook &apos;pré-abbrev-expand-crochet <ph x="5">&lt;x4/&gt;</ph><ph x="6">&lt;x5/&gt;</ph><ph x="7">&lt;x6/&gt;</ph><ph x="8">&lt;x7/&gt;</ph> «Foo-mode pré-abbrev-expand <ph x="9">&lt;x8/&gt;</ph><ph x="10">&lt;x9/&gt;</ph><ph x="11">&lt;x10/&gt;</ph><ph x="12">&lt;x11/&gt;</ph> nil t))) <ph x="13">&lt;x12/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Note that @code{foo-mode-pre-abbrev-expand} just returns @code{nil} without doing anything for lines not starting with @samp{#}.  Hence abbrevs expand normally using @code{foo-mode-abbrev-table} as local abbrev table for such lines.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Notez que @ code {foo-mode pré-abbrev-expand} retourne juste @ code {nil} sans rien faire pour les lignes ne commençant pas par @ samp {#}. Ainsi abbrevs développer normalement en utilisant @ code {foo-mode-abbrev-table} comme table de abbrev locale pour ces lignes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here we list the variables that hold the abbrev tables for the preloaded major modes of Emacs.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici une liste des variables qui contiennent les tables de abbrev pour les principaux modes préchargées d&apos;Emacs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the abbrev table for mode-independent abbrevs.  The abbrevs defined in it apply to all buffers.  Each buffer may also have a local abbrev table, whose abbrev definitions take precedence over those in the global table.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est la table de abbrev pour abbrevs mode indépendant. Les abbrevs y sont définis s&apos;appliquent à tous les tampons. Chaque tampon peut également avoir une table de abbrev local, dont abbrev définitions prévalent sur celles dans le tableau global.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value of this buffer-local variable is the (mode-specific)  abbreviation table of the current buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable locale de tampon est la table de l&apos;abréviation du tampon courant (mode spécifique).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the local abbrev table used in Fundamental mode; in other words, it is the local abbrev table in all buffers in Fundamental mode.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est la table de abbrev local utilisé en mode fondamental, en d&apos;autres mots, c&apos;est la table de abbrev locale dans tous les tampons en mode fondamental.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the local abbrev table used in Text mode.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est la table de abbrev local utilisé en mode texte.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the local abbrev table used in Lisp mode and Emacs Lisp mode.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est la table de abbrev local utilisé en mode Lisp et le mode Emacs Lisp.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Advising Functions</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Conseiller Fonctions</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Debugging</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Débogage</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Byte Compilation</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Byte Compilation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Advising Emacs Lisp Functions</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Conseiller fonctions Emacs Lisp</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! advising functions</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fonctions de conseiller</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @dfn{advice} feature lets you add to the existing definition of a function, by @dfn{advising the function}.  This is a cleaner method for a library to customize functions defined within Emacs---cleaner than redefining the whole function.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ dfn {} conseils vous permet d&apos;ajouter à la définition actuelle d&apos;une fonction, par @ dfn {conseiller la fonction}. Il s&apos;agit d&apos;une méthode plus propre pour une bibliothèque de personnaliser les fonctions définies dans Emacs --- plus propre que la redéfinition de la fonction entière.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! piece of advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>conseil</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Each function can have multiple @dfn{pieces of advice}, separately defined.  Each defined piece of advice can be @dfn{enabled} or @dfn{disabled} explicitly.  All the enabled pieces of advice for any given function actually take effect when you @dfn{activate} advice for that function, or when you define or redefine the function.  Note that enabling a piece of advice and activating advice for a function are not the same thing.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Chaque fonction peut avoir plusieurs @ dfn {} morceaux de conseils, définie séparément. Chaque morceau de conseil peut être défini @ dfn {} permis ou @ dfn {} désactivé explicitement. Toutes les pièces ont permis de conseil pour toute fonction donnée ne prennent effet lorsque vous @ dfn {Activer} conseils pour cette fonction, ou lorsque vous définissez ou redéfinissez la fonction. Notez que l&apos;activation d&apos;un morceau de conseils et d&apos;activation des conseils pour une fonction ne sont pas la même chose.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @strong{Usage Note:} Advice is useful for altering the behavior of existing calls to an existing function.  If you want the new behavior for new calls, or for key bindings, you should define a new function (or a new command) which uses the existing function.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Strong {Remarque sur l&apos;utilisation:} Conseils est utile pour modifier le comportement des appels existants à une fonction existante. Si vous voulez que le nouveau comportement de nouveaux appels, ou pour les raccourcis clavier, vous devez définir une nouvelle fonction (ou une nouvelle commande) qui utilise la fonction existante.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @strong{Usage note:} Advising a function can cause confusion in debugging, since people who debug calls to the original function may not notice that it has been modified with advice.  Therefore, if you have the possibility to change the code of that function (or ask someone to do so) to run a hook, please solve the problem that way.  Advice should be reserved for the cases where you cannot get the function changed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Strong {Note d&apos;utilisation:} Conseils fonction peut causer de la confusion dans le débogage, car les gens qui débogage des appels à la fonction d&apos;origine peuvent ne pas remarquer qu&apos;il a été modifié avec des conseils. Par conséquent, si vous avez la possibilité de modifier le code de cette fonction (ou demander à quelqu&apos;un de le faire) pour exécuter un crochet, s&apos;il vous plaît résoudre le problème de cette façon. Un avis doit être réservée aux cas où vous ne pouvez pas obtenir la fonction a changé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In particular, this means that a file in Emacs should not put advice on a function in Emacs.  There are currently a few exceptions to this convention, but we aim to correct them.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>En particulier, cela signifie qu&apos;un fichier dans Emacs ne devrait pas mettre des conseils sur une fonction dans Emacs. Il n&apos;y a quelques exceptions à cette convention, mais nous cherchons à les corriger.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Simple Advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Des conseils simples</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A simple example to explain the basics of advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un exemple simple pour expliquer les rudiments de conseils.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Defining Advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Définition conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Detailed description of @code{defadvice}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Description détaillée de @ code {} defadvice.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Around-Advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Autour-conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Wrapping advice around a function&apos;s definition.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des conseils d&apos;emballage autour de la définition d&apos;une fonction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Computed Advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Conseils calculé</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ...is to @code{defadvice} as @code{fset} is to @code{defun}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>... Est à @ code {} defadvice que @ code {} fset est à @ code {} defun.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Activation of Advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Activation de conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Advice doesn&apos;t do anything until you activate it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Conseils ne fait rien jusqu&apos;à ce que vous l&apos;activez.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Enabling Advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Conseils permettant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You can enable or disable each piece of advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous pouvez activer ou désactiver chaque conseil.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Preactivation</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Préactivation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Preactivation is a way of speeding up the</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pré-activation est un moyen d&apos;accélérer la</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! loading of compiled advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>chargement des conseils compilé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Argument Access in Advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Argument accès dans les conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How advice can access the function&apos;s arguments.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment conseils peuvent accéder aux arguments de la fonction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Advising Primitives</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Conseiller Primitives</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Accessing arguments when advising a primitive.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Accès arguments pour conseiller une primitive.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Combined Definition</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Définition combinée</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How advice is implemented.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment des conseils est mis en œuvre.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A Simple Advice Example</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un exemple simple: les conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The command @code{next-line} moves point down vertically one or more lines; it is the standard binding of @kbd{C-n}.  When used on the last line of the buffer, this command inserts a newline to create a line to move to if @code{next-line-add-newlines} is non-@code{nil} (its default is @code{nil}.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les commandes @ code {prochaine ligne} déplace le point à la verticale une ou plusieurs lignes, c&apos;est la liaison de @ kbd {Cn} standard. Lorsqu&apos;il est utilisé sur la dernière ligne du tampon, cette commande insère un saut de ligne pour créer une ligne pour passer à si @ code {next-line-add-retours à la ligne} est non @ code {nil} (sa valeur par défaut est @ code {nil }.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Suppose you wanted to add a similar feature to @code{previous-line}, which would insert a new line at the beginning of the buffer for the command to move to (when @code{next-line-add-newlines} is non-@code{nil}).  How could you do this?</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Supposons que vous vouliez ajouter une fonctionnalité similaire à @ code {précédente ligne}, visant à insérer une nouvelle ligne au début de la mémoire tampon de la commande pour passer à (quand @ code {next-line-add-retours à la ligne} est non - @ code {nil}). Comment pouvez-vous faire cela?</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You could do it by redefining the whole function, but that is not modular.  The advice feature provides a cleaner alternative: you can effectively add your code to the existing function definition, without actually changing or even seeing that definition.  Here is how to do this:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous pourriez le faire en redéfinissant la fonction ensemble, mais ce n&apos;est pas modulaire. La fonction de conseil fournit une alternative plus propre: vous pouvez effectivement ajouter votre code à la définition de la fonction existante, sans modifier ou même de voir cette définition. Voici comment faire:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defadvice previous-line (before next-line-at-end<ph x="1">&lt;x0/&gt;</ph>                                 (&amp;optional arg try-vscroll))<ph x="2">&lt;x1/&gt;</ph>  \&quot;Insert an empty line when moving up from the top line.\&quot;<ph x="3">&lt;x2/&gt;</ph>  (if (and next-line-add-newlines (= arg 1)<ph x="4">&lt;x3/&gt;</ph>           (save-excursion (beginning-of-line) (bobp)))<ph x="5">&lt;x4/&gt;</ph>      (progn<ph x="6">&lt;x5/&gt;</ph>        (beginning-of-line)<ph x="7">&lt;x6/&gt;</ph>        (newline))))<ph x="8">&lt;x7/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defadvice précédente ligne (avant la prochaine ligne à la fin <ph x="1">&lt;x0/&gt;</ph> (Et en option arg try-VScroll)) <ph x="2">&lt;x1/&gt;</ph> \ &quot;Insérer une ligne vide lors du déplacement à partir de la première ligne. \&quot; <ph x="3">&lt;x2/&gt;</ph> (Si (et la prochaine ligne-add-retours à la ligne (= arg 1) <ph x="4">&lt;x3/&gt;</ph> (Save-excursion (début de ligne) (BOBP))) <ph x="5">&lt;x4/&gt;</ph> (Progn <ph x="6">&lt;x5/&gt;</ph> (Début de ligne) <ph x="7">&lt;x6/&gt;</ph> (Saut de ligne)))) <ph x="8">&lt;x7/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This expression defines a @dfn{piece of advice} for the function @code{previous-line}.  This piece of advice is named @code{next-line-at-end}, and the symbol @code{before} says that it is @dfn{before-advice} which should run before the regular definition of @code{previous-line}.  @code{(&amp;optional arg try-vscroll)} specifies how the advice code can refer to the function&apos;s arguments.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette expression définit une @ dfn {conseil} pour la fonction @ code {précédente ligne}. Ce conseil est nommé @ code {nouvelle ligne à la fin}, et le symbole @ code {avant} dit que c&apos;est @ dfn {avant} conseils qui devraient courir avant la définition ordinaire de @ code {précédente- ligne}. Code {(et en option arg try-VScroll)} @ spécifie comment le code de conseil peut se référer aux arguments de la fonction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When this piece of advice runs, it creates an additional line, in the situation where that is appropriate, but does not move point to that line.  This is the correct way to write the advice, because the normal definition will run afterward and will move back to the newly inserted line.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Quand ce conseil s&apos;exécute, il crée une ligne supplémentaire, dans le cas où cela est approprié, mais ne bouge pas le point de cette ligne. C&apos;est la bonne façon d&apos;écrire le conseil, parce que la définition normale de fonctionner après et revenir à la ligne nouvellement insérée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Defining the advice doesn&apos;t immediately change the function @code{previous-line}.  That happens when you @dfn{activate} the advice, like this:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Définir le conseil ne change pas immédiatement la fonction @ code {précédente ligne}. Cela se produit lorsque vous @ dfn {} activez le conseil, comme ceci:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (ad-activate &apos;previous-line)<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Ad-activate &apos;previous-line) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is what actually begins to use the advice that has been defined so far for the function @code{previous-line}.  Henceforth, whenever that function is run, whether invoked by the user with @kbd{C-p} or @kbd{M-x}, or called from Lisp, it runs the advice first, and its regular definition second.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est ce qui commence réellement à utiliser les conseils qui a été défini à ce jour pour la fonction @ code {précédente ligne}. Désormais, chaque fois que la fonction est exécutée, qu&apos;elle soit invoquée par l&apos;utilisateur avec @ kbd {Cp} ou @ kbd {Mx}, ou appelé à Lisp, il court le premier conseil, et sa définition régulière seconde.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This example illustrates before-advice, which is one @dfn{class} of advice: it runs before the function&apos;s base definition.  There are two other advice classes: @dfn{after-advice}, which runs after the base definition, and @dfn{around-advice}, which lets you specify an expression to wrap around the invocation of the base definition.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cet exemple illustre avant-conseils, qui est une @ dfn {} classe de conseil: il s&apos;exécute avant la définition de base de la fonction. Il existe deux autres classes de conseil: @ dfn {après avis}, ce qui va après la définition de base, et @ dfn {} autour-conseils, qui vous permet de spécifier une expression à enrouler autour de l&apos;invocation de la définition de base.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! defining advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>définissant des conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! advice, defining</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des conseils, définissant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To define a piece of advice, use the macro @code{defadvice}.  A call to @code{defadvice} has the following syntax, which is based on the syntax of @code{defun} and @code{defmacro}, but adds more:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour définir un conseil, utilisez la macro @ code {} defadvice. Un appel à @ code {} defadvice a la syntaxe suivante, qui est basé sur la syntaxe de @ code {defun} et @ code {} defmacro, mais ajoute plus:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defadvice @var{function} (@var{class} @var{name}<ph x="1">&lt;x0/&gt;</ph>                         @r{[}@var{position}@r{]} @r{[}@var{arglist}@r{]}<ph x="2">&lt;x1/&gt;</ph>                         @var{flags}...)<ph x="3">&lt;x2/&gt;</ph>  @r{[}@var{documentation-string}@r{]}<ph x="4">&lt;x3/&gt;</ph>  @r{[}@var{interactive-form}@r{]}<ph x="5">&lt;x4/&gt;</ph>  @var{body-forms}...)<ph x="6">&lt;x5/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defadvice @ var {fonction} (@ var {classe} @ var {name} <ph x="1">&lt;x0/&gt;</ph> @ R {[} @ var {position} @ r {]} @ r {[} @ {var arglist} @ r {]} <ph x="2">&lt;x1/&gt;</ph> @ Var {drapeaux} ...) <ph x="3">&lt;x2/&gt;</ph> @ R {[} @ {var documentation-string} @ r {]} <ph x="4">&lt;x3/&gt;</ph> @ R {[} @ {var interactive-forme} @ r {]} <ph x="5">&lt;x4/&gt;</ph> @ Var {corps-formes} ...) <ph x="6">&lt;x5/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here, @var{function} is the name of the function (or macro or special form) to be advised.  From now on, we will write just ``function&apos;&apos; when describing the entity being advised, but this always includes macros and special forms.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ici, @ var {fonction} est le nom de la fonction (ou macro ou forme spéciale) à être informé. A partir de maintenant, nous allons écrire juste `` fonction&apos;&apos; pour décrire l&apos;entité se faire conseiller, mais cela inclut toujours des macros et des formes spéciales.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In place of the argument list in an ordinary definition, an advice definition calls for several different pieces of information.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>En lieu et place de la liste d&apos;arguments dans une définition ordinaire, une définition d&apos;avis appelle plusieurs informations différentes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! class of advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>classe de conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! before-advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>avant-conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! after-advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>après-conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! around-advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>autour-conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @var{class} specifies the @dfn{class} of the advice---one of @code{before}, @code{after}, or @code{around}.  Before-advice runs before the function itself; after-advice runs after the function itself; around-advice is wrapped around the execution of the function itself.  After-advice and around-advice can override the return value by setting @code{ad-return-value}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Var {class} spécifie le @ dfn {class} des conseils --- un de @ code {avant}, @ code code {} après, ou @ {} autour. Avant-conseils s&apos;exécute avant la fonction elle-même; après-conseils court après la fonction elle-même; tour des conseils est enroulé autour de l&apos;exécution de la fonction elle-même. Après-conseils et autour-conseils peut remplacer la valeur de retour en fixant @ code {ad-retour valeur}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ad-return-value</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>annonce-retour valeur</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! While advice is executing, after the function&apos;s original definition has been executed, this variable holds its return value, which will ultimately be returned to the caller after finishing all the advice.  After-advice and around-advice can arrange to return some other value by storing it in this variable.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Même si les conseils s&apos;exécute, après définition originale de la fonction a été exécutée, cette variable contient la valeur de retour, qui sera finalement renvoyé à l&apos;appelant après avoir terminé tous les conseils. Après-conseils et autour-conseils peuvent prendre des dispositions pour retourner une autre valeur en les stockant dans cette variable.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The argument @var{name} is the name of the advice, a non-@code{nil} symbol.  The advice name uniquely identifies one piece of advice, within all the pieces of advice in a particular class for a particular @var{function}.  The name allows you to refer to the piece of advice---to redefine it, or to enable or disable it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument @ var {name} est le nom de l&apos;avis, un non-@ code {nil} symbole. Le nom de conseil identifie de manière unique un conseil, dans tous les morceaux de conseils dans une classe particulière pour un {} fonction notamment @ var. Le nom vous permet de consulter le conseil --- à redéfinir, ou pour activer ou désactiver.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The optional @var{position} specifies where, in the current list of advice of the specified @var{class}, this new advice should be placed.  It should be either @code{first}, @code{last} or a number that specifies a zero-based position (@code{first} is equivalent to 0).  If no position is specified, the default is @code{first}.  Position values outside the range of existing positions in this class are mapped to the beginning or the end of the range, whichever is closer.  The @var{position} value is ignored when redefining an existing piece of advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;option @ var {position} spécifie où, dans la liste actuelle des conseils de la @ var spécifié {classe}, ce nouvel avis doit être placé. Il devrait être soit @ code {} première, @ code {} dernier ou un nombre qui indique la position de base zéro (@ code {} première est équivalent à 0). Si aucune position n&apos;est spécifiée, la valeur par défaut est @ code {} première. Les valeurs de position en dehors de la gamme de postes existants de cette classe sont mappés au début ou à la fin de la série, le plus rapproché. Le @ var {position} valeur est ignorée quand redéfinir un conseil existant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The optional @var{arglist} can be used to define the argument list for the sake of advice.  This becomes the argument list of the combined definition that is generated in order to run the advice (@pxref{Combined Definition}).  Therefore, the advice expressions can use the argument variables in this list to access argument values.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;option @ {var arglist} peut être utilisée pour définir la liste des arguments pour le bien de conseils. Cela devient la liste des arguments de la définition combinée qui est généré afin de lancer l&apos;avis (@ pxref {définition} combiné). Par conséquent, les expressions de conseils peuvent utiliser les variables d&apos;arguments dans cette liste pour accéder aux valeurs des arguments.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The argument list used in advice need not be the same as the argument list used in the original function, but must be compatible with it, so that it can handle the ways the function is actually called.  If two pieces of advice for a function both specify an argument list, they must specify the same argument list.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La liste des arguments utilisés dans le conseil ne doit pas être la même que la liste des arguments utilisés dans la fonction d&apos;origine, mais doit être compatible avec elle, de sorte qu&apos;il peut gérer les moyens de la fonction est en fait appelé. Si deux morceaux de conseils pour une fonction précise à la fois une liste d&apos;arguments, ils doivent spécifier le même liste d&apos;arguments.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @xref{Argument Access in Advice}, for more information about argument lists and advice, and a more flexible way for advice to access the arguments.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Xref {Argument accès dans les conseils}, pour plus d&apos;informations sur les listes d&apos;arguments et de conseils, et de manière plus flexible pour obtenir des conseils pour accéder aux arguments.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The remaining elements, @var{flags}, are symbols that specify further information about how to use this piece of advice.  Here are the valid symbols and their meanings:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les éléments restants, @ var {drapeaux}, sont des symboles qui spécifient plus d&apos;informations sur la façon d&apos;utiliser ce conseil. Voici les symboles valides et leurs significations:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! activate</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>activer</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Activate the advice for @var{function} now.  Changes in a function&apos;s advice always take effect the next time you activate advice for the function; this flag says to do so, for @var{function}, immediately after defining this piece of advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Activer les conseils pour @ var {fonction} maintenant. Les changements dans les conseils d&apos;une fonction prennent toujours effet la prochaine fois que vous activez des conseils pour la fonction, ce drapeau indique de le faire, pour @ var {fonction}, immédiatement après la définition de ce conseil.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! forward advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>conseils avant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This flag has no immediate effect if @var{function} itself is not defined yet (a situation known as @dfn{forward advice}), because it is impossible to activate an undefined function&apos;s advice.  However, defining @var{function} will automatically activate its advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cet indicateur n&apos;a pas d&apos;effet immédiat si @ var {fonction} lui-même n&apos;est pas encore définie (une situation connue sous le nom @ dfn {conseils avant}), car il est impossible d&apos;activer le conseil de une fonction non définie. Toutefois, la définition de @ var {fonction} activera automatiquement ses conseils.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! protect</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>protéger</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Protect this piece of advice against non-local exits and errors in preceding code and advice.  Protecting advice places it as a cleanup in an @code{unwind-protect} form, so that it will execute even if the previous code gets an error or uses @code{throw}.  @xref{Cleanups}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Protégez ce conseil contre les sorties non-locaux et les erreurs de code et des conseils précédentes. Protéger des conseils place comme un nettoyage dans un @ code {détendre-protect} forme, de sorte qu&apos;il exécute même si le code précédent devient une erreur ou utilise @ code {} touche. @ Xref {} nettoyages.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! compile</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>compiler</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Compile the combined definition that is used to run the advice.  This flag is ignored unless @code{activate} is also specified.  @xref{Combined Definition}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Compiler la définition combinée qui est utilisé pour exécuter les conseils. Cet indicateur est ignoré à moins que @ code {Activer} est également spécifié. @ Xref {définition Combiné}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! disable</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>désactiver</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Initially disable this piece of advice, so that it will not be used unless subsequently explicitly enabled.  @xref{Enabling Advice}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Initialement désactiver ce conseil, de sorte qu&apos;il ne sera pas utilisé à moins que la suite explicitement permis. @ Xref {} Activation conseils.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! preactivate</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Préactivation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Activate advice for @var{function} when this @code{defadvice} is compiled or macroexpanded.  This generates a compiled advised definition according to the current advice state, which will be used during activation if appropriate.  @xref{Preactivation}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Activer des conseils pour @ var {fonction} lorsque cet @ code {} defadvice est compilé ou macroexpanded. Cela génère une définition conseillé établies selon l&apos;état actuel de conseils, qui sera utilisé lors de l&apos;activation, le cas échéant. @ Xref {} préactivation.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is useful only if this @code{defadvice} is byte-compiled.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce n&apos;est utile que si ce code {@} defadvice est compilé en.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The optional @var{documentation-string} serves to document this piece of advice.  When advice is active for @var{function}, the documentation for @var{function} (as returned by @code{documentation}) combines the documentation strings of all the advice for @var{function} with the documentation string of its original function definition.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;option @ {var documentation-string} sert à documenter ce conseil. Lorsque des conseils est actif pour @ var {fonction}, la documentation de @ var {fonction} (comme retourné par @ code {documentation}) combine les chaînes de documentation de tous les conseils pour @ var {fonction} avec la chaîne de documentation de son origine définition de fonction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The optional @var{interactive-form} form can be supplied to change the interactive behavior of the original function.  If more than one piece of advice has an @var{interactive-form}, then the first one (the one with the smallest position) found among all the advice takes precedence.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;option @ {var interactive-forme} forme peut être amené à modifier le comportement interactif de la fonction d&apos;origine. Si plus d&apos;un conseil a un @ {var interactive-forme}, puis le premier (celui avec le plus petit poste) trouvée parmi tous les conseils a priorité.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The possibly empty list of @var{body-forms} specifies the body of the advice.  The body of an advice can access or change the arguments, the return value, the binding environment, and perform any other kind of side effect.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La liste peut être vide de @ var {corps-formes} spécifie le corps de l&apos;avis. Le corps d&apos;un avis peut accéder ou modifier les arguments, la valeur de retour, l&apos;environnement contraignant, et effectuer un autre type d&apos;effet secondaire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @strong{Warning:} When you advise a macro, keep in mind that macros are expanded when a program is compiled, not when a compiled program is run.  All subroutines used by the advice need to be available when the byte compiler expands the macro.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Strong {Attention:} Lorsque vous conseillez une macro, garder à l&apos;esprit que les macros sont développées quand un programme est compilé, pas quand un programme compilé est exécuté. Tous les sous-programmes utilisés par les conseils doivent être disponibles lorsque le compilateur de byte élargit la macro.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-unadvise function</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Fonction ad-unadvise commande</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command deletes the advice from @var{function}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande supprime les conseils de @ var {fonction}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-unadvise-all</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-unadvise-tout</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command deletes all pieces of advice from all functions.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande supprime tous les morceaux de conseils de toutes les fonctions.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Around-advice lets you ``wrap&apos;&apos; a Lisp expression ``around&apos;&apos; the original function definition.  You specify where the original function definition should go by means of the special symbol @code{ad-do-it}.  Where this symbol occurs inside the around-advice body, it is replaced with a @code{progn} containing the forms of the surrounded code.  Here is an example:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Autour-conseils vous permet de `` enveloppe&apos;&apos; une expression Lisp `` autour&apos;&apos; la définition de la fonction d&apos;origine. Vous spécifiez où la définition de la fonction d&apos;origine devrait aller au moyen du symbole spécial @ code {ad-do-it}. Lorsque ce symbole se produit à l&apos;intérieur du corps autour-conseil, il est remplacé par un @ code {} progn contenant les formes de code entouré. Voici un exemple:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defadvice foo (around foo-around)<ph x="1">&lt;x0/&gt;</ph>  \&quot;Ignore case in `foo&apos;.\&quot;<ph x="2">&lt;x1/&gt;</ph>  (let ((case-fold-search t))<ph x="3">&lt;x2/&gt;</ph>    ad-do-it))<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defadvice foo (environ foo autour) <ph x="1">&lt;x0/&gt;</ph> \ &quot;Ignorer la casse dans foo. \&quot; <ph x="2">&lt;x1/&gt;</ph> (Laisser ((cas-fold-search t)) <ph x="3">&lt;x2/&gt;</ph> annonce-do-it)) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Its effect is to make sure that case is ignored in searches when the original definition of @code{foo} is run.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Son effet est de faire en sorte que la casse est ignorée dans les recherches quand la définition originale de @ code {foo} est exécuté.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ad-do-it</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>annonce-do-it</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is not really a variable, rather a place-holder that looks like a variable.  You use it in around-advice to specify the place to run the function&apos;s original definition and other ``earlier&apos;&apos; around-advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce n&apos;est pas vraiment une variable plutôt une place de titulaire qui ressemble à une variable. Vous pouvez l&apos;utiliser en tour des conseils à préciser le lieu de courir définition originale de la fonction et d&apos;autres `` tôt&apos;&apos; tour des conseils.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the around-advice does not use @code{ad-do-it}, then it does not run the original function definition.  This provides a way to override the original definition completely.  (It also overrides lower-positioned pieces of around-advice).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le tour des conseils n&apos;utilise pas @ code {ad-do-it}, alors il ne fonctionne pas à la définition de la fonction d&apos;origine. Cela fournit un moyen de passer outre la définition originale complètement. (Il remplace aussi des pièces inférieures positionné d&apos;environ-conseils).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the around-advice uses @code{ad-do-it} more than once, the original definition is run at each place.  In this way, around-advice can execute the original definition (and lower-positioned pieces of around-advice)  several times.  Another way to do that is by using @code{ad-do-it} inside of a loop.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le tour des conseils utilise @ code {ad-do-it} plus d&apos;une fois, la définition originale est exécuté à chaque endroit. De cette façon, environ-conseils peut exécuter la définition originale (et morceaux d&apos;environ-conseils inférieur positionné) à plusieurs reprises. Une autre façon de le faire est d&apos;utiliser @ code {ad-do-it} à l&apos;intérieur d&apos;une boucle.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The macro @code{defadvice} resembles @code{defun} in that the code for the advice, and all other information about it, are explicitly stated in the source code.  You can also create advice whose details are computed, using the function @code{ad-add-advice}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La macro @ code {} defadvice ressemble à @ code {} defun en ce que le code pour les conseils, et toute autre information à ce sujet, sont explicitement dans le code source. Vous pouvez également créer des conseils dont les coordonnées sont calculées en utilisant la fonction @ code {ad complément des conseils}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ad-add-advice function advice class position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>annonce-add-conseils position de classe des conseils de la fonction</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Calling @code{ad-add-advice} adds @var{advice} as a piece of advice to @var{function} in class @var{class}.  The argument @var{advice} has this form:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Appel @ code {ad-add-conseils} ajoute @ var {} des conseils comme un conseil de @ var {fonction} dans la classe @ var {class}. L&apos;argument @ {var} conseils a ce formulaire:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (@var{name} @var{protected} @var{enabled} @var{definition})<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(@ Var {name} @ var {protected} @ {var permis} @ {var définition}) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here @var{protected} and @var{enabled} are flags, and @var{definition} is the expression that says what the advice should do.  If @var{enabled} is @code{nil}, this piece of advice is initially disabled (@pxref{Enabling Advice}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici @ var {protected} et @ var {} sont permis drapeaux, et @ var {définition} est l&apos;expression qui dit que le conseil doit faire. Si @ var {} est permis @ code {nil}, ce conseil est initialement désactivée (@ pxref {Activation conseils}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{function} already has one or more pieces of advice in the specified @var{class}, then @var{position} specifies where in the list to put the new piece of advice.  The value of @var{position} can either be @code{first}, @code{last}, or a number (counting from 0 at the beginning of the list).  Numbers outside the range are mapped to the beginning or the end of the range, whichever is closer.  The @var{position} value is ignored when redefining an existing piece of advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {fonction} a déjà un ou plusieurs morceaux de conseils dans le @ var spécifié {classe}, puis @ var {position} spécifie où dans la liste pour mettre le nouveau conseil. La valeur de @ var {position} peut être soit @ code {} première, @ code {} dernier, ou un certain nombre (en partant de 0 au début de la liste). Numéros en dehors de la gamme sont mappés au début ou à la fin de la gamme, le plus rapproché. Le @ var {position} valeur est ignorée quand redéfinir un conseil existant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{function} already has a piece of @var{advice} with the same name, then the position argument is ignored and the old advice is replaced with the new one.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {fonction} a déjà un morceau de @ var {} des conseils avec le même nom, alors l&apos;argument de position est ignoré et l&apos;ancien conseil est remplacé par le nouveau.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! activating advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>l&apos;activation des conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! advice, activating</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des conseils, activation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! By default, advice does not take effect when you define it---only when you @dfn{activate} advice for the function that was advised.  However, the advice will be activated automatically if you define or redefine the function later.  You can request the activation of advice for a function when you define the advice, by specifying the @code{activate} flag in the @code{defadvice}.  But normally you activate the advice for a function by calling the function @code{ad-activate} or one of the other activation commands listed below.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Par défaut, le conseil ne prend effet lorsque vous définissez --- uniquement lorsque vous @ dfn {Activer} des conseils pour la fonction qui a été conseillé. Toutefois, le conseil sera activé automatiquement si vous définissez ou redéfinissez la fonction plus tard. Vous pouvez demander l&apos;activation de conseils pour une fonction lorsque vous définissez les conseils, en spécifiant le @ code {drapeau activate} dans le code de @ {} de defadvice. Mais normalement, vous activez les conseils pour une fonction en appelant la fonction @ code {ad-activate} ou l&apos;une des autres commandes d&apos;activation ci-dessous.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Separating the activation of advice from the act of defining it permits you to add several pieces of advice to one function efficiently, without redefining the function over and over as each advice is added.  More importantly, it permits defining advice for a function before that function is actually defined.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La séparation de l&apos;activation des conseils de l&apos;acte de définir vous permet d&apos;ajouter plusieurs conseils pour un bon fonctionnement, sans redéfinir la fonction encore et que chaque conseil est ajouté. Plus important encore, il permet des conseils définissant une fonction avant que la fonction est en fait défini.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When a function&apos;s advice is first activated, the function&apos;s original definition is saved, and all enabled pieces of advice for that function are combined with the original definition to make a new definition.  (Pieces of advice that are currently disabled are not used; see @ref{Enabling Advice}.)  This definition is installed, and optionally byte-compiled as well, depending on conditions described below.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque le conseil d&apos;une fonction n&apos;est activée, la définition originale de la fonction est enregistrée, et tous les morceaux permis de conseils pour cette fonction sont combinés avec la définition originale de faire une nouvelle définition. (Pièces de conseils qui sont actuellement désactivée ne sont pas utilisés; voir @ ref {} Activation conseils.) Cette définition est installé, et éventuellement octet compilé ainsi, selon les conditions décrites ci-dessous.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In all of the commands to activate advice, if @var{compile} is @code{t} (or anything but @code{nil} or a negative number), the command also compiles the combined definition which implements the advice.  If it is @code{nil} or a negative number, what happens depends on @code{ad-default-compilation-action} as described below.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Dans toutes les commandes pour activer conseil, si @ var {compiler} est @ code {t} (ou quoi que ce soit mais @ code {nil} ou un nombre négatif), la commande compile également la définition combinée qui met en œuvre les conseils. Si elle est @ code {nil} ou un nombre négatif, ce qui se passe dépend de @ code {ad-default-compilation-action} tel que décrit ci-dessous.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-activate function &amp;optional compile</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande la fonction ad-activation et la compilation en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command activates all the advice defined for @var{function}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande active tous les conseils défini pour @ var {fonction}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Activating advice does nothing if @var{function}&apos;s advice is already active.  But if there is new advice, added since the previous time you activated advice for @var{function}, it activates the new advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Activation des conseils ne fait rien si des conseils @ var {fonction} s &apos;est déjà actif. Mais s&apos;il ya un nouveau conseil, ajoutés depuis la dernière fois que vous avez activé des conseils pour @ var {fonction}, il active le nouveau conseil.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-deactivate function</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Fonction ad-Désactiver commande</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command deactivates the advice for @var{function}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande désactive les conseils pour @ var {fonction}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! deactivating advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des conseils désactivation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-update function &amp;optional compile</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande la fonction ad-mise à jour et de la compilation en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command activates the advice for @var{function} if its advice is already activated.  This is useful if you change the advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande active les conseils de @ var {fonction} si son avis est déjà activé. Ceci est utile si vous modifiez le conseil.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-activate-all &amp;optional compile</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-activate-tout et en option de compilation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command activates the advice for all functions.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande active les conseils pour toutes les fonctions.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-deactivate-all</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-Désactiver tous</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command deactivates the advice for all functions.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande désactive les conseils pour toutes les fonctions.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-update-all &amp;optional compile</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-update-all et option de compilation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command activates the advice for all functions whose advice is already activated.  This is useful if you change the advice of some functions.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande active l&apos;avis de toutes les fonctions dont les conseils est déjà activé. Ceci est utile si vous modifiez les conseils de certaines fonctions.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-activate-regexp regexp &amp;optional compile</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-activate-regexp regexp et la compilation en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command activates all pieces of advice whose names match @var{regexp}.  More precisely, it activates all advice for any function which has at least one piece of advice that matches @var{regexp}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande active tous les morceaux de conseils dont le match @ var {expression rationnelle} noms. Plus précisément, il active tous les conseils pour toute fonction qui comporte au moins un conseil qui correspond @ var {expression rationnelle}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-deactivate-regexp regexp</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-Désactiver-regexp regexp</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command deactivates all pieces of advice whose names match @var{regexp}.  More precisely, it deactivates all advice for any function which has at least one piece of advice that matches @var{regexp}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande désactive tous les morceaux de conseils dont le match @ var {expression rationnelle} noms. Plus précisément, il désactive tous les conseils pour toute fonction qui comporte au moins un conseil qui correspond @ var {expression rationnelle}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-update-regexp regexp &amp;optional compile</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-update-expression rationnelle regexp et la compilation en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command activates pieces of advice whose names match @var{regexp}, but only those for functions whose advice is already activated.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande active morceaux de conseils dont les noms correspondent @ var {} expression rationnelle, mais seulement ceux pour les fonctions dont les conseils est déjà activé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! reactivating advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des conseils réactiver</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Reactivating a function&apos;s advice is useful for putting into effect all the changes that have been made in its advice (including enabling and disabling specific pieces of advice; @pxref{Enabling Advice}) since the last time it was activated.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Réactivation de l&apos;avis d&apos;une fonction est utile pour mettre en œuvre tous les changements qui ont été faites dans son avis (y compris l&apos;activation et la désactivation des éléments spécifiques de conseils, @ pxref {} Activation conseils) depuis la dernière fois qu&apos;il a été activé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-start-advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-début-conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Turn on automatic advice activation when a function is defined or redefined.  This is the default mode.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tournez sur l&apos;activation du conseil automatique lorsqu&apos;une fonction est définie ou redéfinie. Ceci est le mode par défaut.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-stop-advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-stop-conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Turn off automatic advice activation when a function is defined or redefined.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Désactiver l&apos;activation de conseil automatique lorsqu&apos;une fonction est définie ou redéfinie.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable controls whether to compile the combined definition that results from activating advice for a function.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable contrôle si pour compiler la définition combinée qui résulte de l&apos;activation des conseils pour une fonction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A value of @code{always} specifies to compile unconditionally.  A value of @code{never} specifies never compile the advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une valeur de @ code {} spécifie toujours à compiler de manière inconditionnelle. Une valeur de @ code {} ne précise jamais compiler les conseils.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A value of @code{maybe} specifies to compile if the byte-compiler is already loaded.  A value of @code{like-original} specifies to compile the advice if the original definition of the advised function is compiled or a built-in function.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une valeur de @ code {} spécifie peut-être à compiler si le byte-compilateur est déjà chargé. Une valeur de @ code {comme original} spécifie pour compiler le conseil si la définition originale de la fonction conseillé est compilé ou une fonction intégrée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable takes effect only if the @var{compile} argument of @code{ad-activate} (or any of the above functions) did not force compilation.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable prend effet que si le @ {var} compiler argument @ code {ad-activate} (ou l&apos;une des fonctions ci-dessus) n&apos;a pas forcé la compilation.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the advised definition was constructed during ``preactivation&apos;&apos; (@pxref{Preactivation}), then that definition must already be compiled, because it was constructed during byte-compilation of the file that contained the @code{defadvice} with the @code{preactivate} flag.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si la définition conseillé a été construit pendant `` pré-activation&apos;&apos; (@ pxref {} préactivation), alors que la définition doit être déjà compilé, car il a été construit au cours de byte-compilation du fichier qui contient le code de @ {} de defadvice avec le @ code {} Préactivation drapeau.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Enabling and Disabling Advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Activation et désactivation de conseils</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! enabling advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des conseils permettant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! advice, enabling and disabling</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des conseils, activation et la désactivation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! disabling advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des conseils désactivation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Each piece of advice has a flag that says whether it is enabled or not.  By enabling or disabling a piece of advice, you can turn it on and off without having to undefine and redefine it.  For example, here is how to disable a particular piece of advice named @code{my-advice} for the function @code{foo}:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Chaque conseil a un drapeau qui indique s&apos;il est activé ou non. En activant ou désactivant un morceau de conseils, vous pouvez allumer et éteindre sans avoir à annuler la définition et la redéfinir. Par exemple, voici comment désactiver un élément particulier de conseils nommé @ code {ma-conseils} pour la fonction @ code {foo}:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (ad-disable-advice &apos;foo &apos;before &apos;my-advice)<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Ad-disable-conseils &apos;foo&apos; avant &apos;ma-conseils) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function by itself only changes the enable flag for a piece of advice.  To make the change take effect in the advised definition, you must activate the advice for @code{foo} again:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction en elle-même ne change que le drapeau activer pour un conseil. Pour que les modifications prennent effet dans la définition conseillé, vous devez activer les conseils de @ code {foo} à nouveau:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (ad-activate &apos;foo)<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Ad-activate &apos;foo) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-disable-advice function class name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-disable-conseils nom de la classe de fonction</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command disables the piece of advice named @var{name} in class @var{class} on @var{function}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande désactive le conseil nommé @ var {name} dans la classe @ var {class} sur @ var {fonction}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-enable-advice function class name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-enable-conseils nom de la classe de fonction</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command enables the piece of advice named @var{name} in class @var{class} on @var{function}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande permet au conseil nommé @ var {name} dans la classe @ var {class} sur @ var {fonction}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You can also disable many pieces of advice at once, for various functions, using a regular expression.  As always, the changes take real effect only when you next reactivate advice for the functions in question.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous pouvez également désactiver de nombreux morceaux de conseils à la fois, pour diverses fonctions, en utilisant une expression régulière. Comme toujours, les changements prennent effet réel que lorsque vous réactivez prochaine des conseils pour les fonctions en question.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-disable-regexp regexp</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-disable-expression rationnelle regexp</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command disables all pieces of advice whose names match @var{regexp}, in all classes, on all functions.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande désactive tous les morceaux de conseils dont les noms correspondent @ var {} expression rationnelle, dans toutes les classes, sur toutes les fonctions.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command ad-enable-regexp regexp</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ad-enable-expression rationnelle regexp</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command enables all pieces of advice whose names match @var{regexp}, in all classes, on all functions.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande permet à tous les morceaux de conseils dont les noms correspondent @ var {} expression rationnelle, dans toutes les classes, sur toutes les fonctions.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! preactivating advice</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des conseils préactivation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! advice, preactivating</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des conseils, Préactiver</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Constructing a combined definition to execute advice is moderately expensive.  When a library advises many functions, this can make loading the library slow.  In that case, you can use @dfn{preactivation} to construct suitable combined definitions in advance.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Construire une définition combinée à exécuter des conseils est relativement cher. Quand une bibliothèque conseille de nombreuses fonctions, ce qui peut rendre le chargement de la bibliothèque lente. Dans ce cas, vous pouvez utiliser @ dfn {} pré-activation de construire définitions combinés adaptés à l&apos;avance.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To use preactivation, specify the @code{preactivate} flag when you define the advice with @code{defadvice}.  This @code{defadvice} call creates a combined definition which embodies this piece of advice (whether enabled or not) plus any other currently enabled advice for the same function, and the function&apos;s own definition.  If the @code{defadvice} is compiled, that compiles the combined definition also.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour utiliser pré-activation, indiquez le @ code {drapeau de Préactivation} lorsque vous définissez les conseils de @ code {} defadvice. Ce code {@} defadvice appel crée une définition combinée qui incarne ce conseil (si activé ou non) ainsi que tout autre avis actuellement activé pour la même fonction, et la propre définition de la fonction. Si le code de @ {} de defadvice est compilé, qui compile la définition combinée également.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When the function&apos;s advice is subsequently activated, if the enabled advice for the function matches what was used to make this combined definition, then the existing combined definition is used, thus avoiding the need to construct one.  Thus, preactivation never causes wrong results---but it may fail to do any good, if the enabled advice at the time of activation doesn&apos;t match what was used for preactivation.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque le conseil de la fonction est activée ultérieurement, si le conseil activé la fonction correspond à ce qui a été utilisé pour faire cette définition combiné, puis la définition combinée existant est utilisé, évitant ainsi la nécessité de construire un. Ainsi, pré-activation ne provoque jamais de mauvais résultats --- mais il peut échouer à faire du bien, si le conseil a permis au moment de l&apos;activation ne correspond pas à ce qui a été utilisé pour pré-activation.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here are some symptoms that can indicate that a preactivation did not work properly, because of a mismatch.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici quelques symptômes qui peuvent indiquer qu&apos;une pré-activation ne fonctionne pas correctement, à cause d&apos;une incompatibilité.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Activation of the advised function takes longer than usual.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Activation de la fonction conseillé prend plus de temps que d&apos;habitude.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The byte-compiler gets loaded while an advised function gets activated.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le byte-compilateur est chargé tout une fonction conseillé s&apos;active.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{byte-compile} is included in the value of @code{features} even though you did not ever explicitly use the byte-compiler.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {byte-compilation} est inclus dans la valeur de @ code {caractéristiques} même si vous n&apos;avez pas utilisez jamais explicitement le byte-compilateur.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Compiled preactivated advice works properly even if the function itself is not defined until later; however, the function needs to be defined when you @emph{compile} the preactivated advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Des conseils préactivé compilé fonctionne correctement, même si la fonction elle-même n&apos;est pas défini plus tard, cependant, la fonction doit être définie lorsque vous compilez @ emph {} les conseils pré-activé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! There is no elegant way to find out why preactivated advice is not being used.  What you can do is to trace the function @code{ad-cache-id-verification-code} (with the function @code{trace-function-background}) before the advised function&apos;s advice is activated.  After activation, check the value returned by @code{ad-cache-id-verification-code} for that function: @code{verified} means that the preactivated advice was used, while other values give some information about why they were considered inappropriate.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il n&apos;existe aucun moyen élégant de savoir pourquoi des conseils pré-activé n&apos;est pas utilisé. Ce que vous pouvez faire est de tracer la fonction @ code {ad-cache-id-vérification-code} (avec le code fonction @ {tracer fonction-fond}) avant le conseil de la fonction conseillé est activée. Après l&apos;activation, vérifier la valeur retournée par @ code {ad-cache-id-vérification-code} pour cette fonction: @ code {} garantie signifie que le conseil pré-activé a été utilisé, tandis que d&apos;autres valeurs donnent des informations sur la raison pour laquelle ils ont été considérés comme inapproprié .</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @strong{Warning:} There is one known case that can make preactivation fail, in that a preconstructed combined definition is used even though it fails to match the current state of advice.  This can happen when two packages define different pieces of advice with the same name, in the same class, for the same function.  But you should avoid that anyway.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Strong {Attention:} Il ya un cas connu qui peut faire pré-activation sûr, dans une définition combinée préconstruit est utilisée, même si elle ne correspond pas à l&apos;état actuel de conseils. Cela peut se produire lorsque deux paquets définissent différents morceaux de conseils avec le même nom, dans la même classe, pour la même fonction. Mais vous devriez éviter de toute façon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The simplest way to access the arguments of an advised function in the body of a piece of advice is to use the same names that the function definition uses.  To do this, you need to know the names of the argument variables of the original function.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le plus simple pour accéder aux arguments d&apos;une fonction conseillé dans le corps d&apos;un morceau de conseil est d&apos;utiliser les mêmes noms que la définition de la fonction utilise. Pour ce faire, vous devez connaître les noms des variables d&apos;arguments de la fonction d&apos;origine.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! While this simple method is sufficient in many cases, it has a disadvantage: it is not robust, because it hard-codes the argument names into the advice.  If the definition of the original function changes, the advice might break.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Bien que cette méthode simple est suffisante dans de nombreux cas, il a un inconvénient: il n&apos;est pas robuste, car il code en dur les noms d&apos;arguments dans l&apos;avis. Si la définition de la fonction d&apos;origine change, le conseil pourrait se briser.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Another method is to specify an argument list in the advice itself.  This avoids the need to know the original function definition&apos;s argument names, but it has a limitation: all the advice on any particular function must use the same argument list, because the argument list actually used for all the advice comes from the first piece of advice for that function.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une autre méthode est de spécifier une liste d&apos;arguments dans le conseil lui-même. Cela évite la nécessité de connaître les noms des arguments de la définition de fonction d&apos;origine, mais il a une limitation: tous les conseils sur une fonction particulière doit utiliser la même liste d&apos;arguments, car la liste des arguments effectivement utilisé pour tous les conseils vient du premier conseil pour cette fonction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A more robust method is to use macros that are translated into the proper access forms at activation time, i.e., when constructing the advised definition.  Access macros access actual arguments by position regardless of how these actual arguments get distributed onto the argument variables of a function.  This is robust because in Emacs Lisp the meaning of an argument is strictly determined by its position in the argument list.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une méthode plus robuste consiste à utiliser des macros qui sont traduits dans les formes d&apos;accès appropriés au moment de l&apos;activation, à savoir, lors de la construction de la définition conseillé. macros Access accéder arguments réels par poste, indépendamment de la façon dont ces arguments réels sont-ils distribués sur les variables d&apos;arguments d&apos;une fonction. C&apos;est solide parce que dans Emacs Lisp le sens d&apos;un argument est strictement déterminé par sa position dans la liste d&apos;arguments.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ad-get-arg position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>la position ad-obtenir-arg</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This returns the actual argument that was supplied at @var{position}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cela retourne l&apos;argument réel qui a été fourni à @ var {position}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ad-get-args position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>la position ad-get-args</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This returns the list of actual arguments supplied starting at @var{position}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cela renvoie la liste des arguments réels fournis à partir de @ var {position}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ad-set-arg position value</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>annonce-set-arg valeur de position</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This sets the value of the actual argument at @var{position} to @var{value}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ceci définit la valeur de l&apos;argument actuel à @ var {position} à @ var {valeur}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ad-set-args position value-list</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>la position ad-set-args valeur-liste</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This sets the list of actual arguments starting at @var{position} to @var{value-list}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ceci définit la liste des arguments réels à partir de @ var {position} à @ var {value-list}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Now an example.  Suppose the function @code{foo} is defined as</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici maintenant un exemple. Supposons que le code fonction @ {foo} est défini comme</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun foo (x y &amp;optional z &amp;rest r) ...)<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun foo (xy et z en option et reste r) ...) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! and is then called with</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>et est ensuite appelé avec</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (foo 0 1 2 3 4 5 6)<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Foo 0 1 2 3 4 5 6) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! which means that @var{x} is 0, @var{y} is 1, @var{z} is 2 and @var{r} is @code{(3 4 5 6)} within the body of @code{foo}.  Here is what @code{ad-get-arg} and @code{ad-get-args} return in this case:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>ce qui signifie que @ var {x} est égal à 0, @ var {y} est égal à 1, @ var {z} est égal à 2 et @ var {r} est @ code {(3 4 5 6)} dans le corps de code {@ foo}. Voici ce que @ code {ad-get-arg} et @ code {ad-get-args} return dans ce cas:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (ad-get-arg 0) @result{} 0<ph x="1">&lt;x0/&gt;</ph>(ad-get-arg 1) @result{} 1<ph x="2">&lt;x1/&gt;</ph>(ad-get-arg 2) @result{} 2<ph x="3">&lt;x2/&gt;</ph>(ad-get-arg 3) @result{} 3<ph x="4">&lt;x3/&gt;</ph>(ad-get-args 2) @result{} (2 3 4 5 6)<ph x="5">&lt;x4/&gt;</ph>(ad-get-args 4) @result{} (4 5 6)<ph x="6">&lt;x5/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Ad-obtenir-arg 0) @ result {} 0 <ph x="1">&lt;x0/&gt;</ph> (Ad-obtenir-arg 1) @ result {} 1 <ph x="2">&lt;x1/&gt;</ph> (Ad-obtenir-arg 2) @ result {} 2 <ph x="3">&lt;x2/&gt;</ph> (Ad-obtenir-arg 3) @ result {} 3 <ph x="4">&lt;x3/&gt;</ph> (Ad-get-args 2) @ {} résultat (2 3 4 5 6) <ph x="5">&lt;x4/&gt;</ph> (Ad-get-args 4) @ result {} (4 5 6) <ph x="6">&lt;x5/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Setting arguments also makes sense in this example:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Réglage arguments est également judicieux dans cet exemple:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (ad-set-arg 5 \&quot;five\&quot;)<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Ad-mettre-arg 5 \ &quot;cinq \&quot;) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! has the effect of changing the sixth argument to @code{\&quot;five\&quot;}.  If this happens in advice executed before the body of @code{foo} is run, then @var{r} will be @code{(3 4 \&quot;five\&quot; 6)} within that body.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>a pour effet de modifier la sixième argument de @ code {\ &quot;cinq \&quot;}. Si cela se produit dans le conseil exécuté avant que le corps de @ code {foo} est exécuté, alors @ var {r} sera @ code {(3 4 \ &quot;cinq \&quot; 6)} dans ce corps.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here is an example of setting a tail of the argument list:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici un exemple de configuration d&apos;une queue de la liste d&apos;arguments:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (ad-set-args 0 &apos;(5 4 3 2 1 0))<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(annonce-set-args 0 &apos;(5 4 3 2 1 0)) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this happens in advice executed before the body of @code{foo} is run, then within that body, @var{x} will be 5, @var{y} will be 4, @var{z} will be 3, and @var{r} will be @code{(2 1 0)} inside the body of @code{foo}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cela se produit dans le conseil exécuté avant que le corps de @ code {foo} est exécuté, puis au sein de ce corps, @ var {x} sera 5, @ var {y} sera 4, @ var {z} sera 3, et @ var {r} sera @ code {(2 1 0)} à l&apos;intérieur du corps de @ code {foo}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These argument constructs are not really implemented as Lisp macros.  Instead they are implemented specially by the advice mechanism.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ces constructions d&apos;arguments ne sont pas vraiment mises en œuvre sous forme de macros Lisp. Au contraire, ils sont mis en œuvre spécialement par le mécanisme de conseil.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! advising primitives</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>conseiller primitives</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Advising a primitive function (also called a ``subr&apos;&apos;) is risky.  Some primitive functions are used by the advice mechanism; advising them could cause an infinite recursion.  Also, many primitive functions are called directly from C code.  Calls to the primitive from Lisp code will take note of the advice, but calls from C code will ignore the advice.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Conseiller une fonction primitive (également appelé `` subr&apos;&apos;) est risqué. Certaines fonctions primitives sont utilisées par le mécanisme de conseil; leur conseillant peuvent provoquer une récursion infinie. Aussi, beaucoup de fonctions primitives sont appelées directement à partir du code C. Les appels à la primitive du code Lisp prendront note de l&apos;avis, mais les appels à partir du code C vont ignorer les conseils.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When the advice facility constructs the combined definition, it needs to know the argument list of the original function.  This is not always possible for primitive functions.  When advice cannot determine the argument list, it uses @code{(&amp;rest ad-subr-args)}, which always works but is inefficient because it constructs a list of the argument values.  You can use @code{ad-define-subr-args} to declare the proper argument names for a primitive function:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque l&apos;installation de conseils construit la définition combinée, il doit connaître la liste des arguments de la fonction d&apos;origine. Ce n&apos;est pas toujours possible pour des fonctions primitives. Lorsque des conseils ne peut pas déterminer la liste des arguments, il utilise @ code {(et ad-subr-args repos)}, qui fonctionne toujours, mais est inefficace car il construit une liste des valeurs d&apos;argument. Vous pouvez utiliser @ code {ad subr-args définir-} pour déclarer les noms des arguments appropriés pour une fonction primitive:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ad-define-subr-args function arglist</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fonction ad-define-subr-args arglist</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function specifies that @var{arglist} should be used as the argument list for function @var{function}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction indique que @ var {} arglist devrait être utilisé comme liste d&apos;arguments pour la fonction @ var {fonction}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For example,</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Par exemple,</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (ad-define-subr-args &apos;fset &apos;(sym newdef))<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(&apos;Fset ad-define-subr-args (sym newdef)) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! specifies the argument list for the function @code{fset}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>précise la liste des arguments de la fonction @ code {} fset.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The Combined Definition</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La définition combinée</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Suppose that a function has @var{n} pieces of before-advice (numbered from 0 through @var{n}@minus{}1), @var{m} pieces of around-advice and @var{k} pieces of after-advice.  Assuming no piece of advice is protected, the combined definition produced to implement the advice for a function looks like this:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Supposons qu&apos;une fonction a @ var {n} morceaux de avant-conseils (numérotés de 0 à @ var {n} {} @ moins 1), @ var {m} morceaux d&apos;environ-conseils et @ var {k} morceaux de après-conseils. En supposant qu&apos;aucun morceau de conseil est protégé, la définition combinée produit à appliquer les conseils pour une fonction ressemble à ceci:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (lambda @var{arglist}<ph x="1">&lt;x0/&gt;</ph>  @r{[} @r{[}@var{advised-docstring}@r{]} @r{[}(interactive ...)@r{]} @r{]}<ph x="2">&lt;x1/&gt;</ph>  (let (ad-return-value)<ph x="3">&lt;x2/&gt;</ph>    @r{before-0-body-form}...<ph x="4">&lt;x3/&gt;</ph>         ....<ph x="5">&lt;x4/&gt;</ph>    @r{before-@var{n}@minus{}1-body-form}...<ph x="6">&lt;x5/&gt;</ph>    @r{around-0-body-form}...<ph x="7">&lt;x6/&gt;</ph>       @r{around-1-body-form}...<ph x="8">&lt;x7/&gt;</ph>             ....<ph x="9">&lt;x8/&gt;</ph>          @r{around-@var{m}@minus{}1-body-form}...<ph x="10">&lt;x9/&gt;</ph>             (setq ad-return-value<ph x="11">&lt;x10/&gt;</ph>                   @r{apply original definition to @var{arglist}})<ph x="12">&lt;x11/&gt;</ph>          @r{end-of-around-@var{m}@minus{}1-body-form}...<ph x="13">&lt;x12/&gt;</ph>             ....<ph x="14">&lt;x13/&gt;</ph>       @r{end-of-around-1-body-form}...<ph x="15">&lt;x14/&gt;</ph>    @r{end-of-around-0-body-form}...<ph x="16">&lt;x15/&gt;</ph>    @r{after-0-body-form}...<ph x="17">&lt;x16/&gt;</ph>          ....<ph x="18">&lt;x17/&gt;</ph>    @r{after-@var{k}@minus{}1-body-form}...<ph x="19">&lt;x18/&gt;</ph>    ad-return-value))<ph x="20">&lt;x19/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Lambda @ var {arglist} <ph x="1">&lt;x0/&gt;</ph> @ R {[} @ r {[} @ {var conseillé-docstring} @ r {]} @ r {[} (interactive ...) @ r {]} @ r {]} <ph x="2">&lt;x1/&gt;</ph> (Laisser (ad-retour valeur) <ph x="3">&lt;x2/&gt;</ph> @ R {avant-0-corps-forme} ... <ph x="4">&lt;x3/&gt;</ph> .... <ph x="5">&lt;x4/&gt;</ph> @ R {avant-@ var {n} @ minus {} 1-corps-forme} ... <ph x="6">&lt;x5/&gt;</ph> @ R {autour-0-corps-forme} ... <ph x="7">&lt;x6/&gt;</ph> @ R {autour-1-corps-forme} ... <ph x="8">&lt;x7/&gt;</ph> .... <ph x="9">&lt;x8/&gt;</ph> @ R {tour @ var {m} @ minus {} 1-corps-forme} ... <ph x="10">&lt;x9/&gt;</ph> (Setq ad-retour valeur <ph x="11">&lt;x10/&gt;</ph> @ R {appliquer la définition originale de @ var {arglist}}) <ph x="12">&lt;x11/&gt;</ph> @ R {fin de tour @ var {m} @ minus {} 1-corps-forme} ... <ph x="13">&lt;x12/&gt;</ph> .... <ph x="14">&lt;x13/&gt;</ph> @ R {fin de tour 1-corps-forme} ... <ph x="15">&lt;x14/&gt;</ph> @ R {fin de tour 0-corps-forme} ... <ph x="16">&lt;x15/&gt;</ph> @ R {après-0-corps-forme} ... <ph x="17">&lt;x16/&gt;</ph> .... <ph x="18">&lt;x17/&gt;</ph> @ R {après @ var {k} @ minus {} 1-corps-forme} ... <ph x="19">&lt;x18/&gt;</ph> annonce-retour valeur)) <ph x="20">&lt;x19/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Macros are redefined as macros, which means adding @code{macro} to the beginning of the combined definition.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les macros sont redéfinis comme des macros, ce qui signifie l&apos;ajout de @ code {macro} au début de la définition combinée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The interactive form is present if the original function or some piece of advice specifies one.  When an interactive primitive function is advised, advice uses a special method: it calls the primitive with @code{call-interactively} so that it will read its own arguments.  In this case, the advice cannot access the arguments.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le formulaire interactif est présent si la fonction d&apos;origine ou d&apos;un morceau de conseils spécifie un. Quand une fonction primitive interactive est conseillé, des conseils utilise une méthode particulière: il appelle la primitive avec @ code {appeler interactive} de sorte qu&apos;il va lire ses propres arguments. Dans ce cas, le conseil ne peut pas accéder aux arguments.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The body forms of the various advice in each class are assembled according to their specified order.  The forms of around-advice @var{l} are included in one of the forms of around-advice @var{l} @minus{} 1.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les formes du corps des différents conseils dans chaque catégorie sont assemblés en fonction de leur ordre spécifié. Les formes de l&apos;ordre de-conseils @ var {l} sont inclus dans l&apos;une des formes de l&apos;ordre de-conseils @ var {l} @ minus {} 1.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The innermost part of the around advice onion is</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La partie la plus profonde de l&apos;avis de l&apos;oignon est d&apos;environ</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! apply original definition to @var{arglist}<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>appliquer la définition originale de @ var {arglist} <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! whose form depends on the type of the original function.  The variable @code{ad-return-value} is set to whatever this returns.  The variable is visible to all pieces of advice, which can access and modify it before it is actually returned from the advised function.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>dont la forme dépend du type de la fonction d&apos;origine. La variable @ code {ad-retour valeur} est réglé à ce que cela retourne. La variable est visible à tous les morceaux de conseils, qui peuvent accéder et le modifier avant qu&apos;il ne soit retourné par la fonction conseillé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The semantic structure of advised functions that contain protected pieces of advice is the same.  The only difference is that @code{unwind-protect} forms ensure that the protected advice gets executed even if some previous piece of advice had an error or a non-local exit.  If any around-advice is protected, then the whole around-advice onion is protected as a result.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La structure sémantique des fonctions conseillés qui contiennent des pièces protégées de conseil est le même. La seule différence est que @ code {détendre-protéger} formes veiller à ce que les conseils protégé est exécuté même si une certaine précédente conseil avait une erreur ou une sortie non-locale. Si tout autour-conseils est protégé, l&apos;ensemble oignon autour-conseils est protégée en conséquence.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT!    arch-tag: 80c135c2-f1c3-4f8d-aa85-f8d8770d307f<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>arc-tag: 80c135c2-f1c3-4f8d-aa85-f8d8770d307f <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Antinews</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Antinews</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! GNU Free Documentation License</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>GNU Free Documentation License</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! System Interface</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Interface système</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs 21 Antinews</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs 21 Antinews</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For those users who live backwards in time, here is information about downgrading to Emacs version 21.4.  We hope you will enjoy the greater simplicity that results from the absence of many Emacs @value{EMACSVER} features.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour les utilisateurs qui vivent en arrière dans le temps, voici des informations sur le déclassement de la version d&apos;Emacs 21.4. Nous espérons que vous pourrez profiter de la plus grande simplicité qui résulte de l&apos;absence de nombreux Emacs @ valeur des caractéristiques {} EMACSVER.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Old Lisp Features in Emacs 21</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vieux Lisp Caractéristiques dans Emacs 21</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Many unnecessary features of redisplay have been eliminated.  (The earlier major release, Emacs 20, will have a completely rewritten redisplay engine, which will be even simpler.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Beaucoup de fonctionnalités inutiles de réaffichage ont été éliminés. (La version majeure antérieure, Emacs 20, aura un moteur de réaffichage complètement réécrit, qui sera encore plus simple.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{redisplay} has been removed.  To update the display without delay, call @code{(sit-for 0)}.  Since it is generally considered wasteful to update the display if there are any pending input events, no replacement for @code{(redisplay t)} is provided.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {} réaffichage a été supprimé. Pour mettre à jour l&apos;affichage sans délai, l&apos;appel @ code {(sit-à 0)}. Comme il est généralement considéré comme un gaspillage de mettre à jour l&apos;affichage s&apos;il ya des événements d&apos;entrée en attendant, pas de remplacement pour @ code {(réaffichage t)} est fourni.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{force-window-update} has been removed.  It shouldn&apos;t be needed, since changes in window contents are detected automatically.  In case they aren&apos;t, call @code{redraw-display} to redraw everything.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {force fenêtre de mise à jour} a été supprimé. Il ne devrait pas être nécessaire, car les changements de contenu de la fenêtre sont automatiquement détectés. Au cas où ils ne sont pas, appel @ code {redessiner affichage} pour tout redessiner.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Point no longer moves out from underneath invisible text at the end of each command.  This allows the user to detect invisible text by moving the cursor around---if the cursor gets stuck, there is something invisible in the way.  If you really want cursor motion to ignore the text, try marking it as intangible.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Point ne se déplace plus à partir de texte en dessous invisible à la fin de chaque commande. Cela permet à l&apos;utilisateur de détecter texte invisible en déplaçant le curseur sur --- si le curseur est bloqué, il est quelque chose d&apos;invisible dans le chemin. Si vous voulez vraiment le déplacement du curseur à ignorer le texte, essayez le marquant comme immatériel.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Support for image maps and image slices has been removed.  Emacs was always meant for editing text, anyway.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Support pour les cartes d&apos;image et de tranches d&apos;image a été supprimée. Emacs a toujours été destiné à l&apos;édition de texte, de toute façon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The mode line now accepts all text properties, as well as @code{:propertize} and @code{:eval} forms, regardless of the @code{risky-local-variable} property.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La ligne de mode accepte toutes les propriétés de texte, ainsi que @ code {: propertize} et @ code {}: eval formes, quel que soit le code @ {risqué-local-variable} propriété.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{line-height} and @code{line-spacing} properties no longer have any meaning for newline characters.  Such properties wouldn&apos;t make sense, since newlines are not really characters; they just tell you where to break a line.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ code {line-height} et @ code {interligne} propriétés n&apos;ont plus aucun sens pour les caractères de nouvelle ligne. Ces propriétés ne seraient pas de sens, puisque les sauts de ligne ne sont pas vraiment des personnages, ils vous diront exactement où couper une ligne.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Considerable simplifications have been made to the display specification @code{(space . @var{props})}, which is used for displaying a space of specified width and height.  Pixel-based specifications and Lisp expressions are no longer accepted.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Simplifications considérables ont été faits pour l&apos;affichage spécification @ code {(espace. @ {Var accessoires})}, qui est utilisé pour afficher un espace de largeur et la hauteur spécifiées. Spécifications à base de pixels et des expressions Lisp ne sont plus acceptés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Many features associated with the fringe areas have been removed, to encourage people to concentrate on the main editing area (the fringe will be completely removed in Emacs 20.)  Arbitrary bitmaps can no longer be displayed in the fringe; an overlay arrow can still be displayed, but there can only be one overlay arrow at a time (any more would be confusing.)  The fringe widths cannot be adjusted, and individual windows cannot have their own fringe settings.  A mouse click on the fringe no longer generates a special event.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>De nombreuses fonctionnalités associées aux domaines sociaux ont été supprimés, pour encourager les gens à se concentrer sur la zone d&apos;édition principale (la frange sera complètement supprimé dans Emacs 20.) Bitmaps arbitraires ne peuvent plus être affichés dans la frange; une flèche de recouvrement peut encore être affiché, mais il ne peut y avoir une flèche de superposition à la fois (plus serait source de confusion.) Les largeurs sociaux ne peuvent pas être ajusté, et des fenêtres individuelles ne peuvent pas avoir leurs propres paramètres sociaux. Un clic de souris sur la frange ne génère plus un événement spécial.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Individual windows cannot have their own scroll-bar settings.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fenêtres individuelles ne peuvent pas avoir leurs propres paramètres barre de défilement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You can no longer use @samp{default} in a @code{defface} to specify defaults for subsequent faces.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous ne pouvez plus utiliser @ samp {default} dans un @ code {} defface pour spécifier les valeurs par défaut pour les visages ultérieures.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{display-supports-face-attributes-p} has been removed.  In @code{defface} specifications, the @code{supports} predicate is no longer supported.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {display-supports-visage-attributs-p} a été supprimé. Dans @ code {} defface spécifications, le code {@} supports prédicat n&apos;est plus supporté.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The functions @code{merge-face-attribute} and @code{face-attribute-relative-p} have been removed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions @ code {fusion-face attribut} et @ code {face attribut-rapport-p} ont été supprimés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The priority of faces in a list supplied by the @code{:inherit} face attribute has been reversed.  We like to make changes like this once in a while, to keep Emacs Lisp programmers on their toes.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La priorité des visages dans une liste fournie par le code de @ {:} hériter attribut face a été inversée. Nous aimons faire des changements de ce genre de temps en temps, de garder les programmeurs Emacs Lisp sur leurs orteils.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{min-colors} face attribute, used for tailoring faces to limited-color displays, does not exist.  If in doubt, use colors like ``white&apos;&apos; and ``black,&apos;&apos; which ought to be defined everywhere.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code d&apos;attribut @ {min-couleurs} visage, utilisé pour adapter visages de couleurs limité affiche, n&apos;existe pas. En cas de doute, utilisez des couleurs comme `` blanc&apos;&apos; et `` noir,&apos;&apos; qui doit être défini partout.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{tty-color-mode} frame parameter does not exist.  You should just trust the terminal capabilities database.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code de @ n&apos;existe pas paramètre {tty-couleur-mode} cadre. Vous devez juste faire confiance à la base de données des capacités de terminaux.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Several simplifications have been made to mouse support:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Plusieurs simplifications ont été apportées au support de la souris:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Clicking @kbd{mouse-1} won&apos;t follow links, as that is alien to the spirit of Emacs.  Therefore, the @code{follow-link} property doesn&apos;t has any special meaning, and the function @code{mouse-on-link-p} has been removed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>En cliquant sur @ kbd {1}-souris ne sera pas suivre les liens, car c&apos;est contraire à l&apos;esprit d&apos;Emacs. Par conséquent, le code de @ {suite} lien établissement ne dispose pas de signification particulière, et la fonction @ code {souris sur le lien-p} a été supprimé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variable @code{void-text-area-pointer} has been removed, so the mouse pointer shape remains unchanged when moving between valid text areas and void text areas.  The @code{pointer} image and text properties are no longer supported.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La variable @ code {void texte de la zone pointeur} a été supprimé, si la forme du pointeur de la souris reste inchangé lors du déplacement entre les zones de texte valides et les zones de texte vides. Le code {@} pointeur l&apos;image et les propriétés du texte ne sont plus supportées.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Mouse events will no longer specify the timestamp, the object clicked, equivalent buffer positions (for marginal or fringe areas), glyph coordinates, or relative pixel coordinates.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les événements de souris ne seront plus spécifier l&apos;horodatage, l&apos;objet cliqué, postes équivalents tampons (pour les zones marginales ou sociaux), les coordonnées de glyphes, ou pixel par rapport coordonnées.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Simplifications have also been made to the way Emacs handles keymaps and key sequences:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Simplifications ont également été apportées à la façon Emacs gère claviers et séquences de touches:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{kbd} macro is now obsolete and is no longer documented.  It isn&apos;t that difficult to write key sequences using the string and vector representations, and we want to encourage users to learn.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La macro @ code {} kbd est maintenant obsolète et n&apos;est plus documenté. Il n&apos;est pas si difficile d&apos;écrire des séquences de touches à l&apos;aide de la chaîne et des représentations vectorielles, et nous voulons encourager les utilisateurs à apprendre.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs no longer supports key remapping.  You can do pretty much the same thing with @code{substitute-key-definition}, or by advising the relevant command.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs ne supporte plus reconfiguration clé. Vous pouvez faire à peu près la même chose avec @ code {substitut touche définition}, ou en conseillant la commande correspondante.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{keymap} text and overlay property is now overridden by minor mode keymaps, and will not work at the ends of text properties and overlays.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code {@} keymap texte et des biens superposition est maintenant remplacés par des claviers en mode mineur, et ne fonctionnera pas sur les extrémités des propriétés du texte et les superpositions.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The functions @code{map-keymap}, @code{keymap-prompt}, and @code{current-active-maps} have been removed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions @ code {carte-keymap}, @ code {keymap-rapide} et @ code {-active-cartes current} ont été supprimés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Process support has been pared down to a functional minimum.  The functions @code{call-process-shell-command} and @code{process-file} have been deleted.  Processes no longer maintain property lists, and they won&apos;t ask any questions when the user tries to exit Emacs (which would simply be rude.)  The function @code{signal-process} won&apos;t accept a process object, only the process id; determining the process id from a process object is left as an exercise to the programmer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Soutien de processus a été comparé à un minimum fonctionnel. Les fonctions @ code {appellent-processus-commande shell} et @ code {processus} fichier ont été supprimés. Processus maintenir plus des listes de propriétés, et ils ne seront pas de poser des questions lorsque l&apos;utilisateur tente de quitter Emacs (qui serait tout simplement grossier.) La fonction @ code {signal} processus n&apos;acceptera pas un objet de processus, que le processus id; déterminer l&apos;ID de processus à partir d&apos;un objet de processus est laissé comme exercice pour le programmeur.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Networking has also been simplified: @code{make-network-process} and its various associated function have all been replaced with a single easy-to-use function, @code{open-network-stream}, which can&apos;t use UDP, can&apos;t act as a server, and can&apos;t set up non-blocking connections.  Also, deleting a network process with @code{delete-process} won&apos;t call the sentinel.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Réseau a également été simplifiée: @ code {make-réseau-processus} et sa fonction associée divers ont toutes été remplacées par une seule fonction facile à utiliser, @ code {open-réseau courant}, qui ne peuvent pas utiliser le protocole UDP , ne peut pas agir en tant que serveur, et ne peut pas établir des connexions non bloquantes. En outre, la suppression d&apos;un processus de réseau avec @ code {delete-processus} ne sera pas appeler la sentinelle.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Many programming shortcuts have been deleted, to provide you with the enjoyment of ``rolling your own.&apos;&apos; The macros @code{while-no-input}, @code{with-local-quit}, and @code{with-selected-window}, along with @code{dynamic-completion-table} and @code{lazy-completion-table} no longer exist.  Also, there are no built-in progress reporters; with Emacs, you can take progress for granted.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Beaucoup de raccourcis de programmation ont été supprimés, pour vous offrir le plaisir de rouler votre propre ``.&apos;&apos; Le macros @ code {while-no-entrée}, {@ code de local-quit} et @ code {avec- -fenêtre sélectionnée}, avec @ code {dynamique d&apos;achèvement table} et @ code {lazy-fin-table} n&apos;existent plus. En outre, il n&apos;y a pas construit en journalistes d&apos;avancement; avec Emacs, vous pouvez prendre progrès pour acquis.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Variable aliases are no longer supported.  Aliases are for functions, not for variables.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Alias ​​variables ne sont plus pris en charge. Les alias sont des fonctions, pas pour les variables.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variables @code{most-positive-fixnum} and @code{most-negative-fixnum} do not exist.  On 32 bit machines, the most positive integer is probably 134217727, and the most negative integer is probably -134217728.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les variables @ code {plus positive Fixnum} et @ code {plus négative Fixnum} n&apos;existent pas. Sur les machines 32 bits, le nombre entier le plus positif est probablement 134217727, et l&apos;entier le plus négatif est probablement -134 217 728.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The functions @code{eql} and @code{macroexpand-all} are no longer available.  However, you can find similar functions in the @code{cl} package.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions @ code {eql} et @ code {macroexpand-tout} ne sont plus disponibles. Cependant, vous pouvez trouver des fonctions similaires dans le @ code {cl} paquet.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The list returned by @code{split-string} won&apos;t include null substrings for separators at the beginning or end of a string.  If you want to check for such separators, do it separately.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La liste renvoyée par @ code {split-string} ne comprendra chaînes nulles pour les séparateurs au début ou à la fin d&apos;une chaîne. Si vous voulez vérifier ces séparateurs, faire séparément.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{assoc-string} has been removed.  Use @code{assoc-ignore-case} or @code{assoc-ignore-representation} (which are no longer obsolete.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {assoc-string} a été supprimé. Utiliser le code @ {assoc-ignore-case} ou @ code {assoc-ignore-représentation} (qui ne sont plus obsolètes.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The escape sequence @samp{\\s} is always interpreted as a super modifier, never a space.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La séquence d&apos;échappement @ samp {\ \ s} est toujours interprété comme un modificateur superbe, jamais un espace.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variable @code{buffer-save-without-query} has been removed, to prevent Emacs from sneakily saving buffers.  Also, the hook @code{before-save-hook} has been removed, so if you want something to be done before saving, advise or redefine @code{basic-save-buffer}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La variable @ code {tampon-save-sans-query} a été supprimé, pour éviter Emacs de sauver sournoisement tampons. En outre, le crochet @ code {avant-sauver-crochet} a été supprimé, donc si vous voulez quelque chose à faire avant d&apos;enregistrer, de conseiller ou de redéfinir @ code {base-save-buffer}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variable @code{buffer-auto-save-file-format} has been renamed to @code{auto-save-file-format}, and is no longer a permanent local.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La variable @ code {tampon auto-save-file-format} a été renommé en @ code {auto-save-file-format}, et n&apos;est plus un local permanent.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{visited-file-modtime} now returns a cons, instead of a list of two integers.  The primitive @code{set-file-times} has been eliminated.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {visité fichier-modtime} retourne maintenant un contre, au lieu d&apos;une liste de deux entiers. La primitive @ code {set-file-temps} a été éliminé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{file-remote-p} is no longer available.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {fichier-distant-p} n&apos;est plus disponible.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When determining the filename extension, a leading dot in a filename is no longer ignored.  Thus, @file{.emacs} is considered to have extension @file{emacs}, rather than being extensionless.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lors de la détermination de l&apos;extension de nom de fichier, un point de premier plan dans un nom de fichier n&apos;est plus ignorée. Ainsi, @ file {.} Emacs est considérée comme l&apos;extension @ file {emacs}, plutôt que d&apos;être sans extension.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs looks for special file handlers in a more efficient manner: it will choose the first matching handler in @code{file-name-handler-alist}, rather than trying to figure out which provides the closest match.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs cherche des gestionnaires de fichiers spéciaux d&apos;une manière plus efficace: il choisira le premier gestionnaire correspondant à @ code {nom-fichier-gestionnaire-alist}, plutôt que d&apos;essayer de comprendre ce qui fournit la correspondance la plus proche.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{predicate} argument for @code{read-file-name} has been removed, and so have the variables @code{read-file-name-function} and @code{read-file-name-completion-ignore-case}.  The function @code{read-directory-name} has also been removed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code {@} prédicat argument @ code {lire nom de fichier} a été supprimé, et ont donc les variables @ code {lu nom de fichier fonction} et @ code {lecture du nom de fichier d&apos;achèvement ignorer cas}. La fonction @ code {lecture répertoire-name} a également été supprimée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The functions @code{all-completions} and @code{try-completion} will no longer accept lists of strings or hash tables (it will still accept alists, obarrays, and functions.)  In addition, the function @code{test-completion} is no longer available.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions @ code {tous-les achèvements} et @ code {try-fin} n&apos;accepteront plus des listes de chaînes ou tables de hachage (il sera toujours accepter alistes, obarrays et des fonctions.) En outre, le code fonction @ {test achèvement} n&apos;est plus disponible.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @samp{G} interactive code character is no longer supported.  Use @samp{F} instead.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ samp {G} caractère interactive du code n&apos;est plus supporté. Utilisez @ samp {F} à la place.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Arbitrary Lisp functions can no longer be recorded into @code{buffer-undo-list}.  As a consequence, @code{yank-undo-function} is obsolete, and has been removed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Fonctions Lisp arbitraires ne peuvent plus être enregistrées dans @ code {tampon-undo-liste}. En conséquence, @ code {yank-undo-fonction} est obsolète, et a été éliminée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs will never complain about commands that accumulate too much undo information, so you no longer have to worry about binding @code{buffer-undo-list} to @code{t} for such commands (though you may want to do that anyway, to avoid taking up unnecessary memory space.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs ne se plaindra jamais sur les commandes qui s&apos;accumulent trop défaire d&apos;informations, de sorte que vous n&apos;avez plus à vous soucier de liaison @ code {tampon-undo-liste} à @ code {t} pour ces commandes (si vous pouvez le faire de toute façon, d&apos;éviter de prendre de l&apos;espace mémoire nécessaire).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Atomic change groups are no longer supported.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Modifier les groupes atomiques ne sont plus pris en charge.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The list returned by @code{(match-data t)} no longer records the buffer as a final element.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La liste renvoyée par @ code {(match-données t)} n&apos;enregistre plus le tampon comme un élément final.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{looking-back} has been removed, so we no longer have the benefit of hindsight.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {la recherche-back} a été supprimé, si nous n&apos;avons plus l&apos;avantage du recul.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variable @code{search-spaces-regexp} does not exist.  Spaces always stand for themselves in regular expression searches.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La variable @ code {recherche-espaces-regexp} n&apos;existe pas. Espaces toujours debout pour eux-mêmes dans les recherches d&apos;expressions régulières.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The functions @code{skip-chars-forward} and @code{skip-chars-backward} no longer accepts character classes such as @samp{[:alpha:]}.  All characters are created equal.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions @ code {aller-chars-avant} et @ code {skip-chars-arrière} n&apos;accepte plus les classes de caractères comme @ samp {[: alpha:]}. Tous les personnages sont créés égaux.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{yank-handler} text property no longer has any meaning.  Also, @code{yank-excluded-properties}, @code{insert-for-yank}, and @code{insert-buffer-substring-as-yank} have all been removed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La propriété @ code {yank-gestionnaire} texte n&apos;a plus aucun sens. En outre, @ code {yank-exclu-propriétés}, @ code {insérer-pour-coup sec} et @ code {insert-buffer-chaîne-comme-yank} ont tous été retirés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variable @code{char-property-alias-alist} has been deleted.  Aliases are for functions, not for properties.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La variable @ code {char-propriété-alias-alist} a été supprimé. Les alias sont des fonctions, pas de propriétés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{get-char-property-and-overlay} has been deleted.  If you want the properties at a point, find the text properties at the point; then, find the overlays at the point, and find the properties on those overlays.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code de la fonction @ {get-char-propriété-et-overlay} a été supprimé. Si vous voulez les propriétés à un point, trouver les propriétés de texte au point, puis trouver les superpositions au point, et de trouver les propriétés de ces superpositions.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Font Lock mode only manages @code{face} properties; you can&apos;t use font-lock keywords to specify arbitrary text properties for it to manage.  After all, it is called Font Lock mode, not Arbitrary Properties Lock mode.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Mode Verrouillage de Police ne gère @ code {} visage propriétés; vous ne pouvez pas utiliser des mots clés font-lock pour spécifier les propriétés de texte arbitraire pour qu&apos;il gère. Après tout, il est appelé mode verrouillage de la police, pas en mode arbitraire Propriétés Lock.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The arguments to @code{remove-overlays} are no longer optional.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les arguments de @ code {remove-superpositions} ne sont plus en option.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In @code{replace-match}, the replacement text now inherits properties from the surrounding text.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Dans @ code {remplacer match}, le texte de remplacement hérite désormais des propriétés du texte environnant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variable @code{mode-line-format} no longer supports the @code{:propertize}, @code{<ph x="1">&lt;x0/&gt;</ph>}, and @code{%I} constructs.  The function @code{format-mode-line} has been removed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La variable @ code {mode en ligne au format} ne supporte plus le code de @ {:} propertize, @ code { <ph x="1">&lt;x0/&gt;</ph> } et @ code {I}% constructions. La fonction @ code {format mode en ligne} a été supprimé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The functions @code{window-inside-edges} and @code{window-body-height} have been removed.  You should do the relevant calculations yourself, starting with @code{window-width} and @code{window-height}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions @ code {fenêtre à l&apos;intérieur de bords} et @ code {fenêtre-corps hauteur} ont été supprimés. Vous devez faire les calculs vous-même, en commençant par @ code {fenêtre largeur} et @ code {fenêtre hauteur}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The functions @code{window-pixel-edges} and @code{window-inside-pixel-edges} have been removed.  We prefer to think in terms of lines and columns, not pixel coordinates.  (Sometime in the distant past, we will do away with graphical terminals entirely, in favor of text terminals.)  For similar reasons, the functions @code{posn-at-point}, @code{posn-at-x-y}, and @code{window-line-height} have been removed, and @code{pos-visible-in-window-p} no longer worries about partially visible rows.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions @ code {fenêtre pixels bords} et @ code {fenêtre à l&apos;intérieur de pixels bords} ont été supprimés. Nous préférons penser en termes de lignes et de colonnes, pas pixel coordonnées. (Parfois, dans le passé lointain, nous allons en finir avec les terminaux graphiques entièrement, en faveur de terminaux texte.) Pour des raisons similaires, les fonctions @ code {POSTE-à-Point}, @ code {POSTE-à-xy}, et @ code {fenêtre-line-height} ont été enlevés, et @ code ne s&apos;inquiète {pos-visible-en-window-p} sur les lignes partiellement visibles.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The macro @code{save-selected-window} only saves the selected window of the selected frame, so don&apos;t try selecting windows in other frames.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La macro @ code {-fenêtre de sauvegarde sélectionnée} enregistre uniquement la fenêtre sélectionnée de l&apos;image sélectionnée, alors n&apos;essayez pas de la sélection des fenêtres dans d&apos;autres cadres.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{minibufferp} is no longer available.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {} minibufferp n&apos;est plus disponible.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{modify-all-frames-parameters} has been removed (we always suspected the name was ungrammatical, anyway.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code de la fonction @ {modifier-les-cadres-paramètres} a été supprimé (nous avons toujours soupçonné le nom était grammatical, de toute façon.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{line-spacing} variable no longer accepts float values.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ code {interligne} variables n&apos;accepte plus flotter valeurs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{tool-bar-local-item-from-menu} has been deleted.  If you need to make an entry in the tool bar, you can still use @code{tool-bar-add-item-from-menu}, but that modifies the binding in the source keymap instead of copying it into the local keymap.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {outil-bar-locale-point-de-menu} a été supprimé. Si vous avez besoin de faire une entrée dans la barre d&apos;outils, vous pouvez toujours utiliser @ code {outil-bar-add-point-de-menu}, mais qui modifie la liaison dans le plan de codage de la source au lieu de le copier dans le plan de codage local.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When determining the major mode, the file name takes precedence over the interpreter magic line.  The variable @code{magic-mode-alist}, which associates certain buffer beginnings with major modes, has been eliminated.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour déterminer le mode majeur, le nom de fichier a la priorité sur la ligne magique d&apos;un interprète. La variable @ code {magie mode-alist}, qui associe certains débuts de tampons avec des modes principaux, a été éliminé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The hook @code{after-change-major-mode-hook} is not defined, and neither are @code{run-mode-hooks} and @code{delay-mode-hooks}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le crochet @ code {après-changement-major-mode-hook} n&apos;est pas défini, et ne sont @ code {mode-crochets run-} et @ code {retard mode crochets}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variable @code{minor-mode-list} has been removed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La variable @ code {mode mineur liste} a été supprimé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{define-derived-mode} will copy abbrevs from the parent mode&apos;s abbrev table, instead of creating a new, empty abbrev table.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {-définir le mode dérivé} copie abbrevs de la table de abbrev de la mode parent, au lieu de créer une nouvelle table vide de abbrev.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! There are no ``system&apos;&apos; abbrevs.  When the user saves into the abbrevs file, all abbrevs are saved.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il n&apos;y a pas de `` système&apos;&apos; abbrevs. Lorsque l&apos;utilisateur enregistre dans le fichier abbrevs, tous abbrevs sont enregistrés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The Warnings facility has been removed.  Just use @code{error}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;installation des avertissements a été supprimé. Il suffit d&apos;utiliser @ code {erreur}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Several hook variables have been renamed to flout the Emacs naming conventions.  We feel that consistency is boring, and having non-standard hook names encourages users to check the documentation before using a hook.  For instance, the normal hook @code{find-file-hook} has been renamed to @code{find-file-hooks}, and the abnormal hook @code{delete-frame-functions} has been renamed to @code{delete-frame-hook}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Plusieurs variables de branchements ont été renommés à bafouer les conventions de nommage Emacs. Nous pensons que la cohérence est ennuyeux, et ayant des noms de branchements non standard encourage les utilisateurs à consulter la documentation avant d&apos;utiliser un crochet. Par exemple, le crochet @ code normal {find-file-crochet} a été renommé en @ code {find-file-hooks}, et le code crochet @ anormale {frame-fonctions delete-} a été renommé en @ code {delete -frame-crochet}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{symbol-file} does not exist.  If you want to know which file defined a function or variable, try grepping for it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {symbole fichier} n&apos;existe pas. Si vous voulez savoir quel fichier défini une fonction ou variable, faites une recherche pour elle.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variable @code{load-history} records function definitions just like variable definitions, instead of indicating which functions were previously autoloaded.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La variable @ code de définitions de fonctions {charge}-histoire dossiers, tout comme les définitions de variables, au lieu d&apos;indiquer quelles fonctions étaient auparavant chargés automatiquement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! There is a new variable, @code{recursive-load-depth-limit}, which specifies how many times files can recursively load themselves; it is 50 by default, and @code{nil} means infinity.  Previously, Emacs signaled an error after just 3 recursive loads, which was boring.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il est une nouvelle variable, @ code {récursive charge approfondie limite}, qui spécifie combien de fois les fichiers peuvent se charger de manière récursive, il est de 50 par défaut, et @ code {nil} signifie l&apos;infini. Auparavant, Emacs signalé une erreur après seulement 3 charges récurrentes, ce qui était ennuyeux.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Byte-compiler warnings and error messages will leave out the line and character positions, in order to exercise your debugging skills.  Also, there is no @code{with-no-warnings} macro---instead of suppressing compiler warnings, fix your code to avoid them!</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Avertissements Byte-compilateur et les messages d&apos;erreur vont quitter la ligne et les positions de caractères, afin d&apos;exercer vos compétences de débogage. En outre, il n&apos;y a pas @ code {avec-no-avertissements} macro --- au lieu de supprimer les avertissements du compilateur, corriger votre code à éviter!</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{unsafep} has been removed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code de la fonction @ {} unsafep a été supprimé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! File local variables can now specify a string with text properties.  Since arbitrary Lisp expressions can be embedded in text properties, this can provide you with a great deal of flexibility and power.  On the other hand, @code{safe-local-eval-forms} and the @code{safe-local-eval-function} function property have no special meaning.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Déposer les variables locales peuvent désormais spécifier une chaîne avec des propriétés de texte. Depuis des expressions Lisp arbitraires peuvent être intégrés dans les propriétés du texte, ce qui peut vous fournir avec beaucoup de souplesse et de puissance. D&apos;autre part, @ code {sûr-local-eval-formes} et @ code {-eval-fonction de sécurité locale} propriété de fonction n&apos;ont aucune signification particulière.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You can no longer use @code{char-displayable-p} to test if Emacs can display a certain character.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous ne pouvez plus utiliser @ code {char-affichable-p} pour tester si Emacs peut afficher un certain caractère.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{string-to-multibyte} is no longer available.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {chaîne à plusieurs octets} n&apos;est plus disponible.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{translation-table-for-input} translation table has been removed.  Also, translation hash tables are no longer available, so we don&apos;t need the functions @code{lookup-character} and @code{lookup-integer}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code de @ {traduction-table-pour-entrée} table de traduction a été supprimé. En outre, des tables de traduction de hachage ne sont plus disponibles, nous n&apos;avons pas besoin des fonctions @ code {lookup caractères} et @ code {recherche} entier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{table} argument to @code{translate-region} can no longer be a char-table; it has to be a string.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ code {table} argument de @ code {} translate-région ne peut plus être un caractère table, elle doit être une chaîne.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variable @code{auto-coding-functions} and the two functions @code{merge-coding-systems} and @code{decode-coding-inserted-region} have been deleted.  The coding system property @code{mime-text-unsuitable} no longer has any special meaning.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La variable @ code {auto-codage-fonctions} et les deux fonctions @ code {fusionner codantes systèmes} et @ code {décodage-codage inséré région} ont été supprimées. Le code de la propriété du système de codage de @ {mime-texte inadapté} n&apos;a plus aucune signification particulière.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If pure storage overflows while dumping, Emacs won&apos;t tell you how much additional pure storage it needs.  Try adding in increments of 20000, until you have enough.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le stockage pur déborde tout dumping, Emacs ne sera pas vous dire combien de stockage pur supplémentaire dont il a besoin. Essayez d&apos;ajouter par incréments de 20 000, jusqu&apos;à ce que vous avez assez.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variables @code{gc-elapsed}, @code{gcs-done}, and @code{post-gc-hook} have been garbage-collected.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les variables @ code {gc-écoulé}, @ code {GCS-fait} et @ code {post-gc-crochet} ont été ramasse-miettes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT!    arch-tag: 1d0ef137-2bad-430e-ae8e-d820d569b5a6<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>arc-tag: 1d0ef137-2Bad-430e-ae8e-d820d569b5a6 <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! GNU Emacs Lisp Reference Manual</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Manuel GNU Emacs Lisp Reference</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! GNU Emacs Lisp</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>GNU Emacs Lisp</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This manual describes Emacs Lisp.  Generally speaking, the earlier chapters describe features of Emacs Lisp that have counterparts in many programming languages, and later chapters describe features that are peculiar to Emacs Lisp or relate specifically to editing.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce manuel décrit Emacs Lisp. D&apos;une manière générale, les chapitres précédents décrivent les fonctionnalités d&apos;Emacs Lisp qui ont leurs équivalents dans de nombreux langages de programmation, et les chapitres suivants décrivent les caractéristiques qui sont propres à Emacs Lisp ou se rapportent spécifiquement à l&apos;édition.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @hfil</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Hfil</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Backups and Auto-Saving</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Sauvegardes et Auto-économie</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tampons</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Files</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Fichiers</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! backups and auto-saving</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>les sauvegardes et l&apos;enregistrement automatique</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Backup files and auto-save files are two methods by which Emacs tries to protect the user from the consequences of crashes or of the user&apos;s own errors.  Auto-saving preserves the text from earlier in the current editing session; backup files preserve file contents prior to the current session.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fichiers de sauvegarde et les fichiers de sauvegarde automatique sont deux méthodes par lesquelles Emacs tente de protéger l&apos;utilisateur contre les conséquences des accidents ou des propres erreurs de l&apos;utilisateur. L&apos;auto-sauvegarde conserve le texte de début de la session d&apos;édition en cours, les fichiers de sauvegarde de préserver le contenu du fichier avant la session en cours.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Backup Files</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Fichiers de sauvegarde</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How backup files are made; how their names are chosen.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment les fichiers de sauvegarde sont faites, comment leurs noms sont choisis.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Auto-Saving</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Auto-économie</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How auto-save files are made; how their names are chosen.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment auto-enregistrer des fichiers sont faits, comment leurs noms sont choisis.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Reverting</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Revenant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{revert-buffer}, and how to customize what it does.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {revert-buffer}, et comment personnaliser ce qu&apos;elle fait.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! backup file</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fichier de sauvegarde</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A @dfn{backup file} is a copy of the old contents of a file you are editing.  Emacs makes a backup file the first time you save a buffer into its visited file.  Thus, normally, the backup file contains the contents of the file as it was before the current editing session.  The contents of the backup file normally remain unchanged once it exists.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>A @ dfn {} du fichier de sauvegarde est une copie de l&apos;ancien contenu d&apos;un fichier que vous éditez. Emacs crée un fichier de sauvegarde la première fois que vous enregistrez un tampon dans le fichier qu&apos;il visite. Ainsi, normalement, le fichier de sauvegarde contient le contenu du fichier tel qu&apos;il était avant la session d&apos;édition en cours. Le contenu du fichier de sauvegarde restent normalement inchangées une fois qu&apos;il existe.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Backups are usually made by renaming the visited file to a new name.  Optionally, you can specify that backup files should be made by copying the visited file.  This choice makes a difference for files with multiple names; it also can affect whether the edited file remains owned by the original owner or becomes owned by the user editing it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les sauvegardes sont habituellement faites en renommant le fichier visité un nouveau nom. En option, vous pouvez spécifier que les fichiers de sauvegarde doivent être prises en copiant le fichier visité. Ce choix fait la différence pour les fichiers avec des noms multiples, il peut aussi influer sur le fichier modifié reste détenue par le propriétaire d&apos;origine ou devient détenue par l&apos;utilisateur de le modifier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! By default, Emacs makes a single backup file for each file edited.  You can alternatively request numbered backups; then each new backup file gets a new name.  You can delete old numbered backups when you don&apos;t want them any more, or Emacs can delete them automatically.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Par défaut, Emacs fait un seul fichier de sauvegarde pour chaque fichier modifié. Vous pouvez aussi demander des sauvegardes numérotées, puis chaque nouveau fichier de sauvegarde obtient un nouveau nom. Vous pouvez supprimer les anciennes sauvegardes numérotées lorsque vous ne voulez pas ou plus du tout Emacs pouvez les supprimer automatiquement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Making Backups</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Faire des sauvegardes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How Emacs makes backup files, and when.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment Emacs crée des fichiers de sauvegarde, et quand.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Rename or Copy</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Renommer ou Copier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Two alternatives: renaming the old file or copying it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Deux alternatives: renommer l&apos;ancien fichier ou le copier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Numbered Backups</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les sauvegardes numérotées</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Keeping multiple backups for each source file.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Garder des sauvegardes multiples pour chaque fichier source.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Backup Names</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Noms de sauvegarde</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How backup file names are computed; customization.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment les noms de fichiers de sauvegarde sont calculés; personnalisés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Making Backup Files</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Rendre des fichiers de sauvegarde</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! backup-buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>sauvegarde-tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function makes a backup of the file visited by the current buffer, if appropriate.  It is called by @code{save-buffer} before saving the buffer the first time.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction permet une sauvegarde du fichier visité par le tampon courant, le cas échéant. Elle est appelée par @ code {save-buffer} avant d&apos;enregistrer le tampon la première fois.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If a backup was made by renaming, the return value is a cons cell of the form (@var{modes} . @var{backupname}), where @var{modes} are the mode bits of the original file, as returned by @code{file-modes} (@pxref{File Attributes,, Other Information about Files}), and @var{backupname} is the name of the backup.  In all other cases, that is, if a backup was made by copying or if no backup was made, this function returns @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si une sauvegarde a été faite par le changement de nom, la valeur de retour est une cellule de contre de la forme (@ var {modes}. @ Var {backupname}), où @ var {modes} sont les bits de mode du fichier d&apos;origine, tel que retourné par @ code {modes de fichiers} (@ {pxref des attributs de fichier, d&apos;autres informations sur les fichiers}), et @ var {backupname} est le nom de la sauvegarde. Dans tous les autres cas, c&apos;est à dire si une sauvegarde a été effectuée en copiant ou en l&apos;absence de sauvegarde a été effectuée, cette fonction retourne @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-backed-up</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon-sauvegardé</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This buffer-local variable says whether this buffer&apos;s file has been backed up on account of this buffer.  If it is non-@code{nil}, the backup file has been written.  Otherwise, the file should be backed up when it is next saved (if backups are enabled).  This is a permanent local; @code{kill-all-local-variables} does not alter@tie{}it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable locale de tampon dit que le dossier de ce tampon a été sauvegardé en raison de ce tampon. Si c&apos;est non @ code {nil}, le fichier de sauvegarde a été écrite. Sinon, le fichier doit être sauvegardé lors de sa prochaine sauvé (si les sauvegardes sont activés). Il s&apos;agit d&apos;un local permanent; @ code {all-local-variables tuer-} ne modifie pas @ tie {} il.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable determines whether or not to make backup files.  If it is non-@code{nil}, then Emacs creates a backup of each file when it is saved for the first time---provided that @code{backup-inhibited} is @code{nil} (see below).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable détermine si oui ou non de faire des fichiers de sauvegarde. Si c&apos;est non @ code {nil}, puis Emacs crée une sauvegarde de chaque fichier lorsqu&apos;il est enregistré pour la première fois --- à condition que @ code {sauvegarde inhibée} est @ code {nil} (voir ci-dessous).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The following example shows how to change the @code{make-backup-files} variable only in the Rmail buffers and not elsewhere.  Setting it @code{nil} stops Emacs from making backups of these files, which may save disk space.  (You would put this code in your init file.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;exemple suivant montre comment modifier le code de @ {faire-sauvegarde des fichiers} variable que dans les tampons Rmail et pas ailleurs. Un réglage @ code {nil} s&apos;arrête Emacs de faire des sauvegardes de ces fichiers, qui peut économiser de l&apos;espace disque. (Vous mettriez ce code dans votre fichier init.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (add-hook &apos;rmail-mode-hook<ph x="1">&lt;x0/&gt;</ph>          (function (lambda ()<ph x="2">&lt;x1/&gt;</ph>                      (make-local-variable<ph x="3">&lt;x2/&gt;</ph>                       &apos;make-backup-files)<ph x="4">&lt;x3/&gt;</ph>                      (setq make-backup-files nil))))<ph x="5">&lt;x4/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Add-hook &apos;rmail-mode-hook <ph x="1">&lt;x0/&gt;</ph> (Function (lambda () <ph x="2">&lt;x1/&gt;</ph> (Faire-variable locale <ph x="3">&lt;x2/&gt;</ph> &apos;Make-backup-files) <ph x="4">&lt;x3/&gt;</ph> (Setq make-backup-fichiers nil)))) <ph x="5">&lt;x4/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable&apos;s value is a function to be called on certain occasions to decide whether a file should have backup files.  The function receives one argument, an absolute file name to consider.  If the function returns @code{nil}, backups are disabled for that file.  Otherwise, the other variables in this section say whether and how to make backups.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable est une fonction qui sera appelée à certaines occasions de décider si un fichier doit avoir les fichiers de sauvegarde. La fonction reçoit un argument, un nom de fichier absolu à considérer. Si la fonction renvoie @ code {nil}, les sauvegardes sont désactivés pour ce fichier. Sinon, les autres variables de cette section dire si et comment faire des sauvegardes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The default value is @code{normal-backup-enable-predicate}, which checks for files in @code{temporary-file-directory} and @code{small-temporary-file-directory}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur par défaut est @ code {normale-backup-enable-prédicat}, qui vérifie les fichiers dans @ code {temporaire-fichier-répertoire} et @ code {petit-temporaire-fichier-répertoire}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is non-@code{nil}, backups are inhibited.  It records the result of testing @code{backup-enable-predicate} on the visited file name.  It can also coherently be used by other mechanisms that inhibit backups based on which file is visited.  For example, VC sets this variable non-@code{nil} to prevent making backups for files managed with a version control system.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est non @ code {nil}, les sauvegardes sont inhibées. Il enregistre le résultat des tests @ code {sauvegarde-enable-prédicat} sur le nom du fichier visité. Il peut également être utilisé de manière cohérente par d&apos;autres mécanismes qui empêchent les sauvegardes basées sur le fichier qui est visité. Par exemple, VC définit cette variable non @ code {nil} pour empêcher la réalisation de sauvegardes pour les fichiers gérés par un système de contrôle de version.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is a permanent local, so that changing the major mode does not lose its value.  Major modes should not set this variable---they should set @code{make-backup-files} instead.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il s&apos;agit d&apos;un local permanent, de sorte que le changement du mode majeur ne perd pas sa valeur. Les modes majeurs ne devraient pas définir cette variable --- ils devraient mettre @ code {make-sauvegarde des fichiers} à la place.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable&apos;s value is an alist of filename patterns and backup directory names.  Each element looks like</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable est un aliste des modèles de noms de fichiers et de répertoires de sauvegarde. Chaque élément ressemble</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (@var{regexp} . @var{directory})<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(@ Var {expression rationnelle}. @ {Var répertoire}) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Backups of files with names matching @var{regexp} will be made in @var{directory}.  @var{directory} may be relative or absolute.  If it is absolute, so that all matching files are backed up into the same directory, the file names in this directory will be the full name of the file backed up with all directory separators changed to @samp{!} to prevent clashes.  This will not work correctly if your filesystem truncates the resulting name.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les sauvegardes de fichiers dont les noms correspondent @ var {expression rationnelle} seront effectués dans @ {var} répertoire. @ Var {répertoire} peut être relative ou absolue. Si elle est absolue, de sorte que tous les fichiers correspondants sont sauvegardés dans le même répertoire, les noms de fichiers de ce répertoire seront le nom complet du fichier sauvegardé avec tous les séparateurs de répertoires changé à @ samp {!} Pour éviter les affrontements. Cela ne fonctionnera pas correctement si votre système de fichiers tronque le nom résultant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For the common case of all backups going into one directory, the alist should contain a single element pairing @samp{\&quot;.\&quot;} with the appropriate directory name.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour le cas commun de toutes les sauvegardes dans un répertoire allant, la aliste doit contenir un seul élément appariement @ samp {\ &quot;. \&quot;} Avec le nom de répertoire approprié.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is @code{nil}, or it fails to match a filename, the backup is made in the original file&apos;s directory.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est @ code {nil}, ou il ne correspond pas à un nom de fichier, la sauvegarde est effectuée dans le répertoire du fichier d&apos;origine.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! On MS-DOS filesystems without long names this variable is always ignored.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Sur les systèmes de fichiers MS-DOS sans noms longs cette variable est toujours ignoré.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable&apos;s value is a function to use for making backups instead of the default @code{make-backup-file-name}.  A value of @code{nil} gives the default @code{make-backup-file-name} behavior.  @xref{Backup Names,, Naming Backup Files}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable est une fonction à utiliser pour faire des sauvegardes au lieu du @ code par défaut {make-backup-file-name}. Une valeur de @ code {nil} donne le code par défaut @ {make-backup-file-name} comportement. @ Xref {Noms de sauvegarde, de nommage des fichiers de sauvegarde}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This could be buffer-local to do something special for specific files.  If you define it, you may need to change @code{backup-file-name-p} and @code{file-name-sans-versions} too.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cela pourrait être un tampon local pour faire quelque chose de spécial pour les fichiers spécifiques. Si vous définissez, vous devrez peut-être changer @ code {sauvegarde nom de fichier-p} et @ code {nom-fichier-sans-versions} trop.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Backup by Renaming or by Copying?</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Sauvegarde en renommant ou en copiant?</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! backup files, rename or copy</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fichiers de sauvegarde, renommer ou copier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! There are two ways that Emacs can make a backup file:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il ya deux façons que Emacs peut faire un fichier de sauvegarde:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs can rename the original file so that it becomes a backup file, and then write the buffer being saved into a new file.  After this procedure, any other names (i.e., hard links) of the original file now refer to the backup file.  The new file is owned by the user doing the editing, and its group is the default for new files written by the user in that directory.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs peut renommer le fichier d&apos;origine de sorte qu&apos;il devient un fichier de sauvegarde, puis écrire le tampon étant enregistrées dans un nouveau fichier. Après cette procédure, d&apos;autres noms (par exemple, des liens en dur) du fichier d&apos;origine se réfèrent maintenant au fichier de sauvegarde. Le nouveau fichier est possédée par l&apos;utilisateur de faire le montage, et son groupe est la valeur par défaut pour les nouveaux fichiers écrits par l&apos;utilisateur dans ce répertoire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs can copy the original file into a backup file, and then overwrite the original file with new contents.  After this procedure, any other names (i.e., hard links) of the original file continue to refer to the current (updated) version of the file.  The file&apos;s owner and group will be unchanged.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs peut copier le fichier original dans un fichier de sauvegarde, puis remplacer le fichier original avec de nouveaux contenus. Après cette procédure, d&apos;autres noms (par exemple, des liens en dur) du fichier d&apos;origine continuent à se référer à la version actuelle (mise à jour) du fichier. Le propriétaire et le groupe du fichier ne changera pas.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The first method, renaming, is the default.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La première méthode, le changement de nom, est la valeur par défaut.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The variable @code{backup-by-copying}, if non-@code{nil}, says to use the second method, which is to copy the original file and overwrite it with the new buffer contents.  The variable @code{file-precious-flag}, if non-@code{nil}, also has this effect (as a sideline of its main significance).  @xref{Saving Buffers}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La variable @ code {sauvegarde par copie}, si non @ code {nil}, dit d&apos;utiliser la seconde méthode, qui consiste à copier le fichier d&apos;origine et le remplacer par le nouveau contenu de la mémoire tampon. La variable @ code {fichier précieux drapeau}, si non @ code {nil}, a également cet effet (en marge de sa signification principale). @ Xref {} Sauvegarde tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is non-@code{nil}, Emacs always makes backup files by copying.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est non @ code {nil}, Emacs fait toujours des fichiers de sauvegarde par copie.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The following three variables, when non-@code{nil}, cause the second method to be used in certain special cases.  They have no effect on the treatment of files that don&apos;t fall into the special cases.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les trois variables suivantes, en cas de non-@ code {nil}, provoquent la deuxième méthode pour être utilisé dans certains cas particuliers. Ils n&apos;ont aucun effet sur le traitement des dossiers qui ne relèvent pas des cas particuliers.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is non-@code{nil}, Emacs makes backups by copying for files with multiple names (hard links).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est non @ code {nil}, Emacs effectue des sauvegardes en copiant les fichiers avec plusieurs noms (liens en dur).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable is significant only if @code{backup-by-copying} is @code{nil}, since copying is always used when that variable is non-@code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable n&apos;est significative que si @ code {sauvegarde par copie} est @ code {nil}, puisque la copie est toujours utilisé lorsque cette variable est non @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is non-@code{nil}, Emacs makes backups by copying in cases where renaming would change either the owner or the group of the file.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est non @ code {nil}, Emacs effectue des sauvegardes en copiant dans les cas où le renommage changerait soit le propriétaire ou le groupe du fichier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value has no effect when renaming would not alter the owner or group of the file; that is, for files which are owned by the user and whose group matches the default for a new file created there by the user.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur n&apos;a pas d&apos;effet lors du renommage ne modifierait pas le propriétaire ou le groupe du fichier, c&apos;est, pour les fichiers qui sont détenues par l&apos;utilisateur et dont le groupe correspond à la valeur par défaut pour un nouveau fichier, il créé par l&apos;utilisateur.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable, if non-@code{nil}, specifies the same behavior as @code{backup-by-copying-when-mismatch}, but only for certain user-id values: namely, those less than or equal to a certain number.  You set this variable to that number.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable, si non @ code {nil}, précise le même comportement que @ code {sauvegarde par copie-quand-décalage}, mais seulement pour certaines valeurs utilisateur-id: à savoir, ceux de moins de ou égal à un certain nombre. Vous définissez cette variable de ce nombre.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Thus, if you set @code{backup-by-copying-when-privileged-mismatch} to 0, backup by copying is done for the superuser only, when necessary to prevent a change in the owner of the file.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ainsi, si vous définissez @ code {sauvegarde par copie-quand-privilégié inadéquation} à 0, la sauvegarde par copie est effectuée pour le superutilisateur, si nécessaire, pour empêcher un changement de propriétaire du fichier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The default is 200.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur par défaut est 200.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Making and Deleting Numbered Backup Files</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Faire et suppression des fichiers de sauvegarde numérotée</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If a file&apos;s name is @file{foo}, the names of its numbered backup versions are @file{foo.~@var{v}~}, for various integers @var{v}, like this: @file{foo.~1~}, @file{foo.~2~}, @file{foo.~3~}, @dots{}, @file{foo.~259~}, and so on.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le nom d&apos;un fichier est @ file {foo}, les noms de ses versions de sauvegarde numérotées sont @ file {foo ~ @ var {v} ~.}, Pour diverses entiers @ var {v}, comme ceci: @ file {foo. ~ 1 ~}, @ file {foo. ~ 2 ~}, @ file {foo. ~ 3 ~}, @ points {}, @ file {foo. ~ 259 ~}, et ainsi de suite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable controls whether to make a single non-numbered backup file or multiple numbered backups.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable contrôle si pour faire un fichier de sauvegarde non-numérotée unique ou plusieurs sauvegardes numérotées.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Make numbered backups if the visited file already has numbered backups; otherwise, do not.  This is the default.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Faire une sauvegarde numérotée si le fichier a déjà visité numérotée sauvegardes, sinon, non. C&apos;est la valeur par défaut.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! never</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>jamais</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Do not make numbered backups.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ne pas faire des sauvegardes numérotées.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! anything else</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>rien d&apos;autre</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Make numbered backups.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Faire une sauvegarde numérotée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The use of numbered backups ultimately leads to a large number of backup versions, which must then be deleted.  Emacs can do this automatically or it can ask the user whether to delete them.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;utilisation des sauvegardes numérotées conduit finalement à un grand nombre de versions de sauvegarde, qui doit ensuite être supprimé. Emacs peut le faire automatiquement ou il peut demander à l&apos;utilisateur s&apos;il faut les supprimer.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value of this variable is the number of newest versions to keep when a new numbered backup is made.  The newly made backup is included in the count.  The default value is@tie{}2.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable est le nombre de versions les plus récentes de garder quand une nouvelle sauvegarde numérotée est faite. La sauvegarde nouvellement fait est inclus dans le décompte. La valeur par défaut est @ tie {} 2.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value of this variable is the number of oldest versions to keep when a new numbered backup is made.  The default value is@tie{}2.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable est le nombre de versions les plus anciennes de garder quand une nouvelle sauvegarde numérotée est faite. La valeur par défaut est @ tie {} 2.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If there are backups numbered 1, 2, 3, 5, and 7, and both of these variables have the value 2, then the backups numbered 1 and 2 are kept as old versions and those numbered 5 and 7 are kept as new versions; backup version 3 is excess.  The function @code{find-backup-file-name} (@pxref{Backup Names}) is responsible for determining which backup versions to delete, but does not delete them itself.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si il ya des sauvegardes numérotées 1, 2, 3, 5, et 7, et ces deux variables ont la valeur 2, puis les sauvegardes numérotées 1 et 2 sont gardés comme les anciennes versions et celles numérotées 5 et 7 sont gardés comme de nouvelles versions; version de sauvegarde 3 est en excès. Le code de la fonction @ {trouver-backup-file-name} (@ pxref {Noms de sauvegarde}) est chargé de déterminer quelles versions de sauvegarde à supprimer, mais ne les supprime pas lui-même.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is @code{t}, then saving a file deletes excess backup versions silently.  If it is @code{nil}, that means to ask for confirmation before deleting excess backups.  Otherwise, they are not deleted at all.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est @ code {t}, puis enregistrement d&apos;un fichier supprime les versions excès de sauvegarde en silence. Si elle est @ code {nil}, ce qui signifie de demander confirmation avant de supprimer des sauvegardes excès. Sinon, ils ne sont pas supprimés du tout.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable specifies how many of the newest backup versions to keep in the Dired command @kbd{.} (@code{dired-clean-directory}).  That&apos;s the same thing @code{kept-new-versions} specifies when you make a new backup file.  The default is@tie{}2.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable indique le nombre des versions plus récentes de sauvegarde à conserver dans le Dired commande @ kbd {.} (@ Code {dired-propre répertoire}). C&apos;est la même chose @ code {-nouvelles versions gardés} spécifie quand vous faites un nouveau fichier de sauvegarde. La valeur par défaut est @ tie {} 2.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Naming Backup Files</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Nommer les fichiers de sauvegarde</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The functions in this section are documented mainly because you can customize the naming conventions for backup files by redefining them.  If you change one, you probably need to change the rest.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions de cette section sont documentés principalement parce que vous pouvez personnaliser les conventions de nommage pour les fichiers de sauvegarde par les redéfinir. Si vous modifiez un, vous avez probablement besoin de changer le reste.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! backup-file-name-p filename</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>sauvegarde-nom-fichier-p nom</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns a non-@code{nil} value if @var{filename} is a possible name for a backup file.  It just checks the name, not whether a file with the name @var{filename} exists.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne un non @ code {nil} valeur si @ var {nom de fichier} est un nom possible pour un fichier de sauvegarde. Il vérifie que le nom, pas de savoir si un fichier portant le nom @ var {nom de fichier} existe.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (backup-file-name-p \&quot;foo\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} nil<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Sauvegarde de nom de fichier-p \ &quot;foo \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ {} Résultat nul <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (backup-file-name-p \&quot;foo~\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} 3<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Sauvegarde de nom de fichier-p \ &quot;foo ~ \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} 3 <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The standard definition of this function is as follows:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La définition standard de cette fonction est la suivante:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun backup-file-name-p (file)<ph x="1">&lt;x0/&gt;</ph>  \&quot;Return non-nil if FILE is a backup file \\<ph x="2">&lt;x1/&gt;</ph>name (numeric or not)...\&quot;<ph x="3">&lt;x2/&gt;</ph>  (string-match \&quot;~\\\\&apos;\&quot; file))<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun sauvegarde nom de fichier-p (fichier) <ph x="1">&lt;x0/&gt;</ph> \ &quot;Retour non nulle si le fichier est un fichier de sauvegarde \ \ <ph x="2">&lt;x1/&gt;</ph> nom (numérique ou non) ... \ &quot; <ph x="3">&lt;x2/&gt;</ph> (String-match de \ &quot;~ \ \ \ \ &apos;\&quot; fichier)) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Thus, the function returns a non-@code{nil} value if the file name ends with a @samp{~}.  (We use a backslash to split the documentation string&apos;s first line into two lines in the text, but produce just one line in the string itself.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ainsi, la fonction retourne un code {nil} valeur non-@ si le nom de fichier se termine par un @ samp {~}. (Nous utilisons une barre oblique inverse pour diviser la première ligne de la chaîne de documentation en deux lignes dans le texte, mais de produire une seule ligne dans la chaîne elle-même.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This simple expression is placed in a separate function to make it easy to redefine for customization.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette expression simple est placé dans une fonction distincte pour le rendre facile à redéfinir pour la personnalisation.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! make-backup-file-name filename</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>faire-backup-file-name nom de fichier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns a string that is the name to use for a non-numbered backup file for file @var{filename}.  On Unix, this is just @var{filename} with a tilde appended.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne une chaîne qui est le nom à utiliser pour un fichier de sauvegarde non-numérotée pour le fichier @ var {nom de fichier}. Sous Unix, c&apos;est juste @ var {nom de fichier} avec un tilde annexé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The standard definition of this function, on most operating systems, is as follows:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La définition standard de cette fonction, sur la plupart des systèmes d&apos;exploitation, est la suivante:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun make-backup-file-name (file)<ph x="1">&lt;x0/&gt;</ph>  \&quot;Create the non-numeric backup file name for FILE...\&quot;<ph x="2">&lt;x1/&gt;</ph>  (concat file \&quot;~\&quot;))<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun make-backup-file-name (fichier) <ph x="1">&lt;x0/&gt;</ph> \ &quot;Créer le nom du fichier de sauvegarde non-numérique pour le fichier ... \&quot; <ph x="2">&lt;x1/&gt;</ph> (Fichier de concat \ &quot;~ \&quot;)) <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You can change the backup-file naming convention by redefining this function.  The following example redefines @code{make-backup-file-name} to prepend a @samp{.} in addition to appending a tilde:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous pouvez modifier la convention de nommage fichier de sauvegarde en redéfinissant cette fonction. L&apos;exemple suivant redéfinit @ code {make-backup-file-name} faire précéder un @ samp en plus de l&apos;ajout d&apos;un tilde {.}:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun make-backup-file-name (filename)<ph x="1">&lt;x0/&gt;</ph>  (expand-file-name<ph x="2">&lt;x1/&gt;</ph>    (concat \&quot;.\&quot; (file-name-nondirectory filename) \&quot;~\&quot;)<ph x="3">&lt;x2/&gt;</ph>    (file-name-directory filename)))<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun make-backup-file-name (nom de fichier) <ph x="1">&lt;x0/&gt;</ph> (Élargir nom de fichier <ph x="2">&lt;x1/&gt;</ph> (Concat \ &quot;. \&quot; (Nom de fichier-nondirectory nom de fichier) \ &quot;~ \&quot;) <ph x="3">&lt;x2/&gt;</ph> (Nom-fichier-répertoire filename))) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (make-backup-file-name \&quot;backups.texi\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} \&quot;.backups.texi~\&quot;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Make-backup-file-name \ &quot;backups.texi \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} \ &quot;. Backups.texi ~ \&quot; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Some parts of Emacs, including some Dired commands, assume that backup file names end with @samp{~}.  If you do not follow that convention, it will not cause serious problems, but these commands may give less-than-desirable results.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Certaines parties de Emacs, y compris certaines commandes Dired, supposent que les noms de fichiers de sauvegarde se terminent par @ samp {~}. Si vous ne suivez pas cette convention, il ne sera pas causer de graves problèmes, mais ces commandes peut donner des résultats moins-que-souhaitable.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! find-backup-file-name filename</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>trouver-backup-file-name nom de fichier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function computes the file name for a new backup file for @var{filename}.  It may also propose certain existing backup files for deletion.  @code{find-backup-file-name} returns a list whose @sc{car} is the name for the new backup file and whose @sc{cdr} is a list of backup files whose deletion is proposed.  The value can also be @code{nil}, which means not to make a backup.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction calcule le nom de fichier pour un fichier de sauvegarde pour @ var {nom de fichier}. Il peut également proposer certains fichiers de sauvegarde existants pour la suppression. @ Code {trouver-backup-file-name} renvoie une liste dont les sc @ {} voiture est le nom pour le fichier de sauvegarde, et dont les sc @ {cdr} est une liste de fichiers de sauvegarde dont la suppression est proposée. La valeur peut aussi être @ code {nil}, ce qui signifie pas de faire une sauvegarde.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Two variables, @code{kept-old-versions} and @code{kept-new-versions}, determine which backup versions should be kept.  This function keeps those versions by excluding them from the @sc{cdr} of the value.  @xref{Numbered Backups}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Deux variables, @ code {-vieux-versions gardés} et @ code {gardés-nouvelles versions}, qui déterminent les versions de sauvegarde doivent être conservés. Cette fonction conserve les versions en les excluant de la @ sc {cdr} de la valeur. @ Xref {Sauvegardes numérotées}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In this example, the value says that @file{~rms/foo.~5~} is the name to use for the new backup file, and @file{~rms/foo.~3~} is an ``excess&apos;&apos; version that the caller should consider deleting now.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Dans cet exemple, la valeur dit que @ file {~ rms / foo. ~ 5 ~} est le nom à utiliser pour le nouveau fichier de sauvegarde, et @ file {~ rms / foo. ~ 3 ~} est un `` excès » «la version que l&apos;appelant devrait envisager de supprimer maintenant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (find-backup-file-name \&quot;~rms/foo\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} (\&quot;~rms/foo.~5~\&quot; \&quot;~rms/foo.~3~\&quot;)<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Trouver-backup-file-name \ &quot;~ rms / foo \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} (\ &quot;~ rms / foo. ~ 5 ~ \&quot; \ &quot;~ rms / foo. ~ 3 ~ \&quot;) <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! file-newest-backup filename</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fichier le plus récent de sauvegarde-nom</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the name of the most recent backup file for @var{filename}, or @code{nil} if that file has no backup files.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le nom du fichier de sauvegarde la plus récente pour @ var {nom de fichier} ou @ code {nil} si ce fichier n&apos;a pas de fichiers de sauvegarde.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Some file comparison commands use this function so that they can automatically compare a file with its most recent backup.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Certaines commandes de comparaison de fichiers utilisent cette fonction afin qu&apos;ils puissent comparer automatiquement un fichier avec son sauvegarde la plus récente.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs periodically saves all files that you are visiting; this is called @dfn{auto-saving}.  Auto-saving prevents you from losing more than a limited amount of work if the system crashes.  By default, auto-saves happen every 300 keystrokes, or after around 30 seconds of idle time.  @xref{Auto Save, Auto Save, Auto-Saving: Protection Against Disasters, emacs, The GNU Emacs Manual}, for information on auto-save for users.  Here we describe the functions used to implement auto-saving and the variables that control them.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs enregistre régulièrement tous les fichiers que vous visitez, ce qui est appelé @ dfn {auto-sauvegarde}. L&apos;enregistrement automatique vous empêche de perdre plus d&apos;une quantité limitée de travail si le système se bloque. Par défaut, enregistre automatiquement toutes les 300 se frappes, ou après environ 30 secondes d&apos;inactivité. @ Xref {Auto Save, Auto Save, Auto-Saving: Protection contre les sinistres, emacs, Le manuel de GNU Emacs}, des informations sur l&apos;enregistrement automatique pour les utilisateurs. Ici, nous décrivons les fonctions utilisées pour mettre en œuvre l&apos;auto-sauvegarde et les variables qui les contrôlent.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-auto-save-file-name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon auto-save-file-name</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This buffer-local variable is the name of the file used for auto-saving the current buffer.  It is @code{nil} if the buffer should not be auto-saved.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable locale de tampon est le nom du fichier utilisé pour le tampon courant de l&apos;enregistrement automatique. Il est @ code {nil} si le tampon ne doit pas être enregistrée automatiquement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-auto-save-file-name<ph x="1">&lt;x0/&gt;</ph>     @result{} \&quot;/xcssun/users/rms/lewis/#backups.texi#\&quot;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon auto-save-file-name <ph x="1">&lt;x0/&gt;</ph> @ résultat {} \ &quot;/ xcssun / utilisateurs / rms / lewis / # backups.texi # \&quot; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command auto-save-mode arg</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande auto-save mode arg</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When used interactively without an argument, this command is a toggle switch: it turns on auto-saving of the current buffer if it is off, and vice versa.  With an argument @var{arg}, the command turns auto-saving on if the value of @var{arg} is @code{t}, a nonempty list, or a positive integer.  Otherwise, it turns auto-saving off.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsqu&apos;il est utilisé de façon interactive sans argument, cette commande est un commutateur à bascule: il tourne sur l&apos;enregistrement automatique du tampon courant si elle est éteinte, et vice versa. Avec un argument @ var {arg}, la commande active l&apos;enregistrement automatique sur si la valeur de @ var {arg} est @ code {t}, une liste non vide, ou un nombre entier positif. Sinon, il se l&apos;auto-sauvegarde hors tension.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! auto-save-file-name-p filename</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>auto-save-file-name-p nom de fichier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns a non-@code{nil} value if @var{filename} is a string that could be the name of an auto-save file.  It assumes the usual naming convention for auto-save files: a name that begins and ends with hash marks (@samp{#}) is a possible auto-save file name.  The argument @var{filename} should not contain a directory part.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne un code {nil} valeur non-@ si @ var {nom de fichier} est une chaîne qui pourrait être le nom d&apos;un fichier de sauvegarde automatique. Il suppose la convention de dénomination habituelle pour les fichiers de sauvegarde automatique: un nom qui commence et se termine avec des marques de hachage (@ samp {#}) est un nom possible auto-enregistrer le fichier. L&apos;argument @ var {nom de fichier} ne doit pas contenir une partie du répertoire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (make-auto-save-file-name)<ph x="1">&lt;x0/&gt;</ph>     @result{} \&quot;/xcssun/users/rms/lewis/#backups.texi#\&quot;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Faire-auto-save-file-name) <ph x="1">&lt;x0/&gt;</ph> @ résultat {} \ &quot;/ xcssun / utilisateurs / rms / lewis / # backups.texi # \&quot; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (auto-save-file-name-p \&quot;#backups.texi#\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} 0<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Auto-save-file-name-p \ &quot;# # backups.texi \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} 0 <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (auto-save-file-name-p \&quot;backups.texi\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} nil<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Auto-save-file-name-p \ &quot;backups.texi \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ {} Résultat nul <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun auto-save-file-name-p (filename)<ph x="1">&lt;x0/&gt;</ph>  \&quot;Return non-nil if FILENAME can be yielded by...\&quot;<ph x="2">&lt;x1/&gt;</ph>  (string-match \&quot;^#.*#$\&quot; filename))<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun auto-save-file-name-p (nom de fichier) <ph x="1">&lt;x0/&gt;</ph> \ &quot;Retour non nulle si le fichier peut être donné par ... \&quot; <ph x="2">&lt;x1/&gt;</ph> (String-match de \ &quot;^ #. * # $ \&quot; Nom de fichier)) <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function exists so that you can customize it if you wish to change the naming convention for auto-save files.  If you redefine it, be sure to redefine the function @code{make-auto-save-file-name} correspondingly.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction existe afin que vous puissiez personnaliser si vous souhaitez modifier la convention de nommage pour l&apos;auto-enregistrer des fichiers. Si vous redéfinissez, n&apos;oubliez pas de redéfinir la fonction @ code {make-auto-save-file-name} correspondante.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! make-auto-save-file-name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>faire-auto-save-file-name</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the file name to use for auto-saving the current buffer.  This is just the file name with hash marks (@samp{#}) prepended and appended to it.  This function does not look at the variable @code{auto-save-visited-file-name} (described below); callers of this function should check that variable first.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le nom de fichier à utiliser pour l&apos;enregistrement automatique du tampon courant. Ce n&apos;est que le nom de fichier avec des marques de hachage (@ samp {#}) ajouté en préfixe et annexées à elle. Cette fonction ne regarde pas la variable @ code {nom de fichier de sauvegarde automatique visité} (décrit ci-dessous); appelants de cette fonction doit vérifier que première variable.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here is a simplified version of the standard definition of this function:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici une version simplifiée de la définition standard de cette fonction:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun make-auto-save-file-name ()<ph x="1">&lt;x0/&gt;</ph>  \&quot;Return file name to use for auto-saves \\<ph x="2">&lt;x1/&gt;</ph>of current buffer..\&quot;<ph x="3">&lt;x2/&gt;</ph>  (if buffer-file-name<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun make-auto-save-file-name () <ph x="1">&lt;x0/&gt;</ph> \ &quot;Revenir nom de fichier à utiliser pour l&apos;auto-sauvegarde \ \ <ph x="2">&lt;x1/&gt;</ph> de tampon courant .. \ &quot; <ph x="3">&lt;x2/&gt;</ph> (Si le tampon nom de fichier <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT!       (concat<ph x="1">&lt;x0/&gt;</ph>       (file-name-directory buffer-file-name)<ph x="2">&lt;x1/&gt;</ph>       \&quot;#\&quot;<ph x="3">&lt;x2/&gt;</ph>       (file-name-nondirectory buffer-file-name)<ph x="4">&lt;x3/&gt;</ph>       \&quot;#\&quot;)<ph x="5">&lt;x4/&gt;</ph>    (expand-file-name<ph x="6">&lt;x5/&gt;</ph>     (concat \&quot;#%\&quot; (buffer-name) \&quot;#\&quot;))))<ph x="7">&lt;x6/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Concat <ph x="1">&lt;x0/&gt;</ph> (Tampon nom de fichier nom-fichier-répertoire) <ph x="2">&lt;x1/&gt;</ph> \ &quot;# \&quot; <ph x="3">&lt;x2/&gt;</ph> (Nom-fichier-nondirectory tampon nom de fichier) <ph x="4">&lt;x3/&gt;</ph> \ &quot;# \&quot;) <ph x="5">&lt;x4/&gt;</ph> (Élargir nom de fichier <ph x="6">&lt;x5/&gt;</ph> (Concat \ &quot;#% \&quot; (tampon-nom) \ &quot;# \&quot;)))) <ph x="7">&lt;x6/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This exists as a separate function so that you can redefine it to customize the naming convention for auto-save files.  Be sure to change @code{auto-save-file-name-p} in a corresponding way.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cela existe comme une fonction distincte de sorte que vous pouvez redéfinir pour personnaliser la convention de nommage pour l&apos;auto-enregistrer des fichiers. Soyez sûr de changer @ code {auto-save-file-name-p} d&apos;une manière correspondante.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is non-@code{nil}, Emacs auto-saves buffers in the files they are visiting.  That is, the auto-save is done in the same file that you are editing.  Normally, this variable is @code{nil}, so auto-save files have distinct names that are created by @code{make-auto-save-file-name}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est non @ code {nil}, Emacs enregistre automatiquement les tampons dans les fichiers qu&apos;ils visitent. Autrement dit, l&apos;auto-save est fait dans le même fichier que vous modifiez. Normalement, cette variable est @ code {nil}, donc auto-enregistrer des fichiers ont des noms distincts qui sont créés par @ code {make-auto-save-file-name}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When you change the value of this variable, the new value does not take effect in an existing buffer until the next time auto-save mode is reenabled in it.  If auto-save mode is already enabled, auto-saves continue to go in the same file name until @code{auto-save-mode} is called again.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque vous modifiez la valeur de cette variable, la nouvelle valeur ne prend pas effet dans un tampon existant jusqu&apos;à ce que la prochaine fois que le mode d&apos;enregistrement automatique est réactivé en elle. Si le mode d&apos;enregistrement automatique est déjà activée, enregistre automatiquement continuer à aller dans le même nom de fichier jusqu&apos;à ce que @ code {auto-save-mode} est à nouveau appelé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns @code{t} if the current buffer has been auto-saved since the last time it was read in or saved.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne @ code {t} si le tampon courant a été enregistré automatiquement depuis la dernière fois qu&apos;il a été lu ou enregistré.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function marks the current buffer as auto-saved.  The buffer will not be auto-saved again until the buffer text is changed again.  The function returns @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction marque le tampon courant comme sauvegarde automatique. Le tampon ne sera pas enregistré automatiquement jusqu&apos;à ce que le texte du tampon est de nouveau modifié. La fonction retourne @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value of this variable specifies how often to do auto-saving, in terms of number of input events.  Each time this many additional input events are read, Emacs does auto-saving for all buffers in which that is enabled.  Setting this to zero disables autosaving based on the number of characters typed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable spécifie la fréquence à faire l&apos;auto-sauvegarde, en termes de nombre d&apos;événements d&apos;entrée. Chaque fois que ce nombre d&apos;événements d&apos;entrée supplémentaires sont lus, Emacs sauvegarde automatique pour tous les tampons dans laquelle ce qui est permis. Mettre ce paramètre à zéro désactive l&apos;enregistrement automatique en fonction du nombre de caractères tapés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value of this variable is the number of seconds of idle time that should cause auto-saving.  Each time the user pauses for this long, Emacs does auto-saving for all buffers in which that is enabled.  (If the current buffer is large, the specified timeout is multiplied by a factor that increases as the size increases; for a million-byte buffer, the factor is almost 4.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable est le nombre de secondes d&apos;inactivité qui doit provoquer l&apos;auto-sauvegarde. Chaque fois que l&apos;utilisateur fait une pause pour ce long, Emacs sauvegarde automatique pour tous les tampons dans laquelle ce qui est permis. (Si le tampon courant est grande, la durée d&apos;expiration est multipliée par un facteur qui augmente à mesure que la taille augmente, pour une mémoire tampon M-octets, le facteur est de près de 4.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the value is zero or @code{nil}, then auto-saving is not done as a result of idleness, only after a certain number of input events as specified by @code{auto-save-interval}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si la valeur est zéro ou @ code {nil}, alors l&apos;auto-sauvegarde ne se fait pas à la suite de la paresse, mais seulement après un certain nombre d&apos;événements d&apos;entrée comme spécifié par @ code {auto-save-interval}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This normal hook is run whenever an auto-save is about to happen.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce crochet normale est exécutée chaque fois qu&apos;une sauvegarde automatique est sur le point de se produire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is non-@code{nil}, buffers that are visiting files have auto-saving enabled by default.  Otherwise, they do not.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est non @ code {nil}, tampons qui visitent les fichiers ont l&apos;auto-sauvegarde activée par défaut. Sinon, ils ne le font pas.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command do-auto-save &amp;optional no-message current-only</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande ne-auto-save et option sans message en cours uniquement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function auto-saves all buffers that need to be auto-saved.  It saves all buffers for which auto-saving is enabled and that have been changed since the previous auto-save.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction enregistre automatiquement tous les tampons qui doivent être enregistrés automatiquement. Il enregistre tous les tampons pour lesquels l&apos;enregistrement automatique est activé et qui ont été modifiés depuis la précédente enregistrement automatique.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If any buffers are auto-saved, @code{do-auto-save} normally displays a message saying @samp{Auto-saving...} in the echo area while auto-saving is going on.  However, if @var{no-message} is non-@code{nil}, the message is inhibited.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si tous les tampons sont automatiquement sauvegardés, @ code {ne-auto-save} affiche normalement un message disant @ samp {Enregistrement automatique ...} dans la zone écho alors que l&apos;enregistrement automatique est en cours. Toutefois, si @ var {sans message} est non @ code {nil}, le message est inhibée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{current-only} is non-@code{nil}, only the current buffer is auto-saved.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {current seule} est non @ code {nil}, seul le tampon courant est enregistré automatiquement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! delete-auto-save-file-if-necessary &amp;optional force</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>delete-auto-save-file-si-nécessaire et en option vigueur</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function deletes the current buffer&apos;s auto-save file if @code{delete-auto-save-files} is non-@code{nil}.  It is called every time a buffer is saved.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction supprime le fichier de sauvegarde automatique du tampon courant si @ code {delete-auto-save-fichiers} est non @ code {nil}. Il est appelé à chaque fois un tampon est enregistré.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Unless @var{force} is non-@code{nil}, this function only deletes the file if it was written by the current Emacs session since the last true save.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Sauf @ var {} vigueur est non @ code {nil}, cette fonction ne supprime le fichier si elle a été écrite par la session en cours Emacs depuis la dernière sauvegarde vrai.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable is used by the function @code{delete-auto-save-file-if-necessary}.  If it is non-@code{nil}, Emacs deletes auto-save files when a true save is done (in the visited file).  This saves disk space and unclutters your directory.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable est utilisée par la fonction @ code {delete-auto-save-file-si-nécessaire}. Si c&apos;est non @ code {nil}, Emacs supprime automatiquement les fichiers de sauvegarde quand un vrai sauvegarde se fait (dans le fichier visité). Cela permet d&apos;économiser de l&apos;espace disque et désencombre votre répertoire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function adjusts the current buffer&apos;s auto-save file name if the visited file name has changed.  It also renames an existing auto-save file, if it was made in the current Emacs session.  If the visited file name has not changed, this function does nothing.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction ajuste le nom de fichier d&apos;enregistrement automatique du tampon courant si le nom du fichier visité a changé. Il renomme également un fichier de sauvegarde automatique existant, si elle a été faite dans la session en cours Emacs. Si le nom du fichier visité n&apos;a pas changé, cette fonction ne fait rien.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value of this buffer-local variable is the length of the current buffer, when it was last read in, saved, or auto-saved.  This is used to detect a substantial decrease in size, and turn off auto-saving in response.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable locale de tampon est la longueur du tampon courant, quand il a été lu en dernier, enregistré ou enregistré automatiquement. Il est utilisé pour détecter une diminution substantielle de la taille, et désactiver l&apos;enregistrement automatique en réponse.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If it is @minus{}1, that means auto-saving is temporarily shut off in this buffer due to a substantial decrease in size.  Explicitly saving the buffer stores a positive value in this variable, thus reenabling auto-saving.  Turning auto-save mode off or on also updates this variable, so that the substantial decrease in size is forgotten.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si elle est moins @ {} 1, cela signifie que l&apos;enregistrement automatique est temporairement coupée dans ce tampon en raison d&apos;une diminution substantielle de la taille. Sauver explicitement les mémoires tampons d&apos;une valeur positive de cette variable, réactivant ainsi l&apos;auto-sauvegarde. L&apos;activation du mode d&apos;enregistrement automatique ou désactiver met également à jour cette variable, de sorte que la diminution substantielle de la taille est oublié.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable (if non-@code{nil}) specifies a file for recording the names of all the auto-save files.  Each time Emacs does auto-saving, it writes two lines into this file for each buffer that has auto-saving enabled.  The first line gives the name of the visited file (it&apos;s empty if the buffer has none), and the second gives the name of the auto-save file.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable (si non @ code {nil}) spécifie un fichier pour enregistrer les noms de tous les fichiers de sauvegarde automatique. Chaque fois Emacs sauvegarde automatique, il écrit deux lignes dans ce fichier pour chaque tampon qui a permis l&apos;enregistrement automatique. La première ligne donne le nom du fichier visité (il est vide si le tampon a aucun), et le second donne le nom du fichier de sauvegarde automatique.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When Emacs exits normally, it deletes this file; if Emacs crashes, you can look in the file to find all the auto-save files that might contain work that was otherwise lost.  The @code{recover-session} command uses this file to find them.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Quand Emacs se termine normalement, il supprime ce fichier, si Emacs se bloque, vous pouvez regarder dans le fichier pour trouver tous les fichiers de sauvegarde automatique qui pourraient contenir travail qui a été autrement perdu. La commande {récupérer de session} @ code utilise ce fichier pour les trouver.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The default name for this file specifies your home directory and starts with @samp{.saves-}.  It also contains the Emacs process @acronym{ID} and the host name.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le nom par défaut de ce fichier spécifie le répertoire de votre maison et commence par @ samp {. Sauve-}. Il contient également le processus Emacs @ acronyme {ID} et le nom d&apos;hôte.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! After Emacs reads your init file, it initializes @code{auto-save-list-file-name} (if you have not already set it non-@code{nil}) based on this prefix, adding the host name and process ID.  If you set this to @code{nil} in your init file, then Emacs does not initialize @code{auto-save-list-file-name}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Après Emacs lit votre fichier init, il initialise @ code {auto-save-fichier-liste-nom} (si vous ne l&apos;avez pas déjà réglée non @ code {nil}) sur la base de ce préfixe, en ajoutant le nom d&apos;hôte et l&apos;ID de processus . Si vous réglez cette option @ code {nil} dans votre fichier init, Emacs ne s&apos;initialise pas @ code {auto-save-liste-nom de fichier}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you have made extensive changes to a file and then change your mind about them, you can get rid of them by reading in the previous version of the file with the @code{revert-buffer} command.  @xref{Reverting, , Reverting a Buffer, emacs, The GNU Emacs Manual}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous avez fait des modifications importantes à un fichier, puis changer d&apos;avis à leur sujet, vous pouvez vous débarrasser d&apos;eux en lisant dans la version précédente du fichier avec la commande {revert-buffer} @ code. @ Xref {Revenant, Récupération d&apos;un tampon, emacs, Le manuel de GNU Emacs}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command revert-buffer &amp;optional ignore-auto noconfirm preserve-modes</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande revert-buffer et en option ignore-auto noconfirm préserver-modes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command replaces the buffer text with the text of the visited file on disk.  This action undoes all changes since the file was visited or saved.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande remplace le texte de tampon avec le texte du fichier visité sur le disque. Cette action annule toutes les modifications depuis le fichier a été visité ou enregistré.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! By default, if the latest auto-save file is more recent than the visited file, and the argument @var{ignore-auto} is @code{nil}, @code{revert-buffer} asks the user whether to use that auto-save instead.  When you invoke this command interactively, @var{ignore-auto} is @code{t} if there is no numeric prefix argument; thus, the interactive default is not to check the auto-save file.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Par défaut, si le dernier fichier de sauvegarde automatique est plus récent que le fichier visité, et l&apos;argument @ {var ignore-auto} est @ code {nil}, @ code {revert-buffer} demande à l&apos;utilisateur d&apos;utiliser ou non que l&apos;auto -enregistrer à la place. Lorsque vous appelez cette commande interactive, @ var {ignore-auto} est @ code {t} si il n&apos;existe aucun argument préfixe numérique: ainsi, la valeur par défaut interactive n&apos;est pas pour vérifier le fichier de sauvegarde automatique.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Normally, @code{revert-buffer} asks for confirmation before it changes the buffer; but if the argument @var{noconfirm} is non-@code{nil}, @code{revert-buffer} does not ask for confirmation.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Normalement, @ code {revert-buffer} demande confirmation avant de changer le tampon, mais si l&apos;argument @ {var noconfirm} est non @ code {nil}, @ code {revert-buffer} ne demande pas de confirmation.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Normally, this command reinitializes the buffer&apos;s major and minor modes using @code{normal-mode}.  But if @var{preserve-modes} is non-@code{nil}, the modes remain unchanged.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Normalement, cette commande réinitialise les modes majeurs et mineurs du tampon à l&apos;aide de @ code {} en mode normal. Mais si @ var {préserver-modes} est non @ code {nil}, les modes restent inchangés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Reverting tries to preserve marker positions in the buffer by using the replacement feature of @code{insert-file-contents}.  If the buffer contents and the file contents are identical before the revert operation, reverting preserves all the markers.  If they are not identical, reverting does change the buffer; in that case, it preserves the markers in the unchanged text (if any) at the beginning and end of the buffer.  Preserving any additional markers would be problematical.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Revenant tente de préserver les positions des marqueurs dans la mémoire tampon en utilisant la fonction de remplacement de @ code {insert-file-contenu}. Si le contenu du tampon et le contenu du fichier sont identiques avant l&apos;opération de restauration, revenant conserves tous les marqueurs. Si elles ne sont pas identiques, réversion fait changer le tampon, dans ce cas, il conserve les marqueurs dans le texte inchangé (le cas échéant) au début et à la fin de la mémoire tampon. Préserver des marqueurs supplémentaires serait problématique.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You can customize how @code{revert-buffer} does its work by setting the variables described in the rest of this section.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous pouvez personnaliser la façon dont @ code {revert-buffer} fait son travail en définissant les variables décrites dans le reste de cette section.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable holds a list of files that should be reverted without query.  The value is a list of regular expressions.  If the visited file name matches one of these regular expressions, and the file has changed on disk but the buffer is not modified, then @code{revert-buffer} reverts the file without asking the user for confirmation.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable contient une liste de fichiers qui doivent être ramenés sans requête. La valeur est une liste d&apos;expressions régulières. Si le nom du fichier visité correspond à l&apos;une de ces expressions régulières, et le fichier a été modifié sur le disque, mais le tampon n&apos;est pas modifié, alors @ code {revert-buffer} retourne le fichier sans demander confirmation à l&apos;utilisateur.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Some major modes customize @code{revert-buffer} by making buffer-local bindings for these variables:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Certains modes majeurs personnaliser @ code {revert-buffer} en faisant fixations de tampons local pour ces variables:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Definition of revert-buffer-function</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Définition de revert-buffer-fonction</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value of this variable is the function to use to revert this buffer.  If non-@code{nil}, it should be a function with two optional arguments to do the work of reverting.  The two optional arguments, @var{ignore-auto} and @var{noconfirm}, are the arguments that @code{revert-buffer} received.  If the value is @code{nil}, reverting works the usual way.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable est la fonction à utiliser pour revenir ce tampon. Si non @ code {nil}, il devrait être une fonction avec deux arguments optionnels pour faire le travail de revenir. Les deux arguments optionnels, @ var {ignore-auto} et @ var {noconfirm}, sont les arguments que @ code {revert-buffer} reçu. Si la valeur est @ code {nil}, revenant fonctionne de la manière habituelle.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Modes such as Dired mode, in which the text being edited does not consist of a file&apos;s contents but can be regenerated in some other fashion, can give this variable a buffer-local value that is a function to regenerate the contents.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Modes tels que le mode Dired, dans lequel le texte en cours d&apos;édition ne consiste pas du contenu d&apos;un fichier, mais peut être régénéré dans un autre mode, peuvent donner cette variable une valeur locale de tampon qui est une fonction de régénérer le contenu.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value of this variable, if non-@code{nil}, specifies the function to use to insert the updated contents when reverting this buffer.  The function receives two arguments: first the file name to use; second, @code{t} if the user has asked to read the auto-save file.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable, si non @ code {nil}, spécifie la fonction à utiliser pour insérer le contenu mis à jour lors d&apos;un retour de ce tampon. La fonction reçoit deux arguments: d&apos;abord le nom de fichier à utiliser; deuxième, @ code {t} si l&apos;utilisateur a demandé de lire le fichier de sauvegarde automatique.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The reason for a mode to set this variable instead of @code{revert-buffer-function} is to avoid duplicating or replacing the rest of what @code{revert-buffer} does: asking for confirmation, clearing the undo list, deciding the proper major mode, and running the hooks listed below.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La raison d&apos;un mode pour définir cette variable à la place de @ code {revert-buffer-fonction} est d&apos;éviter la duplication ou de remplacer le reste de ce que @ code {revert-buffer} ne: demande de confirmation, d&apos;effacer l&apos;annulation, la décision de la mode majeur bon, et l&apos;exécution des crochets ci-dessous.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This normal hook is run by @code{revert-buffer} before inserting the modified contents---but only if @code{revert-buffer-function} is @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce crochet normale est géré par @ code {revert-buffer} avant d&apos;insérer le contenu modifié --- mais seulement si @ code {revert-buffer-fonction} est @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This normal hook is run by @code{revert-buffer} after inserting the modified contents---but only if @code{revert-buffer-function} is @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce crochet normale est géré par @ code {revert-buffer} après l&apos;insertion le contenu modifié --- mais seulement si @ code {revert-buffer-fonction} est @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! book-spine</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>livre-colonne vertébrale</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs Version 22.1</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs version 22.1</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! for Unix Users</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>pour les utilisateurs Unix</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! by</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>par</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! and the</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>et l&apos;</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! GNU Manual Group</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>GNU Manuel Groupe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A @dfn{buffer} is a Lisp object containing text to be edited.  Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files.  While several buffers may exist at one time, only one buffer is designated the @dfn{current buffer} at any time.  Most editing commands act on the contents of the current buffer.  Each buffer, including the current buffer, may or may not be displayed in any windows.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>A @ dfn {} tampon est un objet contenant du texte Lisp pour être édité. Les tampons sont utilisés pour maintenir le contenu des fichiers qui sont visités, il peut aussi y avoir des tampons qui ne sont pas en visite fichiers. Alors que plusieurs tampons peuvent exister à un moment donné, un seul tampon est désigné @ dfn {de} tampon courant à tout moment. La plupart des commandes de modification agissent sur le contenu de la mémoire tampon en cours. Chaque tampon, y compris le tampon courant, peut ou ne peut pas être affiché dans toutes les fenêtres.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffer Basics</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Bases de tampons</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! What is a buffer?</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Qu&apos;est-ce qu&apos;un tampon?</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Current Buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tampon courant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Designating a buffer as current</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Désignation d&apos;un tampon en courant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! so that primitives will access its contents.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>de sorte que les primitives accéder à son contenu.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffer Names</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tampon des noms</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Accessing and changing buffer names.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Accéder et de modifier les noms de tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffer File Name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Nom du fichier tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The buffer file name indicates which file is visited.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le nom du fichier de tampon indique le fichier qui est visité.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffer Modification</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Modification tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A buffer is @dfn{modified} if it needs to be saved.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un tampon est @ dfn {} modifié si elle a besoin d&apos;être sauvé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Modification Time</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Heure de modification</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Determining whether the visited file was changed</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Déterminer si le fichier a été modifié visité</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ``behind Emacs&apos;s back&apos;&apos;.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>`` Derrière le dos de Emacs&apos;&apos;.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Read Only Buffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lire Seuls les tampons</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Modifying text is not allowed in a read-only buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Modification du texte n&apos;est pas autorisé dans un tampon en lecture seule.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The Buffer List</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le Buffer List</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How to look at all the existing buffers.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment regarder tous les tampons existants.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Creating Buffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Créer des zones tampons</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Functions that create buffers.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Fonctions qui créent des tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Killing Buffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tuer tampons</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffers exist until explicitly killed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tampons existent jusqu&apos;à explicitement tué.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Indirect Buffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tampons indirects</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! An indirect buffer shares text with some other buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un texte indirecte des actions de tampon avec un autre tampon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffer Gap</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tampon Gap</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The gap in the buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;écart dans la mémoire tampon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A @dfn{buffer} is a Lisp object containing text to be edited.  Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files.  Although several buffers normally exist, only one buffer is designated the @dfn{current buffer} at any time.  Most editing commands act on the contents of the current buffer.  Each buffer, including the current buffer, may or may not be displayed in any windows.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>A @ dfn {} tampon est un objet contenant du texte Lisp pour être édité. Les tampons sont utilisés pour maintenir le contenu des fichiers qui sont visités, il peut aussi y avoir des tampons qui ne sont pas en visite fichiers. Bien que plusieurs tampons existent normalement, un seul tampon est désigné @ dfn {de} tampon courant à tout moment. La plupart des commandes de modification agissent sur le contenu de la mémoire tampon en cours. Chaque tampon, y compris le tampon courant, peut ou ne peut pas être affiché dans toutes les fenêtres.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffers in Emacs editing are objects that have distinct names and hold text that can be edited.  Buffers appear to Lisp programs as a special data type.  You can think of the contents of a buffer as a string that you can extend; insertions and deletions may occur in any part of the buffer.  @xref{Text}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tampons dans Emacs édition sont des objets qui ont des noms distincts et le texte d&apos;attente qui peuvent être modifiés. Tampons semblent programmes Lisp comme un type de données particulier. Vous pouvez penser le contenu d&apos;un tampon comme une chaîne que vous pouvez étendre; insertions et des suppressions peuvent se produire dans n&apos;importe quelle partie de la mémoire tampon. @ Xref {texte}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A Lisp buffer object contains numerous pieces of information.  Some of this information is directly accessible to the programmer through variables, while other information is accessible only through special-purpose functions.  For example, the visited file name is directly accessible through a variable, while the value of point is accessible only through a primitive function.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un objet de tampon Lisp contient de nombreuses informations. Certaines de ces informations sont directement accessibles au programmeur par des variables, alors que d&apos;autres informations sont accessibles que par des fonctions spécifiques. Par exemple, le nom du fichier visité est directement accessible par le biais d&apos;une variable, alors que la valeur du point n&apos;est accessible que par une fonction primitive.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffer-specific information that is directly accessible is stored in @dfn{buffer-local} variable bindings, which are variable values that are effective only in a particular buffer.  This feature allows each buffer to override the values of certain variables.  Most major modes override variables such as @code{fill-column} or @code{comment-column} in this way.  For more information about buffer-local variables and functions related to them, see @ref{Buffer-Local Variables}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Informations spécifiques tampon qui est directement accessible est stocké dans @ dfn liaisons de variables {tampon local}, qui sont les valeurs des variables qui ne sont efficaces que dans un tampon particulier. Cette fonction permet à chaque tampon à remplacer les valeurs de certaines variables. La plupart des modes majeurs remplacent les variables telles que @ code {fill-column} ou @ code {} colonne commentaires de cette façon. Pour plus d&apos;informations sur les variables et fonctions tampons locales qui leur sont liées, voir @ ref {Variables Buffer locales}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For functions and variables related to visiting files in buffers, see @ref{Visiting Files} and @ref{Saving Buffers}.  For functions and variables related to the display of buffers in windows, see @ref{Buffers and Windows}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour les fonctions et les variables liées à des fichiers dans des tampons, voir @ ref {} et les fichiers Visiter @ ref {} Sauvegarde tampons. Pour les fonctions et les variables liées à l&apos;affichage des tampons dans les fenêtres, voir @ ref {tampons et Windows}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bufferp object</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>objet bufferp</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns @code{t} if @var{object} is a buffer, @code{nil} otherwise.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne @ code {t} si @ var {objet} est un tampon, @ code {nil} autrement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The Current Buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le tampon courant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! selecting a buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>la sélection d&apos;un tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! changing to another buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>passer à une autre mémoire tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! current buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon courant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! There are, in general, many buffers in an Emacs session.  At any time, one of them is designated as the @dfn{current buffer}.  This is the buffer in which most editing takes place, because most of the primitives for examining or changing text in a buffer operate implicitly on the current buffer (@pxref{Text}).  Normally the buffer that is displayed on the screen in the selected window is the current buffer, but this is not always so: a Lisp program can temporarily designate any buffer as current in order to operate on its contents, without changing what is displayed on the screen.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il n&apos;y a, en général, plusieurs tampons dans une session Emacs. A tout moment, l&apos;un d&apos;entre eux est désigné comme étant l&apos;@ dfn {} tampon courant. C&apos;est le tampon dans lequel la plupart édition a lieu, parce que la plupart des primitives pour examiner ou modifier le texte dans un tampon fonctionnent implicitement sur le tampon courant (@ pxref {texte}). Normalement, le tampon qui est affichée sur l&apos;écran dans la fenêtre sélectionnée est le tampon courant, mais ce n&apos;est pas toujours le cas: un programme Lisp peut temporairement désigner un tampon en courant pour fonctionner sur son contenu, sans modifier ce qui est affiché sur le écran.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The way to designate a current buffer in a Lisp program is by calling @code{set-buffer}.  The specified buffer remains current until a new one is designated.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La façon de désigner un tampon courant dans un programme Lisp est d&apos;appeler @ code {-tampon SET}. La mémoire tampon spécifiée reste actuelle jusqu&apos;à ce qu&apos;un nouveau est désigné.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When an editing command returns to the editor command loop, the command loop designates the buffer displayed in the selected window as current, to prevent confusion: the buffer that the cursor is in when Emacs reads a command is the buffer that the command will apply to.  (@xref{Command Loop}.)  Therefore, @code{set-buffer} is not the way to switch visibly to a different buffer so that the user can edit it.  For that, you must use the functions described in @ref{Displaying Buffers}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Quand une commande d&apos;édition revient à la boucle de commande de l&apos;éditeur, la boucle de commande désigne le tampon affiché dans la fenêtre sélectionnée en courant, pour éviter toute confusion: le tampon que le curseur est quand Emacs lit une commande est le tampon que la commande s&apos;appliquera à . (@ Xref {commande} boucle.) Par conséquent, @ code {set-tampon} n&apos;est pas la façon de passer visiblement à un tampon différent de sorte que l&apos;utilisateur peut modifier. Pour cela, vous devez utiliser les fonctions décrites dans @ ref {Affichage} tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @strong{Warning:} Lisp functions that change to a different current buffer should not depend on the command loop to set it back afterwards.  Editing commands written in Emacs Lisp can be called from other programs as well as from the command loop; it is convenient for the caller if the subroutine does not change which buffer is current (unless, of course, that is the subroutine&apos;s purpose).  Therefore, you should normally use @code{set-buffer} within a @code{save-current-buffer} or @code{save-excursion} (@pxref{Excursions}) form that will restore the current buffer when your function is done.  Here is an example, the code for the command @code{append-to-buffer} (with the documentation string abridged):</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Strong {Attention:} fonctions Lisp qui changent à un tampon courant différente ne doivent pas dépendre de la boucle de commande pour le remettre par la suite. Les commandes d&apos;édition écrits en Emacs Lisp peuvent être appelées à partir d&apos;autres programmes ainsi que de la boucle de commande, il est commode pour l&apos;appelant si le sous-programme ne change pas quel tampon est en cours (à moins, bien sûr, c&apos;est l&apos;objectif de la sous-routine). Par conséquent, vous devriez normalement utiliser @ code {set-tampon} dans un @ code {sauver courant-buffer} ou @ code {sauver excursion} (@ pxref {Excursions}) forme qui permettra de restaurer le tampon courant lorsque votre fonction est faire. Voici un exemple, le code de la commande @ code {append-to-buffer} (avec la chaîne de documentation abrégée):</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun append-to-buffer (buffer start end)<ph x="1">&lt;x0/&gt;</ph>  \&quot;Append to specified buffer the text of the region.<ph x="2">&lt;x1/&gt;</ph>@dots{}\&quot;<ph x="3">&lt;x2/&gt;</ph>  (interactive \&quot;BAppend to buffer: \<ph x="4">&lt;x3/&gt;</ph>r\&quot;)<ph x="5">&lt;x4/&gt;</ph>  (let ((oldbuf (current-buffer)))<ph x="6">&lt;x5/&gt;</ph>    (save-current-buffer<ph x="7">&lt;x6/&gt;</ph>      (set-buffer (get-buffer-create buffer))<ph x="8">&lt;x7/&gt;</ph>      (insert-buffer-substring oldbuf start end))))<ph x="9">&lt;x8/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun append-to-buffer (tampon commencer fin) <ph x="1">&lt;x0/&gt;</ph> \ &quot;Ajouter au tampon spécifié le texte de la région. <ph x="2">&lt;x1/&gt;</ph> @ points {} \ &quot; <ph x="3">&lt;x2/&gt;</ph> (\ Interactive &quot;BAppend à tampon: \ <ph x="4">&lt;x3/&gt;</ph> r \ &quot;) <ph x="5">&lt;x4/&gt;</ph> (Laisser ((oldbuf (courant-buffer))) <ph x="6">&lt;x5/&gt;</ph> (Save-courant tampon <ph x="7">&lt;x6/&gt;</ph> (Tampon mis (get-tampon créer tampon)) <ph x="8">&lt;x7/&gt;</ph> (Insert-buffer-chaîne oldbuf début fin)))) <ph x="9">&lt;x8/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function binds a local variable to record the current buffer, and then @code{save-current-buffer} arranges to make it current again.  Next, @code{set-buffer} makes the specified buffer current.  Finally, @code{insert-buffer-substring} copies the string from the original current buffer to the specified (and now current) buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction relie une variable locale pour enregistrer le tampon courant, et @ code {sauver courant-buffer} s&apos;arrange pour faire courant nouveau. Ensuite, @ code {-tampon définir} fait le courant de mémoire tampon spécifiée. Enfin, @ code {insert-buffer-sous-chaîne} copie la chaîne de la mémoire tampon courant d&apos;origine de la mémoire tampon spécifiée (et maintenant en cours).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the buffer appended to happens to be displayed in some window, the next redisplay will show how its text has changed.  Otherwise, you will not see the change immediately on the screen.  The buffer becomes current temporarily during the execution of the command, but this does not cause it to be displayed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le tampon ajouté au arrive à être affiché dans certains fenêtre, la prochaine réaffichage montrera comment le texte a changé. Sinon, vous ne verrez pas le changement immédiatement sur l&apos;écran. Le tampon devient courant temporairement au cours de l&apos;exécution de la commande, mais cela ne lui fait pas affiché.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you make local bindings (with @code{let} or function arguments) for a variable that may also have buffer-local bindings, make sure that the same buffer is current at the beginning and at the end of the local binding&apos;s scope.  Otherwise you might bind it in one buffer and unbind it in another! There are two ways to do this.  In simple cases, you may see that nothing ever changes the current buffer within the scope of the binding.  Otherwise, use @code{save-current-buffer} or @code{save-excursion} to make sure that the buffer current at the beginning is current again whenever the variable is unbound.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous faites les liaisons locales (avec @ code {laisser} ou les arguments de fonction) pour une variable qui peut également avoir des liaisons de tampon local, assurez-vous que le même tampon est en cours au début et à la fin de la portée de la liaison locale. Sinon, vous pourriez lier dans un tampon et le dissocier d&apos;un autre! Il ya deux façons de le faire. Dans les cas simples, vous pouvez voir que rien ne change jamais le tampon courant dans le cadre de la liaison. Sinon, utilisez le code @ {sauver courant-buffer} ou @ code {sauvegarde} excursion à faire en sorte que le courant de tampon au début est en cours à chaque fois que la variable est non liée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Do not rely on using @code{set-buffer} to change the current buffer back, because that won&apos;t do the job if a quit happens while the wrong buffer is current.  Here is what @emph{not} to do:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ne comptez pas sur l&apos;aide de @ code {-tampon SET} pour changer de tampon en arrière, parce que cela va pas faire le travail si un quittez arrive alors que le mauvais tampon est en cours. Voici ce que @ emph {pas} faire:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (let (buffer-read-only<ph x="1">&lt;x0/&gt;</ph>      (obuf (current-buffer)))<ph x="2">&lt;x1/&gt;</ph>  (set-buffer @dots{})<ph x="3">&lt;x2/&gt;</ph>  @dots{}<ph x="4">&lt;x3/&gt;</ph>  (set-buffer obuf))<ph x="5">&lt;x4/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Laisser (tampon-read-only <ph x="1">&lt;x0/&gt;</ph> (OBUF (courant-buffer))) <ph x="2">&lt;x1/&gt;</ph> (-Tampons Set @ points {}) <ph x="3">&lt;x2/&gt;</ph> @ dots {} <ph x="4">&lt;x3/&gt;</ph> (Tampon mis OBUF)) <ph x="5">&lt;x4/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Using @code{save-current-buffer}, as shown here, handles quitting, errors, and @code{throw}, as well as ordinary evaluation.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Utilisation de @ code {save-courant-buffer}, comme indiqué ici, les poignées de quitter, les erreurs et @ code {} jet, ainsi que l&apos;évaluation ordinaire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (let (buffer-read-only)<ph x="1">&lt;x0/&gt;</ph>  (save-current-buffer<ph x="2">&lt;x1/&gt;</ph>    (set-buffer @dots{})<ph x="3">&lt;x2/&gt;</ph>    @dots{}))<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Laisser (tampon-read-only) <ph x="1">&lt;x0/&gt;</ph> (Save-courant tampon <ph x="2">&lt;x1/&gt;</ph> (-Tampons Set @ points {}) <ph x="3">&lt;x2/&gt;</ph> @ Points {})) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! current-buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>courant-tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the current buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le tampon courant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (current-buffer)<ph x="1">&lt;x0/&gt;</ph>     @result{} #&lt;buffer buffers.texi&gt;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Courant-buffer) <ph x="1">&lt;x0/&gt;</ph> @ Result {} # &lt;buffer buffers.texi&gt; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! set-buffer buffer-or-name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>-tampon définir tampon ou nom</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function makes @var{buffer-or-name} the current buffer.  This does not display the buffer in any window, so the user cannot necessarily see the buffer.  But Lisp programs will now operate on it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction permet @ var {tampon ou nom} le tampon courant. Cette n&apos;affiche pas le tampon dans une fenêtre, afin que l&apos;utilisateur ne peut pas voir nécessairement le tampon. Mais les programmes Lisp vont maintenant fonctionner sur elle.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the buffer identified by @var{buffer-or-name}.  An error is signaled if @var{buffer-or-name} does not identify an existing buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le tampon identifié par @ var {tampon ou nom}. Une erreur est signalée si @ var {tampon ou nom} ne permet pas d&apos;identifier un tampon existant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! save-current-buffer body@dots{}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>enregistrer-courant tampons corps @ points {}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{save-current-buffer} special form saves the identity of the current buffer, evaluates the @var{body} forms, and finally restores that buffer as current.  The return value is the value of the last form in @var{body}.  The current buffer is restored even in case of an abnormal exit via @code{throw} or error (@pxref{Nonlocal Exits}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code {@ save-courant tampon} forme spéciale enregistre l&apos;identité du tampon courant, évalue les @ {var} corps formes, et enfin restaure ce tampon en courant. La valeur de retour est la valeur de la dernière forme de @ var {body}. Le tampon courant est rétabli, même dans le cas d&apos;une sortie anormale via @ code {} jet ou erreur (@ pxref {Quitte non locales}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the buffer that used to be current has been killed by the time of exit from @code{save-current-buffer}, then it is not made current again, of course.  Instead, whichever buffer was current just before exit remains current.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le tampon qui sert à être en cours a été tué au moment de la sortie de @ code {save-courant-buffer}, alors il n&apos;est pas courant fait nouveau, bien sûr. Au lieu de cela, selon tampon était courant juste avant la sortie reste actuel.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! with-current-buffer buffer-or-name body@dots{}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>avec courant-buffer tampon ou nom corps @ points {}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{with-current-buffer} macro saves the identity of the current buffer, makes @var{buffer-or-name} current, evaluates the @var{body} forms, and finally restores the buffer.  The return value is the value of the last form in @var{body}.  The current buffer is restored even in case of an abnormal exit via @code{throw} or error (@pxref{Nonlocal Exits}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ code {avec courant-buffer} macro enregistre l&apos;identité du tampon courant, fait @ var {tampon ou nom} actuelle, évalue les @ {var} corps formes, et restaure enfin le tampon. La valeur de retour est la valeur de la dernière forme de @ var {body}. Le tampon courant est rétabli, même dans le cas d&apos;une sortie anormale via @ code {} jet ou erreur (@ pxref {Quitte non locales}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! An error is signaled if @var{buffer-or-name} does not identify an existing buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une erreur est signalée si @ var {tampon ou nom} ne permet pas d&apos;identifier un tampon existant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! with-temp-buffer body@dots{}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>avec-temp-tampons corps @ points {}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Definition of with-temp-buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Définition des avec-temp-tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{with-temp-buffer} macro evaluates the @var{body} forms with a temporary buffer as the current buffer.  It saves the identity of the current buffer, creates a temporary buffer and makes it current, evaluates the @var{body} forms, and finally restores the previous current buffer while killing the temporary buffer.  By default, undo information (@pxref{Undo}) is not recorded in the buffer created by this macro (but @var{body} can enable that, if needed).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ code {avec-temp-tampon} macro évalue les @ {var} corps forme avec un tampon temporaire comme le tampon courant. Il enregistre l&apos;identité du tampon courant, crée un tampon temporaire et il est en cours, évalue les @ {var} corps formes, et restaure enfin le tampon courant précédent tout en tuant le tampon temporaire. Par défaut, des informations d&apos;annulation (@ pxref {Annuler}) n&apos;est pas enregistré dans la mémoire tampon créée par cette macro (mais @ var {body} peut permettre que, si nécessaire).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The return value is the value of the last form in @var{body}.  You can return the contents of the temporary buffer by using @code{(buffer-string)} as the last form.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de retour est la valeur de la dernière forme de @ var {body}. Vous pouvez retourner le contenu de la mémoire tampon temporaire à l&apos;aide de @ code {(tampon-chaîne)} comme la dernière forme.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The current buffer is restored even in case of an abnormal exit via @code{throw} or error (@pxref{Nonlocal Exits}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le tampon courant est rétabli, même dans le cas d&apos;une sortie anormale via @ code {} jet ou erreur (@ pxref {Quitte non locales}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! See also @code{with-temp-file} in @ref{Definition of with-temp-file,, Writing to Files}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voir aussi @ code {avec-temp-fichier} dans @ ref {Définition de par-temp-fichier, Ecriture dans un fichier}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer names</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>noms de tampons</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Each buffer has a unique name, which is a string.  Many of the functions that work on buffers accept either a buffer or a buffer name as an argument.  Any argument called @var{buffer-or-name} is of this sort, and an error is signaled if it is neither a string nor a buffer.  Any argument called @var{buffer} must be an actual buffer object, not a name.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Chaque tampon a un nom unique, qui est une chaîne. La plupart des fonctions qui travaillent sur les tampons acceptent soit un tampon ou un nom de tampon comme argument. Tout argument appelé @ var {tampon ou nom} est de ce genre, et une erreur est signalée si elle n&apos;est ni une chaîne ni un tampon. Tout argument appelé @ var {} tampon doit être un objet de mémoire tampon réelle, pas un nom.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! hidden buffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampons cachés</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffers without undo information</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampons sans annuler informations</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffers that are ephemeral and generally uninteresting to the user have names starting with a space, so that the @code{list-buffers} and @code{buffer-menu} commands don&apos;t mention them (but if such a buffer visits a file, it @strong{is} mentioned).  A name starting with space also initially disables recording undo information; see @ref{Undo}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tampons qui sont éphémères et généralement sans intérêt pour l&apos;utilisateur ont des noms commençant par un espace, de sorte que le code de @ {list-buffers} et @ code {buffer-menu} commandes ne les mentionne pas (mais si un tel tampon visite d&apos;un fichier , il @ strong {} est mentionné). Un nom commençant avec un espace désactive également un premier enregistrement d&apos;informations d&apos;annulation, voir @ ref {Annuler}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-name &amp;optional buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon-nom et tampon en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the name of @var{buffer} as a string.  If @var{buffer} is not supplied, it defaults to the current buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le nom de @ var {} tampon comme une chaîne. Si @ var {} tampon n&apos;est pas fournie, la valeur par défaut du tampon courant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @code{buffer-name} returns @code{nil}, it means that @var{buffer} has been killed.  @xref{Killing Buffers}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ code {tampon-name} retourne @ code {nil}, cela signifie que @ var {} tampon a été tué. @ Xref {} Tuer tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (buffer-name)<ph x="1">&lt;x0/&gt;</ph>     @result{} \&quot;buffers.texi\&quot;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Tampon-nom) <ph x="1">&lt;x0/&gt;</ph> @ Result {} \ &quot;buffers.texi \&quot; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (setq foo (get-buffer \&quot;temp\&quot;))<ph x="1">&lt;x0/&gt;</ph>     @result{} #&lt;buffer temp&gt;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Setq foo (get-tampon \ &quot;temp \&quot;)) <ph x="1">&lt;x0/&gt;</ph> @ Result {} # &lt;buffer temp&gt; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (kill-buffer foo)<ph x="1">&lt;x0/&gt;</ph>     @result{} nil<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Kill-buffer foo) <ph x="1">&lt;x0/&gt;</ph> @ {} Résultat nul <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (buffer-name foo)<ph x="1">&lt;x0/&gt;</ph>     @result{} nil<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Tampon-nom foo) <ph x="1">&lt;x0/&gt;</ph> @ {} Résultat nul <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! foo<ph x="1">&lt;x0/&gt;</ph>     @result{} #&lt;killed buffer&gt;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>foo <ph x="1">&lt;x0/&gt;</ph> @ Result {} # &lt;killed buffer&gt; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command rename-buffer newname &amp;optional unique</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande rename-buffer nouveaunom et facultatif uniques</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function renames the current buffer to @var{newname}.  An error is signaled if @var{newname} is not a string.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction renomme le tampon courant @ var {} nouveaunom. Une erreur est signalée si @ var {} nouveaunom n&apos;est pas une chaîne.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Ordinarily, @code{rename-buffer} signals an error if @var{newname} is already in use.  However, if @var{unique} is non-@code{nil}, it modifies @var{newname} to make a name that is not in use.  Interactively, you can make @var{unique} non-@code{nil} with a numeric prefix argument.  (This is how the command @code{rename-uniquely} is implemented.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ordinairement, @ code {rename-buffer} signale une erreur si @ var {} nouveaunom est déjà en cours d&apos;utilisation. Toutefois, si @ var {} est unique, non @ code {nil}, il modifie @ var {} nouveaunom se faire un nom qui n&apos;est pas en cours d&apos;utilisation. Interactive, vous pouvez faire @ var {} uniques non @ code {nil} avec un argument préfixe numérique. (C&apos;est ainsi que la commande @ code {rename-unique} est mis en œuvre.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the name actually given to the buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le nom effectivement donné à la mémoire tampon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! get-buffer buffer-or-name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>get-tampon tampon ou nom</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the buffer specified by @var{buffer-or-name}.  If @var{buffer-or-name} is a string and there is no buffer with that name, the value is @code{nil}.  If @var{buffer-or-name} is a buffer, it is returned as given; that is not very useful, so the argument is usually a name.  For example:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le tampon spécifié par @ {var tampon ou nom}. Si @ var {tampon ou nom} est une chaîne et il n&apos;ya pas de tampon avec ce nom, la valeur est @ code {nil}. Si @ var {tampon ou nom} est un tampon, il est retourné comme donné, ce n&apos;est pas très utile, si l&apos;argument est généralement un nom. Par exemple:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (setq b (get-buffer \&quot;lewis\&quot;))<ph x="1">&lt;x0/&gt;</ph>     @result{} #&lt;buffer lewis&gt;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Setq b (get-tampon \ &quot;lewis \&quot;)) <ph x="1">&lt;x0/&gt;</ph> @ Result {} # &lt;buffer lewis&gt; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (get-buffer b)<ph x="1">&lt;x0/&gt;</ph>     @result{} #&lt;buffer lewis&gt;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Get-tampon b) <ph x="1">&lt;x0/&gt;</ph> @ Result {} # &lt;buffer lewis&gt; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (get-buffer \&quot;Frazzle-nots\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} nil<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Get-tampon \ &quot;Frazzle démunis \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ {} Résultat nul <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! See also the function @code{get-buffer-create} in @ref{Creating Buffers}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voir aussi le code de la fonction @ {get-tampon-créer dans} @ ref {} créer des zones tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! generate-new-buffer-name starting-name &amp;optional ignore</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>générer nouveau-tampon nom de départ nom et option ignorent</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns a name that would be unique for a new buffer---but does not create the buffer.  It starts with @var{starting-name}, and produces a name not currently in use for any buffer by appending a number inside of @samp{&lt;@dots{}&gt;}.  It starts at 2 and keeps incrementing the number until it is not the name of an existing buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne un nom qui serait unique pour un nouveau tampon --- mais ne crée pas de la mémoire tampon. Il commence par @ var {name} de départ, et produit un nom pas en cours d&apos;utilisation pour tout tampon en ajoutant un numéro à l&apos;intérieur de @ samp {&lt;@ points {}&gt;}. Il commence à 2 et conserve incrémenter le nombre jusqu&apos;à ce que ce n&apos;est pas le nom d&apos;un tampon existant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the optional second argument @var{ignore} is non-@code{nil}, it should be a string, a potential buffer name.  It means to consider that potential buffer acceptable, if it is tried, even it is the name of an existing buffer (which would normally be rejected).  Thus, if buffers named @samp{foo}, @samp{foo&lt;2&gt;}, @samp{foo&lt;3&gt;} and @samp{foo&lt;4&gt;} exist,</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si l&apos;option deuxième argument @ {var ignorer} est non @ code {nil}, il devrait être une chaîne, un nom de tampon potentiel. Cela signifie de considérer que tampon potentiel acceptable, si elle est jugée, même s&apos;il est le nom d&apos;un tampon existant (qui devrait normalement être rejetée). Ainsi, si les tampons nommés @ samp {foo}, @ samp {foo &lt;2&gt;}, @ samp {foo &lt;3&gt;} et @ samp {foo &lt;4&gt;} existe,</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (generate-new-buffer-name \&quot;foo\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} \&quot;foo&lt;5&gt;\&quot;<ph x="2">&lt;x1/&gt;</ph>(generate-new-buffer-name \&quot;foo\&quot; \&quot;foo&lt;3&gt;\&quot;)<ph x="3">&lt;x2/&gt;</ph>     @result{} \&quot;foo&lt;3&gt;\&quot;<ph x="4">&lt;x3/&gt;</ph>(generate-new-buffer-name \&quot;foo\&quot; \&quot;foo&lt;6&gt;\&quot;)<ph x="5">&lt;x4/&gt;</ph>     @result{} \&quot;foo&lt;5&gt;\&quot;<ph x="6">&lt;x5/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Générer nouveau-tampon-nom \ &quot;foo \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} \ &quot;foo &lt;5&gt; \&quot; <ph x="2">&lt;x1/&gt;</ph> (Générer nouveau-tampon-nom \ &quot;foo \&quot; \ &quot;foo &lt;3&gt; \&quot;) <ph x="3">&lt;x2/&gt;</ph> @ Result {} \ &quot;foo &lt;3&gt; \&quot; <ph x="4">&lt;x3/&gt;</ph> (Générer nouveau-tampon-nom \ &quot;foo \&quot; \ &quot;foo &lt;6&gt; \&quot;) <ph x="5">&lt;x4/&gt;</ph> @ Result {} \ &quot;foo &lt;5&gt; \&quot; <ph x="6">&lt;x5/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! See the related function @code{generate-new-buffer} in @ref{Creating Buffers}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voir la fonction @ code correspondant {générer nouveau tampon} dans @ ref {} créer des zones tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! visited file</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fichier visité</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer file name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>nom de fichier de la mémoire tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! file name of buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>nom de fichier du tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @dfn{buffer file name} is the name of the file that is visited in that buffer.  When a buffer is not visiting a file, its buffer file name is @code{nil}.  Most of the time, the buffer name is the same as the nondirectory part of the buffer file name, but the buffer file name and the buffer name are distinct and can be set independently.  @xref{Visiting Files}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ dfn {nom de fichier tampon} est le nom du fichier qui est visité dans ce tampon. Quand un tampon n&apos;est pas la visite d&apos;un fichier, son nom de fichier de la mémoire tampon est @ code {nil}. La plupart du temps, le nom du tampon est la même que la partie nondirectory du nom de fichier de la mémoire tampon, mais le nom de fichier de la mémoire tampon et le nom de tampon sont distincts et peuvent être réglés indépendamment. @ Xref {Fichiers Visiter}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-file-name &amp;optional buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon nom de fichier et tampon en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the absolute file name of the file that @var{buffer} is visiting.  If @var{buffer} is not visiting any file, @code{buffer-file-name} returns @code{nil}.  If @var{buffer} is not supplied, it defaults to the current buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le nom de fichier absolu du fichier @ {var} tampon est en visite. Si @ var {} tampon ne visite pas un fichier, @ code {tampon nom de fichier} retourne @ code {nil}. Si @ var {} tampon n&apos;est pas fournie, la valeur par défaut du tampon courant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (buffer-file-name (other-buffer))<ph x="1">&lt;x0/&gt;</ph>     @result{} \&quot;/usr/user/lewis/manual/files.texi\&quot;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Tampon nom de fichier (autre-buffer)) <ph x="1">&lt;x0/&gt;</ph> @ Result {} \ &quot;/ usr / user / lewis / manuel / files.texi \&quot; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-file-name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon nom de fichier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This buffer-local variable contains the name of the file being visited in the current buffer, or @code{nil} if it is not visiting a file.  It is a permanent local variable, unaffected by @code{kill-all-local-variables}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable locale de tampon contient le nom du fichier en cours de visite dans le tampon courant, ou @ code {nil} si elle n&apos;est pas la visite d&apos;un fichier. Il s&apos;agit d&apos;une variable locale permanente, affectée par @ code {kill-all-local-variables}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-file-name<ph x="1">&lt;x0/&gt;</ph>     @result{} \&quot;/usr/user/lewis/manual/buffers.texi\&quot;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon nom de fichier <ph x="1">&lt;x0/&gt;</ph> @ Result {} \ &quot;/ usr / user / lewis / manuel / buffers.texi \&quot; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! It is risky to change this variable&apos;s value without doing various other things.  Normally it is better to use @code{set-visited-file-name} (see below); some of the things done there, such as changing the buffer name, are not strictly necessary, but others are essential to avoid confusing Emacs.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il est risqué de modifier la valeur de cette variable sans faire d&apos;autres choses. Normalement, il est préférable d&apos;utiliser @ code {nom de fichier set-visited} (voir ci-dessous); certaines des choses faites là, comme changer le nom du tampon, ne sont pas strictement nécessaire, mais d&apos;autres sont indispensables pour éviter la confusion Emacs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-file-truename</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon-file-truename</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This buffer-local variable holds the abbreviated truename of the file visited in the current buffer, or @code{nil} if no file is visited.  It is a permanent local, unaffected by @code{kill-all-local-variables}.  @xref{Truenames}, and @ref{Definition of abbreviate-file-name}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable locale de tampon détient le truename abrégée du fichier visité dans le tampon courant, ou @ code {nil} si aucun fichier n&apos;est visité. Il s&apos;agit d&apos;un local permanent, affecté par @ code {kill-all-local-variables}. @ Xref {TrueNames} et @ ref {Définition des abréger nom de fichier}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-file-number</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon-numéro de fichier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This buffer-local variable holds the file number and directory device number of the file visited in the current buffer, or @code{nil} if no file or a nonexistent file is visited.  It is a permanent local, unaffected by @code{kill-all-local-variables}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable locale de tampon contient le nombre de fichiers et de répertoires numéro de périphérique du fichier visité dans le tampon courant, ou @ code {nil} si aucun fichier ou un fichier inexistant est visité. Il s&apos;agit d&apos;un local permanent, affecté par @ code {kill-all-local-variables}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value is normally a list of the form @code{(@var{filenum} @var{devnum})}.  This pair of numbers uniquely identifies the file among all files accessible on the system.  See the function @code{file-attributes}, in @ref{File Attributes}, for more information about them.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur est normalement une liste de la forme @ code {(@ var {filenum} @ {var devnum})}. Cette paire de numéros identifiant de façon unique le fichier parmi les fichiers accessibles sur le système. Voir la fonction @ code {fichier-attributs}, dans @ ref {Attributs du fichier}, pour plus d&apos;informations à leur sujet.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @code{buffer-file-name} is the name of a symbolic link, then both numbers refer to the recursive target.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ code {tampon nom de fichier} est le nom d&apos;un lien symbolique, les deux numéros renvoient à la cible récursive.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! get-file-buffer filename</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>obtenir-file-tampon nom de fichier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the buffer visiting file @var{filename}.  If there is no such buffer, it returns @code{nil}.  The argument @var{filename}, which must be a string, is expanded (@pxref{File Name Expansion}), then compared against the visited file names of all live buffers.  Note that the buffer&apos;s @code{buffer-file-name} must match the expansion of @var{filename} exactly.  This function will not recognize other names for the same file.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le tampon visitant fichier @ var {nom de fichier}. Si il n&apos;y a pas de tampon, il retourne @ code {nil}. L&apos;argument @ var {nom}, qui doit être une chaîne, est élargi (@ pxref {nom de fichier} Expansion), puis comparés aux noms de fichiers visités de tous les tampons en direct. Notez que @ code de la mémoire tampon {tampon nom de fichier} doit correspondre à l&apos;expansion de @ var {nom de fichier} exactement. Cette fonction ne reconnaît pas d&apos;autres noms pour le même fichier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (get-file-buffer \&quot;buffers.texi\&quot;)<ph x="1">&lt;x0/&gt;</ph>    @result{} #&lt;buffer buffers.texi&gt;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Get-fichier-tampon \ &quot;buffers.texi \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} # &lt;buffer buffers.texi&gt; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In unusual circumstances, there can be more than one buffer visiting the same file name.  In such cases, this function returns the first such buffer in the buffer list.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Dans des circonstances exceptionnelles, il peut y avoir plus d&apos;un tampon visitant le même nom de fichier. Dans ce cas, cette fonction retourne le premier tampon de ce type dans la liste des tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! find-buffer-visiting filename &amp;optional predicate</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>trouver-tampon visitant nom et option prédicat</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is like @code{get-file-buffer}, except that it can return any buffer visiting the file @emph{possibly under a different name}.  That is, the buffer&apos;s @code{buffer-file-name} does not need to match the expansion of @var{filename} exactly, it only needs to refer to the same file.  If @var{predicate} is non-@code{nil}, it should be a function of one argument, a buffer visiting @var{filename}.  The buffer is only considered a suitable return value if @var{predicate} returns non-@code{nil}.  If it can not find a suitable buffer to return, @code{find-buffer-visiting} returns @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est comme @ code {get-file-tampon}, sauf qu&apos;il peut retourner tout tampon visitant le fichier @ emph {éventuellement sous un autre nom}. C&apos;est, @ code de la mémoire tampon {tampon nom de fichier} n&apos;a pas besoin de répondre à l&apos;expansion de @ var {nom de fichier} exactement, il suffit de se reporter vers le même fichier. Si @ var {prédicat} est non @ code {nil}, il devrait être une fonction à un argument, un tampon de visite @ var {nom de fichier}. Le tampon est seulement considéré comme une valeur de rendement approprié si @ var {} prédicat renvoie non @ code {nil}. Si elle ne peut pas trouver un tampon approprié pour revenir, @ code {trouver-tampon de visite} retourne @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command set-visited-file-name filename &amp;optional no-query along-with-file</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande set-nom de fichier visité nom de fichier et option sans requête long-with-file</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{filename} is a non-empty string, this function changes the name of the file visited in the current buffer to @var{filename}.  (If the buffer had no visited file, this gives it one.)  The @emph{next time} the buffer is saved it will go in the newly-specified file.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {nom de fichier} est une chaîne non vide, cette fonction modifie le nom du fichier visité dans le tampon courant @ var {nom de fichier}. (Si le tampon a pas de fichier visité, ce qui lui donne un.) Le @ emph {} prochaine fois que le tampon est enregistré il ira dans le nouveau fichier spécifié.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command marks the buffer as modified, since it does not (as far as Emacs knows) match the contents of @var{filename}, even if it matched the former visited file.  It also renames the buffer to correspond to the new file name, unless the new name is already in use.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande marque le tampon comme modifié, car il ne (autant que Emacs sait) correspond pas au contenu de @ var {nom}, même si elle correspondait à l&apos;ancien fichier visité. Il renomme également le tampon pour correspondre au nouveau nom de fichier, à moins que le nouveau nom est déjà utilisé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{filename} is @code{nil} or the empty string, that stands for ``no visited file.&apos;&apos; In this case, @code{set-visited-file-name} marks the buffer as having no visited file, without changing the buffer&apos;s modified flag.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {nom de fichier} est @ code {nil} ou une chaîne vide, qui signifie `` pas de fichier visité&apos;&apos;. Dans ce cas, @ code {nom de fichier set-visited} marque le tampon comme ayant pas visité déposer, sans changer le drapeau modifié de la mémoire tampon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Normally, this function asks the user for confirmation if there already is a buffer visiting @var{filename}.  If @var{no-query} is non-@code{nil}, that prevents asking this question.  If there already is a buffer visiting @var{filename}, and the user confirms or @var{query} is non-@code{nil}, this function makes the new buffer name unique by appending a number inside of @samp{&lt;@dots{}&gt;} to @var{filename}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Normalement, cette fonction demande à l&apos;utilisateur de confirmer s&apos;il existe déjà un tampon de visite @ var {nom de fichier}. Si @ var {} sans requête est non @ code {nil}, qui empêche de poser cette question. S&apos;il existe déjà un tampon de visite @ var {nom}, et l&apos;utilisateur confirme ou @ var {query} est non @ code {nil}, cette fonction rend le nouveau nom de tampon unique en ajoutant un numéro à l&apos;intérieur de @ samp {&lt; @ points {}&gt;} pour @ var {nom de fichier}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{along-with-file} is non-@code{nil}, that means to assume that the former visited file has been renamed to @var{filename}.  In this case, the command does not change the buffer&apos;s modified flag, nor the buffer&apos;s recorded last file modification time as reported by @code{visited-file-modtime} (@pxref{Modification Time}).  If @var{along-with-file} is @code{nil}, this function clears the recorded last file modification time, after which @code{visited-file-modtime} returns zero.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {long-with-file} est non @ code {nil}, cela signifie que de supposer que l&apos;ancien fichier visité a été renommé en @ {var filename}. Dans ce cas, la commande ne change pas le drapeau modifié de la mémoire tampon, ni enregistré dernier fichier de la date de modification de la mémoire tampon tel que rapporté par @ code {visité fichier-modtime} (@ pxref {} Heure de modification). Si @ var {long-with-file} est @ code {nil}, cette fonction efface le dernier fichier date de modification enregistrée, après quoi @ code {visité fichier-modtime} renvoie zéro.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When the function @code{set-visited-file-name} is called interactively, it prompts for @var{filename} in the minibuffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque le code fonction @ {nom de fichier set-visited} est appelé de façon interactive, il invite à @ var {nom de fichier} dans le mini-tampon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! list-buffers-directory</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>list-buffers-répertoire</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This buffer-local variable specifies a string to display in a buffer listing where the visited file name would go, for buffers that don&apos;t have a visited file name.  Dired buffers use this variable.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable locale de tampon spécifie une chaîne à afficher dans la liste de mémoire tampon où le nom du fichier visité irait, pour les tampons qui n&apos;ont pas un nom de fichier visité. Tampons Dired utilisent cette variable.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer modification</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>modification de la mémoire tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! modification flag (of buffer)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>modification drapeau (de tampon)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs keeps a flag called the @dfn{modified flag} for each buffer, to record whether you have changed the text of the buffer.  This flag is set to @code{t} whenever you alter the contents of the buffer, and cleared to @code{nil} when you save it.  Thus, the flag shows whether there are unsaved changes.  The flag value is normally shown in the mode line (@pxref{Mode Line Variables}), and controls saving (@pxref{Saving Buffers}) and auto-saving (@pxref{Auto-Saving}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs garde un indicateur appelé la @ dfn {drapeau} modifié pour chaque tampon, pour indiquer si vous avez modifié le texte de la mémoire tampon. Ce drapeau est mis à @ code {t} chaque fois que vous modifiez le contenu de la mémoire tampon, et autorisé à @ code {nil} lorsque vous l&apos;enregistrez. Ainsi, le drapeau indique si il ya des modifications non enregistrées. La valeur de l&apos;indicateur est normalement indiqué dans la ligne de mode (@ de pxref {Variables mode de ligne}), et commandes d&apos;économie (@ pxref {} Sauvegarde tampons) et l&apos;enregistrement automatique (@ pxref {Auto-Saving}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Some Lisp programs set the flag explicitly.  For example, the function @code{set-visited-file-name} sets the flag to @code{t}, because the text does not match the newly-visited file, even if it is unchanged from the file formerly visited.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Certains programmes Lisp mis le drapeau explicitement. Par exemple, la fonction @ code {set visité nom de fichier} définit l&apos;indicateur à @ code {t}, parce que le texte ne correspond pas au fichier nouvellement visité, même si elle n&apos;a pas changé depuis le fichier précédemment visité.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The functions that modify the contents of buffers are described in @ref{Text}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions qui modifient le contenu des tampons sont décrits dans @ ref {texte}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-modified-p &amp;optional buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>-p tampon modifié et tampon en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns @code{t} if the buffer @var{buffer} has been modified since it was last read in from a file or saved, or @code{nil} otherwise.  If @var{buffer} is not supplied, the current buffer is tested.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne @ code {t} si le tampon @ var {} tampon a été modifié depuis sa dernière lecture à partir d&apos;un fichier ou sauvés, ou @ code {nil} autrement. Si @ var {} tampon n&apos;est pas fourni, le tampon courant est testé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! set-buffer-modified-p flag</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>drapeau-p-tampon mis modifiée</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function marks the current buffer as modified if @var{flag} is non-@code{nil}, or as unmodified if the flag is @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction marque le tampon courant comme modifiée si l&apos;@ var {drapeau} est non @ code {nil}, ou non modifiée si le drapeau est @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Another effect of calling this function is to cause unconditional redisplay of the mode line for the current buffer.  In fact, the function @code{force-mode-line-update} works by doing this:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un autre effet de l&apos;appel de cette fonction pour provoquer réaffichage inconditionnelle de la ligne de mode pour le tampon courant. En fait, la fonction @ code {vigueur mode en ligne de mise à jour} fonctionne en faisant ceci:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (set-buffer-modified-p (buffer-modified-p))<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Tampon mis-p modifié (p-tampon modifié)) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! restore-buffer-modified-p flag</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>-p restaurer tampon modifié drapeau</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Like @code{set-buffer-modified-p}, but does not force redisplay of mode lines.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comme @ code {set-tampon-modified-p}, mais ne pas forcer le réaffichage de lignes de mode.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command not-modified &amp;optional arg</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Arg commande pas modifié et en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command marks the current buffer as unmodified, and not needing to be saved.  If @var{arg} is non-@code{nil}, it marks the buffer as modified, so that it will be saved at the next suitable occasion.  Interactively, @var{arg} is the prefix argument.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande marque le tampon courant comme non modifiée, et ne pas avoir besoin d&apos;être sauvé. Si @ var {arg} est non @ code {nil}, il marque le tampon tel que modifié, de sorte qu&apos;il sera enregistrée à la prochaine occasion appropriée. Interactive, @ var {arg} est l&apos;argument de préfixe.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Don&apos;t use this function in programs, since it prints a message in the echo area; use @code{set-buffer-modified-p} (above) instead.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ne pas utiliser cette fonction dans les programmes, car il affiche un message dans la zone écho; utilisation @ code {-p-tampon définir modifié} (ci-dessus) à la place.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-modified-tick &amp;optional buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon-tique tampon modifié et en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns @var{buffer}&apos;s modification-count.  This is a counter that increments every time the buffer is modified.  If @var{buffer} is @code{nil} (or omitted), the current buffer is used.  The counter can wrap around occasionally.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne @ var {} tampon de modification de comptage. Il s&apos;agit d&apos;un compteur qui s&apos;incrémente à chaque fois que le tampon est modifié. Si @ var {} tampon est @ code {nil} (ou omis), le tampon courant est utilisé. Le compteur peut s&apos;enrouler autour de temps en temps.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-chars-modified-tick &amp;optional buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon-tique tampons-chars modifiés et en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns @var{buffer}&apos;s character-change modification-count.  Changes to text properties leave this counter unchanged; however, each time text is inserted or removed from the buffer, the counter is reset to the value that would be returned @code{buffer-modified-tick}.  By comparing the values returned by two @code{buffer-chars-modified-tick} calls, you can tell whether a character change occurred in that buffer in between the calls.  If @var{buffer} is @code{nil} (or omitted), the current buffer is used.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne @ var {} tampon de changement de caractère modification de comptage. Modifications au texte propriétés quittent ce compteur inchangé, mais chaque texte de temps est inséré ou retiré de la mémoire tampon, le compteur est remis à la valeur qui aurait été retourné @ code {-tique tampon modifié}. En comparant les valeurs renvoyées par deux @ code {-tique tampons-chars modifié} appelle, vous pouvez dire si un changement de caractère est survenue dans ce tampon entre les appels. Si @ var {} tampon est @ code {nil} (ou omis), le tampon courant est utilisé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Buffer Modification Time</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tampon Heure de modification</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! comparing file modification time</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>comparant fichier date de modification</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! modification time of buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>date de modification de tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Suppose that you visit a file and make changes in its buffer, and meanwhile the file itself is changed on disk.  At this point, saving the buffer would overwrite the changes in the file.  Occasionally this may be what you want, but usually it would lose valuable information.  Emacs therefore checks the file&apos;s modification time using the functions described below before saving the file.  (@xref{File Attributes}, for how to examine a file&apos;s modification time.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Supposons que vous visitez un fichier et faire des changements dans sa mémoire tampon, et en attendant le fichier lui-même est changé sur le disque. À ce stade, l&apos;enregistrement du tampon écraserait les modifications dans le fichier. Parfois cela peut être ce que vous voulez, mais habituellement il perdrait de précieux renseignements. Emacs vérifie donc l&apos;heure de modification du fichier en utilisant les fonctions décrites ci-dessous avant d&apos;enregistrer le fichier. (@ Xref {Attributs du fichier}, pour la façon d&apos;examiner la date de modification d&apos;un fichier.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! verify-visited-file-modtime buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon vérifier visité fichier-modtime</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function compares what @var{buffer} has recorded for the modification time of its visited file against the actual modification time of the file as recorded by the operating system.  The two should be the same unless some other process has written the file since Emacs visited or saved it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction compare ce @ var {} tampon a enregistré pour l&apos;heure de modification de son fichier visité contre la date de modification réelle du fichier enregistré par le système d&apos;exploitation. Les deux doivent être les mêmes à moins qu&apos;un autre processus a écrit le fichier depuis Emacs visité ou sauvé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function returns @code{t} if the last actual modification time and Emacs&apos;s recorded modification time are the same, @code{nil} otherwise.  It also returns @code{t} if the buffer has no recorded last modification time, that is if @code{visited-file-modtime} would return zero.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction retourne @ code {t} si la dernière date de modification réelle et la date de modification enregistrée d&apos;Emacs sont les mêmes, @ code {nil} autrement. Il renvoie également @ code {t} si le tampon a pas enregistrée date de dernière modification, si tant est que @ code {visité fichier-modtime} reviendrait zéro.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! It always returns @code{t} for buffers that are not visiting a file, even if @code{visited-file-modtime} returns a non-zero value.  For instance, it always returns @code{t} for dired buffers.  It returns @code{t} for buffers that are visiting a file that does not exist and never existed, but @code{nil} for file-visiting buffers whose file has been deleted.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il renvoie toujours @ code {t} pour les tampons qui ne sont pas la visite d&apos;un fichier, même si @ code {visité fichier-modtime} renvoie une valeur non nulle. Par exemple, elle renvoie toujours @ code {t} pour tampons dired. Il retourne @ code {t} pour les tampons qui visitent un fichier qui n&apos;existe pas et n&apos;a jamais existé, mais @ code {nil} pour les tampons de visite de fichier dont le fichier a été supprimé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! clear-visited-file-modtime</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>clair visité fichier-modtime</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function clears out the record of the last modification time of the file being visited by the current buffer.  As a result, the next attempt to save this buffer will not complain of a discrepancy in file modification times.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction efface le record de l&apos;heure de la dernière modification du fichier étant visité par le tampon courant. Par conséquent, la prochaine tentative de sauver ce tampon ne se plaindra pas de divergence dans les dates de modification de fichier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function is called in @code{set-visited-file-name} and other exceptional places where the usual test to avoid overwriting a changed file should not be done.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction est appelée à @ code {nom de fichier set-visited} et d&apos;autres lieux d&apos;exception où le test habituel pour éviter d&apos;écraser un fichier modifié ne doit pas être fait.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! visited-file-modtime</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>visité fichier-modtime</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the current buffer&apos;s recorded last file modification time, as a list of the form @code{(@var{high} @var{low})}.  (This is the same format that @code{file-attributes} uses to return time values; see @ref{File Attributes}.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne enregistré dernier fichier de la date de modification du tampon courant, comme une liste de la forme @ code {(@ var {haut} @ {var bas})}. (C&apos;est le même format que @ code {fichier-attributs} utilise pour renvoyer des valeurs de temps, voir @ ref {Attributs du fichier}.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the buffer has no recorded last modification time, this function returns zero.  This case occurs, for instance, if the buffer is not visiting a file or if the time has been explicitly cleared by @code{clear-visited-file-modtime}.  Note, however, that @code{visited-file-modtime} returns a list for some non-file buffers too.  For instance, in a Dired buffer listing a directory, it returns the last modification time of that directory, as recorded by Dired.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le tampon a pas enregistrée date de dernière modification, cette fonction retourne zéro. Ce cas se présente, par exemple, si le tampon n&apos;est pas la visite d&apos;un fichier ou si le temps a été explicitement autorisé par @ code {clear visité fichier-modtime}. Notez, cependant, que @ code {visité fichier-modtime} renvoie une liste de certains tampons non-fichiers trop. Par exemple, dans un tampon Dired l&apos;inscription d&apos;un répertoire, elle retourne la dernière date de modification de ce répertoire, enregistrée par Dired.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For a new buffer visiting a not yet existing file, @var{high} is @minus{}1 and @var{low} is 65535, that is,</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour un nouveau tampon visitant un fichier qui n&apos;existe pas encore, @ var {} est élevée moins @ {} 1 et @ var {} faible est 65535, c&apos;est-à-</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! 2**16 - 1.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>2 ** 16-1.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @math<ph x="1">&lt;x0/&gt;</ph>-1}.<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Mathématiques <ph x="1">&lt;x0/&gt;</ph> -1}. <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! set-visited-file-modtime &amp;optional time</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>set-visited-file-modtime et en option le temps</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function updates the buffer&apos;s record of the last modification time of the visited file, to the value specified by @var{time} if @var{time} is not @code{nil}, and otherwise to the last modification time of the visited file.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction met à jour le dossier de la mémoire tampon de la date de dernière modification du fichier visité, à la valeur spécifiée par @ var {temps} if @ var {temps} n&apos;est pas @ code {nil}, et contraire à la dernière date de modification de la visite déposer.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{time} is neither @code{nil} nor zero, it should have the form @code{(@var{high} . @var{low})} or @code{(@var{high} @var{low})}, in either case containing two integers, each of which holds 16 bits of the time.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {heure} n&apos;est ni @ code {nil} ni zéro, il devrait avoir la forme @ code {(@ var {} haut. @ {Var bas})} ou @ code {(@ var {haut} @ var {bas})}, dans les deux cas contenant deux entiers, dont chacun détient 16 bits de l&apos;époque.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function is useful if the buffer was not read from the file normally, or if the file itself has been changed for some known benign reason.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction est utile si le tampon n&apos;a pas été lu à partir du fichier normalement, ou si le fichier lui-même a été changé pour une raison bénigne connu.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ask-user-about-supersession-threat filename</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>demander-user-sur-dépassement-menace fichier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function is used to ask a user how to proceed after an attempt to modify an buffer visiting file @var{filename} when the file is newer than the buffer text.  Emacs detects this because the modification time of the file on disk is newer than the last save-time of the buffer.  This means some other program has probably altered the file.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction est utilisée pour demander à un utilisateur la marche à suivre après une tentative de modifier un tampon visitant fichier @ var {nom de fichier} lorsque le fichier est plus récent que le texte du tampon. Emacs détecte ce parce que la date de modification du fichier sur le disque est plus récente que la dernière fois de sauvegarde de la mémoire tampon. Cela signifie un autre programme a probablement modifié le fichier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! file-supersession</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fichier dépassement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Depending on the user&apos;s answer, the function may return normally, in which case the modification of the buffer proceeds, or it may signal a @code{file-supersession} error with data @code{(@var{filename})}, in which case the proposed buffer modification is not allowed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>En fonction de la réponse de l&apos;utilisateur, la fonction peut retourner normalement, dans ce cas, la modification du produit de tampons, ou il peut signaler un @ code {fichier dépassement} erreur avec les données @ code {(@ var {nom de fichier})}, dans auquel cas la modification tampon proposée n&apos;est pas autorisée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function is called automatically by Emacs on the proper occasions.  It exists so you can customize Emacs by redefining it.  See the file @file{userlock.el} for the standard definition.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction est appelée automatiquement par Emacs sur les occasions appropriées. Il existe de sorte que vous pouvez personnaliser Emacs en le redéfinissant. Voir le fichier @ file {de} userlock.el pour la définition standard.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! See also the file locking mechanism in @ref{File Locks}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voir aussi le mécanisme de verrouillage dans le fichier @ ref {Serrures de fichier}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Read-Only Buffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lecture seule tampons</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! read-only buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>lecture seule tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer, read-only</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon en lecture seule</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If a buffer is @dfn{read-only}, then you cannot change its contents, although you may change your view of the contents by scrolling and narrowing.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si un tampon est @ dfn {lecture seule}, alors vous ne pouvez pas modifier son contenu, mais vous pouvez changer votre point de vue du contenu par défilement et le rétrécissement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Read-only buffers are used in two kinds of situations:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lecture seule tampons sont utilisés dans deux types de situations:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A buffer visiting a write-protected file is normally read-only.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un tampon visitant un fichier protégé en écriture est normalement en lecture seule.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here, the purpose is to inform the user that editing the buffer with the aim of saving it in the file may be futile or undesirable.  The user who wants to change the buffer text despite this can do so after clearing the read-only flag with @kbd{C-x C-q}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ici, le but est d&apos;informer l&apos;utilisateur que la modification du tampon dans le but de le sauver dans le fichier peut être futile ou indésirable. L&apos;utilisateur qui veut changer le texte du tampon, malgré ce qui peut le faire après avoir franchi le drapeau de lecture seule avec @ kbd {Cx Cq}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Modes such as Dired and Rmail make buffers read-only when altering the contents with the usual editing commands would probably be a mistake.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Modes tels que Dired et Rmail font tampons en lecture seule lors de la modification du contenu avec les commandes d&apos;édition habituelles seraient probablement une erreur.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The special commands of these modes bind @code{buffer-read-only} to @code{nil} (with @code{let}) or bind @code{inhibit-read-only} to @code{t} around the places where they themselves change the text.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les commandes spéciales de ces modes se lient @ code {tampon-read-only} à @ code {nil} (avec @ code {laisser}) ou bind @ code {inhiber-read-only} à @ code {t} autour des lieux où ils se changent le texte.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-read-only</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon-read-only</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This buffer-local variable specifies whether the buffer is read-only.  The buffer is read-only if this variable is non-@code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable locale de tampon indique si le tampon est en lecture seule. Le tampon est en lecture seule si cette variable est non @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! inhibit-read-only</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>inhiber-read-only</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is non-@code{nil}, then read-only buffers and, depending on the actual value, some or all read-only characters may be modified.  Read-only characters in a buffer are those that have non-@code{nil} @code{read-only} properties (either text properties or overlay properties).  @xref{Special Properties}, for more information about text properties.  @xref{Overlays}, for more information about overlays and their properties.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est non @ code {nil}, alors en lecture seule et tampons, en fonction de la valeur réelle, certains ou tous les caractères en lecture seule peuvent être modifiées. Lecture uniquement des caractères dans un tampon sont ceux qui ont non @ code {nil} @ code {lecture seule} propriétés (soit propriétés de texte ou propriétés de recouvrement). @ Xref {} Propriétés spéciales, pour plus d&apos;informations sur les propriétés de texte. @ Xref {} superpositions, pour plus d&apos;informations sur les superpositions et leurs propriétés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @code{inhibit-read-only} is @code{t}, all @code{read-only} character properties have no effect.  If @code{inhibit-read-only} is a list, then @code{read-only} character properties have no effect if they are members of the list (comparison is done with @code{eq}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ code {inhiber-read-only} est @ code {t}, tout le code de @ {} en lecture seule des propriétés de caractère n&apos;ont pas d&apos;effet. Si @ code {inhiber-read-only} est une liste, @ code {} en lecture seule des propriétés de caractère sont sans effet si elles sont membres de la liste (comparaison est faite avec @ code {eq}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command toggle-read-only &amp;optional arg</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Bascule de commande-lecture seule et en option arg</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This command toggles whether the current buffer is read-only.  It is intended for interactive use; do not use it in programs.  At any given point in a program, you should know whether you want the read-only flag on or off; so you can set @code{buffer-read-only} explicitly to the proper value, @code{t} or @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette commande permet de basculer si le tampon courant est en lecture seule. Il est destiné à une utilisation interactive; ne pas l&apos;utiliser dans les programmes. À un moment donné dans un programme, vous devez savoir si vous voulez l&apos;indicateur de lecture seule ou de désactiver, de sorte que vous pouvez définir @ code {tampon-read-only} explicitement à la valeur correcte, @ code {t} ou @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{arg} is non-@code{nil}, it should be a raw prefix argument.  @code{toggle-read-only} sets @code{buffer-read-only} to @code{t} if the numeric value of that prefix argument is positive and to @code{nil} otherwise.  @xref{Prefix Command Arguments}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {arg} est non @ code {nil}, il devrait être un argument préfixe brut. @ Code {toggle-read-only} définit @ code {tampon-read-only} à @ code {t} si la valeur numérique de cet argument de préfixe est positif et @ code {nil} autrement. @ Xref {Arguments préfixe de commande}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! barf-if-buffer-read-only</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>barf-si-tampon en lecture seule</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function signals a @code{buffer-read-only} error if the current buffer is read-only.  @xref{Using Interactive}, for another way to signal an error if the current buffer is read-only.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction signale un @ code {tampon en lecture seule} erreur si le tampon courant est en lecture seule. @ Xref {} Interactive, une autre façon de signaler une erreur si le tampon courant est en lecture seule.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer list</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>liste des tampons</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @dfn{buffer list} is a list of all live buffers.  The order of the buffers in the list is based primarily on how recently each buffer has been displayed in a window.  Several functions, notably @code{other-buffer}, use this ordering.  A buffer list displayed for the user also follows this order.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ dfn {liste de tampon} est une liste de tous les tampons en direct. L&apos;ordre des tampons dans la liste est basée principalement sur la façon dont récemment chaque tampon a été affiché dans une fenêtre. Plusieurs fonctions, notamment @ code {} autre tampon, utilisez cette commande. Une liste de tampon affiché pour l&apos;utilisateur suit également cette commande.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Creating a buffer adds it to the end of the buffer list, and killing a buffer removes it.  Buffers move to the front of the list when they are selected for display in a window (@pxref{Displaying Buffers}), and to the end when they are buried (see @code{bury-buffer}, below).  There are no functions available to the Lisp programmer which directly manipulate the buffer list.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Création d&apos;un tampon ajoute à la fin de la liste de mémoire tampon, un tampon et de tuer le supprime. Tampons se déplacent à l&apos;avant de la liste quand ils sont sélectionnés pour l&apos;affichage dans une fenêtre (@ pxref {Affichage} tampons), et à la fin, quand ils sont enterrés (voir @ code {enterrer tampon}, ci-dessous). Il n&apos;y a pas les fonctions disponibles pour le programmeur Lisp qui manipulent directement la liste des tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In addition to the fundamental Emacs buffer list, each frame has its own version of the buffer list, in which the buffers that have been selected in that frame come first, starting with the buffers most recently selected @emph{in that frame}.  (This order is recorded in @var{frame}&apos;s @code{buffer-list} frame parameter; see @ref{Buffer Parameters}.)  The buffers that were never selected in @var{frame} come afterward, ordered according to the fundamental Emacs buffer list.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>En plus de la liste fondamentale de tampon d&apos;Emacs, chaque cadre a sa propre version de la liste des tampons, dans lequel les tampons qui ont été sélectionnés dans ce cadre au premier plan, à commencer par les tampons plus récemment sélectionnés @ emph {dans ce cadre}. (Cette commande est enregistrée dans @ var {frame} s &apos;@ code {buffer-list} paramètre de cadre, voir @ ref {tampons Paramètres}.) Les tampons qui n&apos;ont jamais été sélectionnés dans @ var {frame} viennent ensuite classées selon la liste des tampons Emacs fondamentale.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-list &amp;optional frame</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>buffer-list et le cadre en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the buffer list, including all buffers, even those whose names begin with a space.  The elements are actual buffers, not their names.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne la liste des tampons, y compris tous les tampons, même ceux dont le nom commence par un espace. Les éléments sont des tampons réels, et non pas leurs noms.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{frame} is a frame, this returns @var{frame}&apos;s buffer list.  If @var{frame} is @code{nil}, the fundamental Emacs buffer list is used: all the buffers appear in order of most recent selection, regardless of which frames they were selected in.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {frame} est un cadre, cela renvoie @ var {frame} s &apos;de la liste des tampons. Si @ var {frame} est @ code {nil}, la liste fondamentale de tampon d&apos;Emacs est utilisé: tous les tampons apparaissent dans l&apos;ordre de sélection la plus récente, quel que soit le cadres qu&apos;ils ont été sélectionnés po</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (buffer-list)<ph x="1">&lt;x0/&gt;</ph>     @result{} (#&lt;buffer buffers.texi&gt;<ph x="2">&lt;x1/&gt;</ph>         #&lt;buffer  *Minibuf-1*&gt; #&lt;buffer buffer.c&gt;<ph x="3">&lt;x2/&gt;</ph>         #&lt;buffer *Help*&gt; #&lt;buffer TAGS&gt;)<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Buffer-list) <ph x="1">&lt;x0/&gt;</ph> @ Result {} (# &lt;buffer buffers.texi&gt; <ph x="2">&lt;x1/&gt;</ph> # # &lt;buffer *Minibuf-1*&gt; &lt;buffer Buffer.c&gt; <ph x="3">&lt;x2/&gt;</ph> # # &lt;buffer *Help*&gt; &lt;buffer TAGS&gt;) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ;; @r{Note that the name of the minibuffer}<ph x="1">&lt;x0/&gt;</ph>;;   @r{begins with a space!}<ph x="2">&lt;x1/&gt;</ph>(mapcar (function buffer-name) (buffer-list))<ph x="3">&lt;x2/&gt;</ph>    @result{} (\&quot;buffers.texi\&quot; \&quot; *Minibuf-1*\&quot;<ph x="4">&lt;x3/&gt;</ph>        \&quot;buffer.c\&quot; \&quot;*Help*\&quot; \&quot;TAGS\&quot;)<ph x="5">&lt;x4/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>;; @ R {Notez que le nom de la mini-tampon} <ph x="1">&lt;x0/&gt;</ph> ;; @ R {commence par un espace!} <ph x="2">&lt;x1/&gt;</ph> (Mapcar (fonction tampon-nom) (buffer-list)) <ph x="3">&lt;x2/&gt;</ph> @ Result {} (\ &quot;buffers.texi \&quot; \ &quot;* Minibuf-1 * \&quot; <ph x="4">&lt;x3/&gt;</ph> \ &quot;Buffer.c \&quot; \ &quot;* Aide * \&quot; \ &quot;TAGS \&quot;) <ph x="5">&lt;x4/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The list that @code{buffer-list} returns is constructed specifically by @code{buffer-list}; it is not an internal Emacs data structure, and modifying it has no effect on the order of buffers.  If you want to change the order of buffers in the frame-independent buffer list, here is an easy way:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La liste que @ code {buffer-list} renvoie est construit spécifiquement par @ code {buffer-list}, ce n&apos;est pas une structure de données interne d&apos;Emacs, et la modification n&apos;a pas d&apos;effet sur l&apos;ordre de tampons. Si vous souhaitez modifier l&apos;ordre des tampons dans la liste des tampons cadre indépendant, voici un moyen facile:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun reorder-buffer-list (new-list)<ph x="1">&lt;x0/&gt;</ph>  (while new-list<ph x="2">&lt;x1/&gt;</ph>    (bury-buffer (car new-list))<ph x="3">&lt;x2/&gt;</ph>    (setq new-list (cdr new-list))))<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun réapprovisionnement-buffer-list (nouvelle liste) <ph x="1">&lt;x0/&gt;</ph> (Tandis que la nouvelle liste <ph x="2">&lt;x1/&gt;</ph> (Enterrer-tampon (voiture nouvelle liste)) <ph x="3">&lt;x2/&gt;</ph> (Setq nouvelle liste (cdr nouvelle liste)))) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! With this method, you can specify any order for the list, but there is no danger of losing a buffer or adding something that is not a valid live buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Avec cette méthode, vous pouvez spécifier un ordre de la liste, mais il n&apos;y a pas de danger de perdre un tampon ou d&apos;ajouter quelque chose qui n&apos;est pas un tampon en direct valide.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To change the order or value of a frame&apos;s buffer list, set the frame&apos;s @code{buffer-list} frame parameter with @code{modify-frame-parameters} (@pxref{Parameter Access}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour modifier l&apos;ordre ou de la valeur de la liste des tampons d&apos;un cadre, set @ code de la trame de paramètres {buffer-list} cadre avec @ code {modifier-cadres paramètres} (@ pxref {Parameter Access}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! other-buffer &amp;optional buffer visible-ok frame</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>autre tampon et tampon cadre visible ok option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the first buffer in the buffer list other than @var{buffer}.  Usually this is the buffer selected most recently (in frame @var{frame} or else the currently selected frame, @pxref{Input Focus}), aside from @var{buffer}.  Buffers whose names start with a space are not considered at all.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le premier tampon dans la liste des tampons autre que @ var {} tampon. Habituellement, c&apos;est le tampon sélectionné le plus récemment (dans le cadre @ var {frame} ou bien le cadre sélectionné, @ pxref {point d&apos;entrée}), en dehors de @ var {} tampon. Tampons dont le nom commence par un espace ne sont pas considérés du tout.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{buffer} is not supplied (or if it is not a buffer), then @code{other-buffer} returns the first buffer in the selected frame&apos;s buffer list that is not now visible in any window in a visible frame.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {tampon} n&apos;est pas fourni (ou si ce n&apos;est pas un tampon), puis sur @ code {autre tampon} renvoie le premier tampon dans la liste des tampons de l&apos;image sélectionnée qui n&apos;est pas actuellement visible dans une fenêtre dans un cadre visible.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{frame} has a non-@code{nil} @code{buffer-predicate} parameter, then @code{other-buffer} uses that predicate to decide which buffers to consider.  It calls the predicate once for each buffer, and if the value is @code{nil}, that buffer is ignored.  @xref{Buffer Parameters}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {frame} dispose d&apos;un code non-@ {nil} @ code {tampon-prédicat} paramètre, @ code {autre tampon} utilise ce prédicat de décider qui tamponne à considérer. Il appelle le prédicat une fois pour chaque mémoire tampon, et si la valeur est @ code {nil}, ce tampon est ignoré. @ Xref {tampons Paramètres}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{visible-ok} is @code{nil}, @code{other-buffer} avoids returning a buffer visible in any window on any visible frame, except as a last resort.  If @var{visible-ok} is non-@code{nil}, then it does not matter whether a buffer is displayed somewhere or not.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {visible} est ok @ code {nil}, @ code {autre tampon} évite de retourner un tampon visible dans une fenêtre sur un cadre visible, sauf en dernier recours. Si @ var {visible ok} est non @ code {nil}, alors il n&apos;a pas d&apos;importance si un tampon est affiché quelque part ou pas.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If no suitable buffer exists, the buffer @samp{*scratch*} is returned (and created, if necessary).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si aucun tampon approprié existe, le tampon @ samp {* scratch *} est retourné (et créé, si nécessaire).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command bury-buffer &amp;optional buffer-or-name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande enterrer-tampon et tampon en option ou nom</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function puts @var{buffer-or-name} at the end of the buffer list, without changing the order of any of the other buffers on the list.  This buffer therefore becomes the least desirable candidate for @code{other-buffer} to return.  The argument can be either a buffer itself or the name of one.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction met @ var {tampon ou nom} à la fin de la liste des tampons, sans modification de l&apos;ordre de l&apos;un des autres tampons sur la liste. Ce tampon devient donc le candidat le moins souhaitable pour @ code {autre tampon} pour revenir. L&apos;argument peut être soit un tampon lui-même ou le nom d&apos;un.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{bury-buffer} operates on each frame&apos;s @code{buffer-list} parameter as well as the frame-independent Emacs buffer list; therefore, the buffer that you bury will come last in the value of @code{(buffer-list @var{frame})} and in the value of @code{(buffer-list nil)}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Code {enterrer tampon} @ fonctionne sur @ code de chaque trame {buffer-list} paramètre ainsi que la liste des tampons Emacs cadre indépendant et, par conséquent, le tampon que vous enterrez viendra dernier dans la valeur de @ code {(tampon- liste @ var {frame})} et de la valeur de @ code {(buffer-list nil)}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{buffer-or-name} is @code{nil} or omitted, this means to bury the current buffer.  In addition, if the buffer is displayed in the selected window, this switches to some other buffer (obtained using @code{other-buffer}) in the selected window.  But if the buffer is displayed in some other window, it remains displayed there.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {tampon ou nom} est @ code {nil} ou omis, cela signifie pour enterrer le tampon courant. En outre, si le tampon est affiché dans la fenêtre sélectionnée, cette bascule vers une autre mémoire tampon (obtenu en utilisant @ code {autre}-tampon) dans la fenêtre sélectionnée. Mais si la mémoire tampon est affichée dans une autre fenêtre, il y reste affiché.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To replace a buffer in all the windows that display it, use @code{replace-buffer-in-windows}.  @xref{Buffers and Windows}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour remplacer un tampon dans toutes les fenêtres qui s&apos;affichent, utilisez @ code {remplacer le tampon en fenêtres}. @ Xref {tampons et de Windows}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! creating buffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>créer des zones tampons</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffers, creating</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des tampons, créant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This section describes the two primitives for creating buffers.  @code{get-buffer-create} creates a buffer if it finds no existing buffer with the specified name; @code{generate-new-buffer} always creates a new buffer and gives it a unique name.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette section décrit les deux primitives pour créer des zones tampons. @ Code {get-buffer-créer} crée une mémoire tampon si elle ne trouve pas de tampon existant avec le nom spécifié; @ code {générer nouveau tampon} crée toujours un nouveau tampon et lui donne un nom unique.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Other functions you can use to create buffers include @code{with-output-to-temp-buffer} (@pxref{Temporary Displays}) and @code{create-file-buffer} (@pxref{Visiting Files}).  Starting a subprocess can also create a buffer (@pxref{Processes}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Autres fonctions que vous pouvez utiliser pour créer des zones tampons comprennent @ code {avec sortie à temp-tampon} (@ pxref {Affiche temporaires}) et @ code {créer fichier tampon} (@ {pxref fichiers Visiter}). À partir d&apos;un sous-processus peut également créer une zone tampon (@ pxref {processus}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! get-buffer-create name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>get-tampon créer nom</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns a buffer named @var{name}.  It returns a live buffer with that name, if one exists; otherwise, it creates a new buffer.  The buffer does not become the current buffer---this function does not change which buffer is current.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne un tampon nommé @ var {name}. Il retourne une mémoire tampon en direct avec ce nom, s&apos;il en existe un, sinon, il crée un nouveau tampon. Le tampon ne devienne pas le tampon courant --- cette fonction ne change pas ce qui est tampon courant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{name} is a buffer instead of a string, it is returned, even if it is dead.  An error is signaled if @var{name} is neither a string nor a buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {name} est un tampon au lieu d&apos;une chaîne, il est renvoyé, même si elle est morte. Une erreur est signalée si @ var {name} n&apos;est ni une chaîne ni un tampon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (get-buffer-create \&quot;foo\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} #&lt;buffer foo&gt;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Se-tampon de créer \ &quot;foo \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} # &lt;buffer foo&gt; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The major mode for a newly created buffer is set to Fundamental mode.  (The variable @code{default-major-mode} is handled at a higher level; see @ref{Auto Major Mode}.)  If the name begins with a space, the buffer initially disables undo information recording (@pxref{Undo}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le mode majeur pour un tampon nouvellement créé est réglé sur le mode fondamental. (La variable @ code {-major-mode par défaut} est traitée à un niveau supérieur;. Voir @ ref {Mode Auto Major}) Si le nom commence par un espace, la mémoire tampon désactive d&apos;abord les informations d&apos;annulation d&apos;enregistrement (@ pxref {Annuler} ).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! generate-new-buffer name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>nom générer nouveau-tampon</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns a newly created, empty buffer, but does not make it current.  If there is no buffer named @var{name}, then that is the name of the new buffer.  If that name is in use, this function adds suffixes of the form @samp{&lt;@var{n}&gt;} to @var{name}, where @var{n} is an integer.  It tries successive integers starting with 2 until it finds an available name.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne un tampon vide nouvellement créé, mais ne permet pas de courant. S&apos;il n&apos;y a pas de tampon nommé @ var {name}, alors que c&apos;est le nom de la nouvelle mémoire tampon. Si ce nom est utilisé, cette fonction ajoute des suffixes de la forme @ samp {&lt;@ var {n}&gt;} pour @ var {name}, où @ var {n} est un entier. Il essaie entiers successifs à partir de 2 jusqu&apos;à ce qu&apos;il trouve un nom disponible.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! An error is signaled if @var{name} is not a string.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une erreur est signalée si @ var {name} n&apos;est pas une chaîne.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (generate-new-buffer \&quot;bar\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} #&lt;buffer bar&gt;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Générer nouveau tampon \ &quot;bar \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} # &lt;buffer d&apos;espace&gt; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (generate-new-buffer \&quot;bar\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} #&lt;buffer bar&lt;2&gt;&gt;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Générer nouveau tampon \ &quot;bar \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} # &lt;bar tampon &lt;2 &gt;&gt; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (generate-new-buffer \&quot;bar\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} #&lt;buffer bar&lt;3&gt;&gt;<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Générer nouveau tampon \ &quot;bar \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} # &lt;bar tampon &lt;3 &gt;&gt; <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The major mode for the new buffer is set to Fundamental mode.  The variable @code{default-major-mode} is handled at a higher level.  @xref{Auto Major Mode}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le mode majeur pour le nouveau tampon est réglé sur le mode fondamental. La variable @ code {-major-mode par défaut} est traitée à un niveau supérieur. @ Xref {mode Major Auto}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! See the related function @code{generate-new-buffer-name} in @ref{Buffer Names}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voir la fonction @ code correspondant {générer nouveau-tampon-name} dans @ ref {} tampons noms.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! killing buffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tuant tampons</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffers, killing</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampons, meurtre</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @dfn{Killing a buffer} makes its name unknown to Emacs and makes the memory space it occupied available for other use.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Dfn {Tuer un tampon} fait son nom inconnu pour Emacs et rend l&apos;espace mémoire qu&apos;il occupait disponible pour les autres.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The buffer object for the buffer that has been killed remains in existence as long as anything refers to it, but it is specially marked so that you cannot make it current or display it.  Killed buffers retain their identity, however; if you kill two distinct buffers, they remain distinct according to @code{eq} although both are dead.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;objet de tampon pour le tampon qui a été tué reste en existence aussi longtemps que quelque chose se réfère à elle, mais il est marqué spécialement pour que vous ne pouvez pas le faire en cours ou l&apos;afficher. Tampons tués conservent leur identité, cependant, si vous tuez deux tampons distincts, ils restent distincts selon @ code {eq} bien que les deux sont morts.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you kill a buffer that is current or displayed in a window, Emacs automatically selects or displays some other buffer instead.  This means that killing a buffer can in general change the current buffer.  Therefore, when you kill a buffer, you should also take the precautions associated with changing the current buffer (unless you happen to know that the buffer being killed isn&apos;t current).  @xref{Current Buffer}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous tuez un tampon qui est en cours ou affichée dans une fenêtre, Emacs sélectionne ou affiche avec un autre tampon au lieu automatiquement. Cela signifie que le meurtre d&apos;un tampon peut en général modifier le tampon courant. Par conséquent, lorsque vous tuez un tampon, vous devez également prendre les précautions liées à l&apos;évolution du tampon courant (sauf si vous connaissez ce que le tampon d&apos;être tué n&apos;est pas courant). @ Xref {} tampon courant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you kill a buffer that is the base buffer of one or more indirect buffers, the indirect buffers are automatically killed as well.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous tuez un tampon qui est le tampon de base d&apos;un ou plusieurs tampons indirects, les tampons indirects sont automatiquement tués ainsi.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{buffer-name} of a killed buffer is @code{nil}.  You can use this feature to test whether a buffer has been killed:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ code {name} tampon d&apos;un tampon est tué @ code {nil}. Vous pouvez utiliser cette fonction pour tester si un tampon a été tué:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun buffer-killed-p (buffer)<ph x="1">&lt;x0/&gt;</ph>  \&quot;Return t if BUFFER is killed.\&quot;<ph x="2">&lt;x1/&gt;</ph>  (not (buffer-name buffer)))<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun tampon-tué-p (tampon) <ph x="1">&lt;x0/&gt;</ph> \ &quot;Retour t si le tampon est tué. \&quot; <ph x="2">&lt;x1/&gt;</ph> (Pas (tampon nom de tampon))) <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command kill-buffer buffer-or-name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande kill-buffer tampon ou nom</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function kills the buffer @var{buffer-or-name}, freeing all its memory for other uses or to be returned to the operating system.  If @var{buffer-or-name} is @code{nil}, it kills the current buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction détruit le tampon @ {var tampon-ou-name}, libérant toute sa mémoire pour d&apos;autres utilisations ou pour être retournée au système d&apos;exploitation. Si @ var {tampon ou nom} est @ code {nil}, il tue le tampon courant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Any processes that have this buffer as the @code{process-buffer} are sent the @code{SIGHUP} signal, which normally causes them to terminate.  (The basic meaning of @code{SIGHUP} is that a dialup line has been disconnected.)  @xref{Signals to Processes}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tous les processus qui ont ce tampon comme le code de @ {processus} tampon sont envoyés le signal SIGHUP {} @ code, ce qui provoque normalement leur terminent. (Le sens fondamental de @ code {} SIGHUP est qu&apos;une ligne commutée a été déconnecté.) @ Xref {} signaux aux processus.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the buffer is visiting a file and contains unsaved changes, @code{kill-buffer} asks the user to confirm before the buffer is killed.  It does this even if not called interactively.  To prevent the request for confirmation, clear the modified flag before calling @code{kill-buffer}.  @xref{Buffer Modification}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le tampon est en visite d&apos;un fichier et contient des modifications non enregistrées, @ code {kill-buffer} demande à l&apos;utilisateur de confirmer avant que le tampon est tué. Il le fait même s&apos;il n&apos;est pas appelé de façon interactive. Pour éviter la demande de confirmation, effacer l&apos;indicateur modifié avant d&apos;appeler @ code {kill-buffer}. @ Xref {tampon Modification}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Killing a buffer that is already dead has no effect.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tuer un tampon qui est déjà mort n&apos;a pas d&apos;effet.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns @code{t} if it actually killed the buffer.  It returns @code{nil} if the user refuses to confirm or if @var{buffer-or-name} was already dead.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne @ code {t} si elle a effectivement tué le tampon. Il retourne @ code {nil} si l&apos;utilisateur refuse de confirmer ou si @ var {tampon ou nom} était déjà mort.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (kill-buffer \&quot;foo.unchanged\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} t<ph x="2">&lt;x1/&gt;</ph>(kill-buffer \&quot;foo.changed\&quot;)<ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Kill-buffer \ &quot;foo.unchanged \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} t <ph x="2">&lt;x1/&gt;</ph> (Kill-buffer \ &quot;foo.changed \&quot;) <ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ---------- Buffer: Minibuffer ----------<ph x="1">&lt;x0/&gt;</ph>Buffer foo.changed modified; kill anyway? (yes or no) @kbd{yes}<ph x="2">&lt;x1/&gt;</ph>---------- Buffer: Minibuffer ----------<ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>---------- Tampon: Minibuffer ---------- <ph x="1">&lt;x0/&gt;</ph> Tampon foo.changed modifiés; tuer de toute façon? (Oui ou non) @ kbd {oui} <ph x="2">&lt;x1/&gt;</ph> ---------- Tampon: Minibuffer ---------- <ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT!      @result{} t<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Result {} t <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! kill-buffer-query-functions</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>kill-buffer-query-fonctions</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! After confirming unsaved changes, @code{kill-buffer} calls the functions in the list @code{kill-buffer-query-functions}, in order of appearance, with no arguments.  The buffer being killed is the current buffer when they are called.  The idea of this feature is that these functions will ask for confirmation from the user.  If any of them returns @code{nil}, @code{kill-buffer} spares the buffer&apos;s life.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Après avoir confirmé les modifications non enregistrées, @ code {kill-buffer} appelle les fonctions dans la liste @ code {tampons-query-fonctions kill-}, par ordre d&apos;apparition, sans arguments. Le tampon d&apos;être tué est le tampon courant quand ils sont appelés. L&apos;idée de cette fonctionnalité est que ces fonctions vont demander confirmation de l&apos;utilisateur. Si l&apos;un d&apos;eux renvoie @ code {nil}, @ code {kill-buffer} épargne la vie de la mémoire tampon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! kill-buffer-hook</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>kill-buffer-crochet</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is a normal hook run by @code{kill-buffer} after asking all the questions it is going to ask, just before actually killing the buffer.  The buffer to be killed is current when the hook functions run.  @xref{Hooks}.  This variable is a permanent local, so its local binding is not cleared by changing major modes.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il s&apos;agit d&apos;un crochet normale géré par @ code {kill-buffer} après avoir demandé à toutes les questions qu&apos;il va poser, juste avant de tuer effectivement le tampon. Le tampon d&apos;être tué est courant lorsque les fonctions de branchements exécutés. @ Xref {} crochets. Cette variable est un local permanent, de sorte que son liaison locale n&apos;est pas éliminée par le changement des modes principaux.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-offer-save</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon offre-save</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable, if non-@code{nil} in a particular buffer, tells @code{save-buffers-kill-emacs} and @code{save-some-buffers} (if the second optional argument to that function is @code{t}) to offer to save that buffer, just as they offer to save file-visiting buffers.  @xref{Definition of save-some-buffers}.  The variable @code{buffer-offer-save} automatically becomes buffer-local when set for any reason.  @xref{Buffer-Local Variables}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable, si non @ code {nil} dans un tampon particulier, dit @ code {sauver-tampons-kill-emacs} et @ code {save-some-buffers} (si le second argument optionnel de cette fonction est @ code {t}) pour offrir à sauver ce tampon, comme ils offrent de sauver des tampons de visite de fichier. @ Xref {Définition de sauvegarde quelque tampons}. La variable @ code {tampon offre-save} devient automatiquement tampon local lorsqu&apos;il est réglé pour une raison quelconque. @ Xref {Variables Buffer locales}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-save-without-query</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon-save-sans-requête</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable, if non-@code{nil} in a particular buffer, tells @code{save-buffers-kill-emacs} and @code{save-some-buffers} to save this buffer (if it&apos;s modified) without asking the user.  The variable automatically becomes buffer-local when set for any reason.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable, si non @ code {nil} dans un tampon particulier, dit @ code {sauver-tampons-kill-emacs} et @ code {save-some-buffers} pour sauver ce tampon (si elle est modifiée) sans demander l&apos; utilisateur. La variable devient automatiquement tampon local lorsqu&apos;il est réglé pour une raison quelconque.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-live-p object</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>objet tampon-live-p</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns @code{t} if @var{object} is a buffer which has not been killed, @code{nil} otherwise.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne @ code {t} si @ var {objet} est un tampon qui n&apos;a pas été tué, @ code {nil} autrement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! indirect buffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampons indirects</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! base buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>un tampon de base</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! An @dfn{indirect buffer} shares the text of some other buffer, which is called the @dfn{base buffer} of the indirect buffer.  In some ways it is the analogue, for buffers, of a symbolic link among files.  The base buffer may not itself be an indirect buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une @ dfn {de} tampon indirect partage le texte avec un autre tampon, qui est appelé le @ dfn {tampon de base} du tampon indirect. À certains égards, il est l&apos;analogue, pour les tampons, d&apos;un lien symbolique entre les fichiers. Le tampon de base peut ne pas être lui-même un tampon indirect.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The text of the indirect buffer is always identical to the text of its base buffer; changes made by editing either one are visible immediately in the other.  This includes the text properties as well as the characters themselves.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le texte du tampon indirect est toujours identique au texte de son tampon de base; changements apportés par la modification ou l&apos;autre sont immédiatement visibles dans l&apos;autre. Cela comprend les propriétés du texte, ainsi que les personnages eux-mêmes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In all other respects, the indirect buffer and its base buffer are completely separate.  They have different names, independent values of point, independent narrowing, independent markers and overlays (though inserting or deleting text in either buffer relocates the markers and overlays for both), independent major modes, and independent buffer-local variable bindings.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>A tous autres égards, le tampon indirect et son tampon de base sont complètement séparées. Ils ont des noms différents, des valeurs indépendantes du point, rétrécissement indépendant, marqueurs indépendants et superpositions (si l&apos;insertion ou la suppression de texte dans les deux tampon déménage les marqueurs et les superpositions pour les deux), les modes principaux indépendants, et liaisons de variables tampons locales indépendantes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! An indirect buffer cannot visit a file, but its base buffer can.  If you try to save the indirect buffer, that actually saves the base buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un tampon indirect ne peut pas visiter un fichier, mais son tampon de base peut. Si vous essayez d&apos;enregistrer le tampon indirect, qui sauve réellement le tampon de base.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Killing an indirect buffer has no effect on its base buffer.  Killing the base buffer effectively kills the indirect buffer in that it cannot ever again be the current buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tuer un tampon indirect n&apos;a aucun effet sur son tampon de base. Détruire le tampon de base tue efficacement le tampon indirect en ce qu&apos;il ne peut pas jamais être le tampon courant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command make-indirect-buffer base-buffer name &amp;optional clone</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande make-indirect-buffer nom de base-tampon et clone en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This creates and returns an indirect buffer named @var{name} whose base buffer is @var{base-buffer}.  The argument @var{base-buffer} may be a live buffer or the name (a string) of an existing buffer.  If @var{name} is the name of an existing buffer, an error is signaled.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cela crée et renvoie un tampon indirect nommé @ var {name} dont le tampon de base est @ {var base tampon}. L&apos;argument @ var {base} tampon peut être un tampon en direct ou le nom (une chaîne) d&apos;un tampon existant. Si @ var {name} est le nom d&apos;un tampon existant, une erreur est signalée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{clone} is non-@code{nil}, then the indirect buffer originally shares the ``state&apos;&apos; of @var{base-buffer} such as major mode, minor modes, buffer local variables and so on.  If @var{clone} is omitted or @code{nil} the indirect buffer&apos;s state is set to the default state for new buffers.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {} clone est non @ code {nil}, alors le tampon indirect part à l&apos;origine de la ``&apos;&apos; état de @ var {base} tampon tel que le mode majeur, mode mineur, tampon variables locales et ainsi de suite. Si @ var {clone} est omis ou @ code {nil} l&apos;état du tampon indirect est réglé sur l&apos;état par défaut pour les nouveaux tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{base-buffer} is an indirect buffer, its base buffer is used as the base for the new buffer.  If, in addition, @var{clone} is non-@code{nil}, the initial state is copied from the actual base buffer, not from @var{base-buffer}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {base} tampon est un tampon indirect, son tampon de base est utilisé comme base pour le nouveau tampon. Si, en plus, @ var {} clone est non @ code {nil}, l&apos;état initial est copié dans la mémoire tampon de base réelle, pas de @ var {base} tampon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! clone-indirect-buffer newname display-flag &amp;optional norecord</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>clone-indirect-buffer nouveaunom affichage drapeau et norecord option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function creates and returns a new indirect buffer that shares the current buffer&apos;s base buffer and copies the rest of the current buffer&apos;s attributes.  (If the current buffer is not indirect, it is used as the base buffer.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction crée et retourne un nouveau tampon indirect qui partage la mémoire tampon et copies de base de la mémoire tampon en cours, le reste des attributs de la mémoire tampon en cours. (Si le tampon courant n&apos;est pas indirect, il est utilisé comme tampon de base.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{display-flag} is non-@code{nil}, that means to display the new buffer by calling @code{pop-to-buffer}.  If @var{norecord} is non-@code{nil}, that means not to put the new buffer to the front of the buffer list.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {display-drapeau} est non @ code {nil}, cela signifie que pour afficher le nouveau tampon en appelant @ code {pop-to-buffer}. Si @ var {norecord} est non @ code {nil}, ce qui signifie pas de mettre le nouveau tampon à l&apos;avant de la liste des tampons.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! buffer-base-buffer &amp;optional buffer</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tampon tampon base-tampon et en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the base buffer of @var{buffer}, which defaults to the current buffer.  If @var{buffer} is not indirect, the value is @code{nil}.  Otherwise, the value is another buffer, which is never an indirect buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le tampon de base de @ var {} tampon, qui est par défaut le tampon courant. Si @ var {} tampon n&apos;est pas indirecte, la valeur est @ code {nil}. Dans le cas contraire, la valeur est une autre mémoire tampon, qui n&apos;est jamais un tampon indirect.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The Buffer Gap</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le tampon Gap</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs buffers are implemented using an invisible @dfn{gap} to make insertion and deletion faster.  Insertion works by filling in part of the gap, and deletion adds to the gap.  Of course, this means that the gap must first be moved to the locus of the insertion or deletion.  Emacs moves the gap only when you try to insert or delete.  This is why your first editing command in one part of a large buffer, after previously editing in another far-away part, sometimes involves a noticeable delay.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les tampons d&apos;Emacs sont mises en œuvre en utilisant un @ dfn {invisible} écart pour faciliter l&apos;insertion et la suppression rapide. Insertion fonctionne en remplissant une partie de l&apos;écart, et la suppression ajoute à l&apos;écart. Bien sûr, cela signifie que l&apos;écart doit tout d&apos;abord être déplacée vers le lieu de l&apos;insertion ou de suppression. Emacs déplace l&apos;écart que lorsque vous essayez d&apos;insérer ou de supprimer. C&apos;est pourquoi votre première commande d&apos;édition dans une partie d&apos;une grande mémoire tampon, après l&apos;édition précédemment dans une autre partie lointain, implique parfois un retard notable.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This mechanism works invisibly, and Lisp code should never be affected by the gap&apos;s current location, but these functions are available for getting information about the gap status.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce mécanisme fonctionne de manière invisible, et le code Lisp ne doit jamais être affectée par l&apos;emplacement actuel de l&apos;écart, mais ces fonctions sont disponibles pour obtenir des informations sur l&apos;état de l&apos;écart.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! gap-position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>écart-poste</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the current gap position in the current buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne la position de l&apos;écart actuel dans le tampon courant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! gap-size</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>écart-taille</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the current gap size of the current buffer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne la taille de l&apos;écart actuel du tampon courant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command Loop</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande en boucle</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Keymaps</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Keymaps</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Minibuffers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Minibuffers</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! editor command loop</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>commande éditeur boucle</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! command loop</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>commande boucle</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When you run Emacs, it enters the @dfn{editor command loop} almost immediately.  This loop reads key sequences, executes their definitions, and displays the results.  In this chapter, we describe how these things are done, and the subroutines that allow Lisp programs to do them.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque vous exécutez Emacs, il entre dans la @ dfn {commande de l&apos;éditeur boucle} presque immédiatement. Cette boucle lit les séquences de touches, exécute leurs définitions, et affiche les résultats. Dans ce chapitre, nous décrivons comment ces choses sont faites, et les sous-programmes qui permettent aux programmes Lisp pour les faire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command Overview</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Présentation commande</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How the command loop reads commands.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment la boucle de commande lit les commandes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Defining Commands</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Définition commandes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Specifying how a function should read arguments.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Spécifier comment une fonction doit lire arguments.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Interactive Call</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Appel Interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Calling a command, so that it will read arguments.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Appel d&apos;une commande, de sorte qu&apos;il sera lu arguments.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command Loop Info</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande Infos boucle</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Variables set by the command loop for you to examine.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Variables définies par la boucle de commande pour vous d&apos;examiner.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Adjusting Point</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Réglage point</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Adjustment of point after a command.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Réglage du point après une commande.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Input Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Événements d&apos;entrée</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! What input looks like when you read it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Qu&apos;est-ce que l&apos;entrée ressemble quand vous le lisez.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Reading Input</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lecture d&apos;entrée</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How to read input events from the keyboard or mouse.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment lire les événements d&apos;entrée à partir du clavier ou de la souris.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Special Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Événements spéciaux</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Events processed immediately and individually.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Evénements traitées immédiatement et individuellement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Waiting</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Attente</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Waiting for user input or elapsed time.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>En attente de saisie de l&apos;utilisateur ou le temps écoulé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Quitting</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Quitter</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How @kbd{C-g} works</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment @ kbd {Cg} œuvres</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How to catch or defer quitting.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment attraper ou de reporter cesser de fumer.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Prefix Command Arguments</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Arguments de la commande préfixe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How the commands to set prefix args work.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment les commandes pour régler args préfixe travaillent.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Recursive Editing</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Récursive édition</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Entering a recursive edit,</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Saisie d&apos;une édition récursive,</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! and why you usually shouldn&apos;t.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>et pourquoi vous ne devriez pas habituellement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Disabling Commands</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Désactivation des commandes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How the command loop handles disabled commands.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment la boucle de commande gère les commandes à mobilité réduite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command History</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Historique des commandes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How the command history is set up, and how accessed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment l&apos;histoire de commande est mis en place, et comment accéder.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Keyboard Macros</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Macros clavier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How keyboard macros are implemented.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment macros clavier sont mises en œuvre.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command Loop Overview</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Commande boucle Présentation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The first thing the command loop must do is read a key sequence, which is a sequence of events that translates into a command.  It does this by calling the function @code{read-key-sequence}.  Your Lisp code can also call this function (@pxref{Key Sequence Input}).  Lisp programs can also do input at a lower level with @code{read-event} (@pxref{Reading One Event}) or discard pending input with @code{discard-input} (@pxref{Event Input Misc}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La première chose que la boucle de commande doit faire est de lire une séquence de touches, qui est une séquence d&apos;événements qui se traduit par une commande. Elle le fait en appelant la fonction @ code {lecture séquence de touches}. Votre code Lisp peut aussi appeler cette fonction (@ {pxref d&apos;entrée de séquence de touches}). Programmes Lisp peuvent également faire l&apos;entrée à un niveau inférieur par @ code {lire événement} (@ pxref {Lire un événement}) ou jeter entrée en cours avec @ code {discard-entrée} (@ pxref {entrée de l&apos;événement Divers}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The key sequence is translated into a command through the currently active keymaps.  @xref{Key Lookup}, for information on how this is done.  The result should be a keyboard macro or an interactively callable function.  If the key is @kbd{M-x}, then it reads the name of another command, which it then calls.  This is done by the command @code{execute-extended-command} (@pxref{Interactive Call}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La séquence de touches est traduite en une commande par l&apos;intermédiaire des claviers actuellement actifs. @ Xref {de} Clé de recherche, des informations sur la façon dont cela est fait. Le résultat devrait être une macro de clavier ou une fonction interactive appelable. Si la clé est @ kbd {Mx}, puis il lit le nom d&apos;une autre commande, qu&apos;elle appelle alors. Cela se fait par la commande @ code {-commande exécuter étendu} (@ pxref {Interactive Appel}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To execute a command requires first reading the arguments for it.  This is done by calling @code{command-execute} (@pxref{Interactive Call}).  For commands written in Lisp, the @code{interactive} specification says how to read the arguments.  This may use the prefix argument (@pxref{Prefix Command Arguments}) or may read with prompting in the minibuffer (@pxref{Minibuffers}).  For example, the command @code{find-file} has an @code{interactive} specification which says to read a file name using the minibuffer.  The command&apos;s function body does not use the minibuffer; if you call this command from Lisp code as a function, you must supply the file name string as an ordinary Lisp function argument.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour exécuter une commande il faut d&apos;abord lire les arguments pour cela. Cela se fait en appelant @ code {commande exécuter} (@ pxref {Interactive Appel}). Pour les commandes écrites en Lisp, le code de @ {} interactive de spécification dit comment lire les arguments. Cela peut utiliser l&apos;argument préfixe (@ de pxref {Arguments préfixe de commande}) ou peut lire avec encouragement dans le mini-tampon (@ pxref {} Minibuffers). Par exemple, la commande @ code {find-file} a un code de @ {} interactive de spécification qui dit de lire un nom de fichier en utilisant le mini-tampon. Le corps de la fonction de la commande n&apos;utilise pas le mini-tampon, si vous appelez cette commande à partir du code Lisp en fonction, vous devez fournir la chaîne de nom de fichier comme argument de fonction Lisp ordinaire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the command is a string or vector (i.e., a keyboard macro) then @code{execute-kbd-macro} is used to execute it.  You can call this function yourself (@pxref{Keyboard Macros}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si la commande est une chaîne ou d&apos;un vecteur (c&apos;est à dire, une macro de clavier) puis @ code {execute-kbd-macro} est utilisé pour l&apos;exécuter. Vous pouvez appeler cette fonction vous-même (@ pxref {} macros de clavier).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To terminate the execution of a running command, type @kbd{C-g}.  This character causes @dfn{quitting} (@pxref{Quitting}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour mettre fin à l&apos;exécution d&apos;une commande en cours d&apos;exécution, tapez @ kbd {Cg}. Ce personnage provoque @ dfn {} quitter (@ pxref {Quitter}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! pre-command-hook</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>pré-commande crochet</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The editor command loop runs this normal hook before each command.  At that time, @code{this-command} contains the command that is about to run, and @code{last-command} describes the previous command.  @xref{Command Loop Info}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La commande en boucle de l&apos;éditeur fonctionne ce crochet normale avant chaque commande. A cette époque, @ code {ce-commande} contient la commande qui est sur le point de lancer, et @ code {dernière commande} décrit la commande précédente. @ Xref {commande Infos boucle}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! post-command-hook</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>post-commande-crochet</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The editor command loop runs this normal hook after each command (including commands terminated prematurely by quitting or by errors), and also when the command loop is first entered.  At that time, @code{this-command} refers to the command that just ran, and @code{last-command} refers to the command before that.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La commande en boucle de l&apos;éditeur fonctionne ce crochet normale après chaque commande (y compris les commandes terminées prématurément par cesser de fumer ou d&apos;erreurs), et aussi quand la boucle de commande est d&apos;abord entré. A cette époque, @ code {ce-commande} fait référence à la commande qui a juste couru, et @ code {dernière commande} fait référence à la commande avant que.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Quitting is suppressed while running @code{pre-command-hook} and @code{post-command-hook}.  If an error happens while executing one of these hooks, it terminates execution of the hook, and clears the hook variable to @code{nil} so as to prevent an infinite loop of errors.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cesser de fumer est supprimée lors de l&apos;exécution @ code {pré-commande crochet} et @ code {post-commande-crochet}. Si une erreur se produit pendant l&apos;exécution d&apos;une de ces crochets, on termine l&apos;exécution de l&apos;hameçon, et efface la variable de crochet à @ code {nil} de manière à éviter une boucle infinie d&apos;erreurs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A request coming into the Emacs server (@pxref{Emacs Server,,, emacs, The GNU Emacs Manual}) runs these two hooks just as a keyboard command does.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une demande entrant dans le serveur Emacs (@ pxref {Emacs Server,,, emacs, Le manuel de GNU Emacs}) exécute ces deux crochets comme une commande de clavier fait.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! defining commands</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>la définition des commandes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! commands, defining</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>commandes, définissant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! functions, making them interactive</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fonctions, les rendant interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! interactive function</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fonction interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A Lisp function becomes a command when its body contains, at top level, a form that calls the special form @code{interactive}.  This form does nothing when actually executed, but its presence serves as a flag to indicate that interactive calling is permitted.  Its argument controls the reading of arguments for an interactive call.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une fonction Lisp devient une commande lorsque son corps contient, au plus haut niveau, une forme qui appelle la forme spéciale @ code {} interactive. Ce formulaire ne fait rien alors qu&apos;en réalité exécuté, mais sa présence sert de drapeau pour indiquer que l&apos;appel est autorisé interactive. Son argument contrôle la lecture des arguments pour une communication interactive.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Using Interactive</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! General rules for @code{interactive}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Règles générales pour @ code {} interactive.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Interactive Codes</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Codes interactifs</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The standard letter-codes for reading arguments</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les lettres-codes standard pour les arguments de lecture</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! in various ways.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>de diverses manières.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Interactive Examples</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Exemples interactifs</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Examples of how to read interactive arguments.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Des exemples de la façon de lire les arguments interactifs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Using @code{interactive}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>En utilisant le code de @ {} interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! arguments, interactive entry</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>arguments, entrée interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This section describes how to write the @code{interactive} form that makes a Lisp function an interactively-callable command, and how to examine a command&apos;s @code{interactive} form.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette section décrit comment écrire le code {@} interactive forme qui fait une fonction Lisp une commande interactive rachetable, et la façon d&apos;examiner @ code {} interactive sous forme d&apos;une commande.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! interactive arg-descriptor</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>interactive arg-descripteur</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This special form declares that the function in which it appears is a command, and that it may therefore be called interactively (via @kbd{M-x} or by entering a key sequence bound to it).  The argument @var{arg-descriptor} declares how to compute the arguments to the command when the command is called interactively.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette forme particulière déclare que la fonction dans laquelle il apparaît est une commande, et qu&apos;il peut donc être appelé de façon interactive (via @ kbd {Mx} ou en entrant une séquence de touches qui lui est lié). L&apos;argument @ {var arg-descripteur} déclare comment calculer les arguments de la commande lorsque la commande est appelée de manière interactive.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A command may be called from Lisp programs like any other function, but then the caller supplies the arguments and @var{arg-descriptor} has no effect.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une commande peut être appelée de programmes Lisp comme toute autre fonction, mais l&apos;appelant fournit les arguments et @ var {arg-descripteur} n&apos;a aucun effet.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @code{interactive} form has its effect because the command loop (actually, its subroutine @code{call-interactively}) scans through the function definition looking for it, before calling the function.  Once the function is called, all its body forms including the @code{interactive} form are executed, but at this time @code{interactive} simply returns @code{nil} without even evaluating its argument.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code {@} interactive forme a son effet, car la boucle de commande (en fait, son code sous-routine @ {appeler interactive}) balaye par la définition de la fonction recherche d&apos;elle, avant d&apos;appeler la fonction. Une fois que la fonction est appelée, toutes ses formes du corps y compris le code de @ {} interactif de forme sont exécutées, mais à ce moment @ code {} interactive renvoie simplement @ code {nil} sans même l&apos;évaluation de son argument.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! There are three possibilities for the argument @var{arg-descriptor}:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il existe trois possibilités pour l&apos;argument @ {var arg-descripteur}:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! It may be omitted or @code{nil}; then the command is called with no arguments.  This leads quickly to an error if the command requires one or more arguments.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il peut être omis ou @ code {nil}, puis la commande est appelée sans aucun argument. Cela conduit rapidement à une erreur si la commande nécessite un ou plusieurs arguments.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! It may be a string; then its contents should consist of a code character followed by a prompt (which some code characters use and some ignore).  The prompt ends either with the end of the string or with a newline.  Here is a simple example:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il peut s&apos;agir d&apos;une chaîne, puis son contenu devrait être composé d&apos;un caractère de code suivi d&apos;un rapide (que certains caractères de code utilisent et certains ignorent). Le message se termine soit à la fin de la chaîne ou avec un saut de ligne. Voici un exemple simple:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (interactive \&quot;bFrobnicate buffer: \&quot;)<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(\ &quot;Tampon bFrobnicate: \&quot; interactif) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The code letter @samp{b} says to read the name of an existing buffer, with completion.  The buffer name is the sole argument passed to the command.  The rest of the string is a prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La lettre de code @ samp {b} dit de lire le nom d&apos;un tampon existant, avec l&apos;achèvement. Le nom de la mémoire tampon est le seul argument passé à la commande. Le reste de la chaîne est une invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If there is a newline character in the string, it terminates the prompt.  If the string does not end there, then the rest of the string should contain another code character and prompt, specifying another argument.  You can specify any number of arguments in this way.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si il ya un caractère de nouvelle ligne dans la chaîne, il met fin à l&apos;invite. Si la chaîne ne s&apos;arrête pas là, puis le reste de la chaîne doit contenir un autre caractère de code et rapide, en spécifiant un autre argument. Vous pouvez spécifier n&apos;importe quel nombre d&apos;arguments de cette façon.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The prompt string can use @samp{%} to include previous argument values (starting with the first argument) in the prompt.  This is done using @code{format} (@pxref{Formatting Strings}).  For example, here is how you could read the name of an existing buffer followed by a new name to give to that buffer:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La chaîne d&apos;invite peut utiliser @ samp {}% pour inclure les valeurs des arguments précédents (en commençant par le premier argument) dans l&apos;invite. Ceci est fait en utilisant @ code {format} (@ pxref {} Formatage de chaînes). Par exemple, voici comment vous pouvez lire le nom d&apos;un tampon existant suivi d&apos;un nouveau nom à donner à ce tampon:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (interactive \&quot;bBuffer to rename: \<ph x="1">&lt;x0/&gt;</ph>sRename buffer <ph x="2">&lt;x1/&gt;</ph> to: \&quot;)<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(\ Interactive &quot;bBuffer renommer: \ <ph x="1">&lt;x0/&gt;</ph> tampon de sRename <ph x="2">&lt;x1/&gt;</ph> pour: \ &quot;) <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @samp{*} in @code{interactive}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Samp {*} à @ code {} interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! read-only buffers in interactive</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>lecture seule tampons en interactif</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the first character in the string is @samp{*}, then an error is signaled if the buffer is read-only.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le premier caractère de la chaîne est @ samp {*}, alors une erreur est signalée si le tampon est en lecture seule.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @samp{@@} in @code{interactive}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Samp {@} @ dans @ code {} interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the first character in the string is @samp{@@}, and if the key sequence used to invoke the command includes any mouse events, then the window associated with the first of those events is selected before the command is run.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le premier caractère de la chaîne est @ samp {@ @}, et si la séquence de touches utilisée pour invoquer la commande comprend tous les événements de la souris, la fenêtre associée à la première de ces événements est sélectionnée avant la commande est exécutée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You can use @samp{*} and @samp{@@} together; the order does not matter.  Actual reading of arguments is controlled by the rest of the prompt string (starting with the first character that is not @samp{*} or @samp{@@}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous pouvez utiliser @ samp {*} et @ samp {@ @} ensemble, l&apos;ordre n&apos;a pas d&apos;importance. Lecture réelle d&apos;arguments est contrôlée par le reste de la chaîne d&apos;invite (en commençant par le premier caractère qui n&apos;est pas @ samp {*} ou @ samp {@ @}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! It may be a Lisp expression that is not a string; then it should be a form that is evaluated to get a list of arguments to pass to the command.  Usually this form will call various functions to read input from the user, most often through the minibuffer (@pxref{Minibuffers})  or directly from the keyboard (@pxref{Reading Input}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est peut-être une expression Lisp qui n&apos;est pas une chaîne, il devrait alors être une forme qui est évaluée pour obtenir une liste d&apos;arguments à passer à la commande. Habituellement ce formulaire seront appeler diverses fonctions à lire les entrées de l&apos;utilisateur, le plus souvent par le mini-tampon (@ pxref {Minibuffers}) ou directement à partir du clavier (@ pxref {Entrée} lecture).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Providing point or the mark as an argument value is also common, but if you do this @emph{and} read input (whether using the minibuffer or not), be sure to get the integer values of point or the mark after reading.  The current buffer may be receiving subprocess output; if subprocess output arrives while the command is waiting for input, it could relocate point and the mark.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Fournir le point ou la marque comme une valeur d&apos;argument est aussi commun, mais si vous faites cela @ emph {et} lu entrée (si en utilisant le mini-tampon ou pas), être sûr d&apos;obtenir les valeurs entières du point ou la marque après la lecture. Le tampon courant reçoit peut-être sortie de sous-processus, si la production de sous-processus arrive alors que la commande est en attente d&apos;entrée, il pourrait déménager points et la marque.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here&apos;s an example of what @emph{not} to do:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici un exemple de ce que @ emph {pas} faire:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (interactive<ph x="1">&lt;x0/&gt;</ph> (list (region-beginning) (region-end)<ph x="2">&lt;x1/&gt;</ph>       (read-string \&quot;Foo: \&quot; nil &apos;my-history)))<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Interactive <ph x="1">&lt;x0/&gt;</ph> (Liste (région-début) (region-end) <ph x="2">&lt;x1/&gt;</ph> (Lire-chaîne \ &quot;Foo: \&quot; néant &quot;mon-histoire))) <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here&apos;s how to avoid the problem, by examining point and the mark after reading the keyboard input:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici comment faire pour éviter le problème, par le point et la marque après la lecture de la saisie au clavier examen:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (interactive<ph x="1">&lt;x0/&gt;</ph> (let ((string (read-string \&quot;Foo: \&quot; nil &apos;my-history)))<ph x="2">&lt;x1/&gt;</ph>   (list (region-beginning) (region-end) string)))<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Interactive <ph x="1">&lt;x0/&gt;</ph> (Laisser ((string (lecture chaîne \ &quot;Foo: \&quot; néant &quot;mon-histoire))) <ph x="2">&lt;x1/&gt;</ph> (Liste (région-début) (region-end) string))) <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @strong{Warning:} the argument values should not include any data types that can&apos;t be printed and then read.  Some facilities save @code{command-history} in a file to be read in the subsequent sessions; if a command&apos;s arguments contain a data type that prints using @samp{#&lt;@dots{}&gt;} syntax, those facilities won&apos;t work.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Strong {Attention:} les valeurs des arguments ne devraient pas inclure tous les types de données qui ne peuvent pas être imprimés puis lus. Certaines installations économiser @ code {command-history} dans un fichier pour être lu dans les sessions ultérieures, si les arguments d&apos;une commande contiennent un type de données qui imprime à l&apos;aide @ samp {# &lt;@ points {}&gt;} syntaxe, ces installations ne sera pas travail.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! There are, however, a few exceptions: it is ok to use a limited set of expressions such as @code{(point)}, @code{(mark)}, @code{(region-beginning)}, and @code{(region-end)}, because Emacs recognizes them specially and puts the expression (rather than its value) into the command history.  To see whether the expression you wrote is one of these exceptions, run the command, then examine @code{(car command-history)}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il ya, cependant, quelques exceptions: il est autorisé à utiliser un nombre limité d&apos;expressions telles que @ code {(points)}, {@ code (marque)}, {@ code (région-début)}, et @ code {(region-end)}, car Emacs les reconnaît spécialement et met l&apos;expression (plutôt que sa valeur) dans l&apos;historique des commandes. Pour voir si l&apos;expression que vous avez écrit est une de ces exceptions, exécutez la commande, puis d&apos;examiner @ code {(voiture commande l&apos;histoire)}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! examining the @code{interactive} form</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>l&apos;examen de la @ code {} interactive forme</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! interactive-form function</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fonction interactive-forme</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the @code{interactive} form of @var{function}.  If @var{function} is an interactively callable function (@pxref{Interactive Call}), the value is the command&apos;s @code{interactive} form @code{(interactive @var{spec})}, which specifies how to compute its arguments.  Otherwise, the value is @code{nil}.  If @var{function} is a symbol, its function definition is used.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le code de @ {} interactif de forme de @ var {fonction}. Si @ var {fonction} est une fonction interactive appelable (@ de pxref {Interactive Appel}), la valeur est @ code de la commande {interactive} forme @ code {(@ interactive var {spec})}, qui spécifie comment calculer son arguments. Sinon, la valeur est @ code {nil}. Si @ var {fonction} est un symbole, sa définition de la fonction est utilisée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Code Characters for @code{interactive}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Code de caractères pour @ code {} interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! interactive code description</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>interactive description du code</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! description for interactive codes</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Description de codes interactifs</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! codes, interactive, description of</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>codes, interactive, la description des</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! characters for interactive codes</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>caractères pour les codes interactifs</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The code character descriptions below contain a number of key words, defined here as follows:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les descriptions de caractères du code ci-dessous contiennent un certain nombre de mots clés, définis ici comme suit:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Completion</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Achèvement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! interactive completion</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>réalisation interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Provide completion.  @key{TAB}, @key{SPC}, and @key{RET} perform name completion because the argument is read using @code{completing-read} (@pxref{Completion}).  @kbd{?} displays a list of possible completions.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Fournir achèvement. @ Key {TAB}, @ key {SPC} et @ key {RET} effectuer achèvement de noms parce que l&apos;argument est lu en utilisant @ code {remplissant lire} (@ pxref {} achèvement). @ Kbd {?} Affiche la liste des complétions possibles.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Existing</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Existant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Require the name of an existing object.  An invalid name is not accepted; the commands to exit the minibuffer do not exit if the current input is not valid.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Exiger le nom d&apos;un objet existant. Un nom incorrect n&apos;est pas accepté, les commandes pour quitter le mini-tampon ne se termine pas si le courant d&apos;entrée n&apos;est pas valide.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Default</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Par défaut</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! default argument string</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>chaîne d&apos;argument par défaut</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A default value of some sort is used if the user enters no text in the minibuffer.  The default depends on the code character.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une valeur par défaut de quelque sorte est utilisée si l&apos;utilisateur ne saisit pas de texte dans le mini-tampon. La valeur par défaut dépend du caractère de code.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! No I/O</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pas d&apos;E / S</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This code letter computes an argument without reading any input.  Therefore, it does not use a prompt string, and any prompt string you supply is ignored.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette lettre de code calcule un argument sans lire toute entrée. Par conséquent, il n&apos;utilise pas une chaîne d&apos;invite, et toute la chaîne d&apos;invite que vous fournissez est ignoré.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Even though the code letter doesn&apos;t use a prompt string, you must follow it with a newline if it is not the last code character in the string.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Même si la lettre de code n&apos;utilise pas une chaîne d&apos;invite, vous devez suivre avec un saut de ligne si ce n&apos;est pas le dernier caractère de code dans la chaîne.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Prompt</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Prompt</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A prompt immediately follows the code character.  The prompt ends either with the end of the string or with a newline.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un message suit immédiatement le caractère de code. Le message se termine soit à la fin de la chaîne ou avec un saut de ligne.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Special</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Spécial</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This code character is meaningful only at the beginning of the interactive string, and it does not look for a prompt or a newline.  It is a single, isolated character.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce caractère de code est valable seulement au début de la chaîne interactive, et il ne semble pas pour une invite ou un saut de ligne. Il s&apos;agit d&apos;un simple, caractère isolé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! reading interactive arguments</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>lecture arguments interactifs</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here are the code character descriptions for use with @code{interactive}:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici les descriptions de caractères de code à utiliser avec @ code {} interactive:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Signal an error if the current buffer is read-only.  Special.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Signaler une erreur si le tampon courant est en lecture seule. Spécial.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @@</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ @</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Select the window mentioned in the first mouse event in the key sequence that invoked this command.  Special.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Sélectionnez la fenêtre mentionnée au premier événement de la souris dans la séquence de touches qui a appelé cette commande. Spécial.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! a</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>un</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A function name (i.e., a symbol satisfying @code{fboundp}).  Existing, Completion, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un nom de fonction (c&apos;est à dire, un symbole satisfaisant @ code {} fboundp). Existant, achèvement, Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! b</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>b</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The name of an existing buffer.  By default, uses the name of the current buffer (@pxref{Buffers}).  Existing, Completion, Default, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le nom d&apos;un tampon existant. Par défaut, utilise le nom du tampon courant (@ pxref {} tampons). Existant, achèvement, par défaut, l&apos;invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! B</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>B</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A buffer name.  The buffer need not exist.  By default, uses the name of a recently used buffer other than the current buffer.  Completion, Default, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un nom de tampon. Le tampon ne doit pas exister. Par défaut, il utilise le nom d&apos;un tampon récemment utilisé autre que le tampon courant. Achèvement, par défaut, l&apos;invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! c</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>c</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A character.  The cursor does not move into the echo area.  Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un personnage. Le curseur ne se déplace pas dans la zone de répercussion. Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! C</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A command name (i.e., a symbol satisfying @code{commandp}).  Existing, Completion, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un nom de commande (c&apos;est à dire, un symbole satisfaisant @ code {} commandp). Existant, achèvement, Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! d</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>ré</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! position argument</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>l&apos;argument de position</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The position of point, as an integer (@pxref{Point}).  No I/O.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La position du point, comme un entier (@ pxref {point}). Pas d&apos;E / O.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! D</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ré</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A directory name.  The default is the current default directory of the current buffer, @code{default-directory} (@pxref{File Name Expansion}).  Existing, Completion, Default, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un nom de répertoire. La valeur par défaut est le répertoire courant par défaut du tampon courant, @ code {default-directory} (@ pxref {nom de fichier} Expansion). Existant, achèvement, par défaut, l&apos;invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! e</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>e</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The first or next mouse event in the key sequence that invoked the command.  More precisely, @samp{e} gets events that are lists, so you can look at the data in the lists.  @xref{Input Events}.  No I/O.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le premier ou prochain événement de la souris dans la séquence de touches qui a appelé la commande. Plus précisément, @ samp {e} obtient les événements qui sont des listes, vous pouvez donc consulter les données dans les listes. @ Xref {entrée} événements. Pas d&apos;E / O.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You can use @samp{e} more than once in a single command&apos;s interactive specification.  If the key sequence that invoked the command has @var{n} events that are lists, the @var{n}th @samp{e} provides the @var{n}th such event.  Events that are not lists, such as function keys and @acronym{ASCII} characters, do not count where @samp{e} is concerned.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous pouvez utiliser @ samp {e} plus d&apos;une fois dans la spécification interactive d&apos;une seule commande. Si la séquence de touches qui a appelé la commande a @ var {n} événements qui sont des listes, le @ var {n} e @ samp {e} fournit le @ var {n} e tel événement. Les événements qui ne sont pas des listes, telles que les touches de fonction et @ acronyme {ASCII} caractères, ne comptez pas où @ samp {e} est concerné.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! f</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fa</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A file name of an existing file (@pxref{File Names}).  The default directory is @code{default-directory}.  Existing, Completion, Default, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un nom de fichier d&apos;un fichier existant (@ de pxref {des noms de fichier}). Le répertoire par défaut est @ code {default-directory}. Existant, achèvement, par défaut, l&apos;invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! F</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Fa</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A file name.  The file need not exist.  Completion, Default, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un nom de fichier. Le fichier n&apos;a pas besoin d&apos;exister. Achèvement, par défaut, l&apos;invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! G</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Sol</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A file name.  The file need not exist.  If the user enters just a directory name, then the value is just that directory name, with no file name within the directory added.  Completion, Default, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un nom de fichier. Le fichier n&apos;a pas besoin d&apos;exister. Si l&apos;utilisateur entre simplement un nom de répertoire, alors la valeur est juste que le nom du répertoire, sans nom de fichier dans le répertoire ajouté. Achèvement, par défaut, l&apos;invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! i</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Je</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! An irrelevant argument.  This code always supplies @code{nil} as the argument&apos;s value.  No I/O.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un argument pertinent. Ce code fournit toujours @ code {nil} comme valeur de l&apos;argument. Pas d&apos;E / O.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! k</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>k</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A key sequence (@pxref{Key Sequences}).  This keeps reading events until a command (or undefined command) is found in the current key maps.  The key sequence argument is represented as a string or vector.  The cursor does not move into the echo area.  Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une séquence de touches (@ de pxref {Séquences clés}). Cela permet la lecture des événements jusqu&apos;à ce qu&apos;une commande (ou commande undefined) se trouve dans les cartes clés actuelles. L&apos;argument de la séquence de touches est représentée comme une chaîne ou d&apos;un vecteur. Le curseur ne se déplace pas dans la zone de répercussion. Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @samp{k} reads a key sequence that ends with a down-event, it also reads and discards the following up-event.  You can get access to that up-event with the @samp{U} code character.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ samp {k} lit une séquence de touches qui se termine par une baisse de l&apos;évènement, il lit aussi et rejette le suivi-événement. Vous pouvez accéder à ce que des cas avec le @ samp {U} de caractères du code.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This kind of input is used by commands such as @code{describe-key} and @code{global-set-key}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce type d&apos;entrée est utilisé par des commandes telles que @ code {describe-key} et @ code {-set-key global}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! K</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>K</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A key sequence, whose definition you intend to change.  This works like @samp{k}, except that it suppresses, for the last input event in the key sequence, the conversions that are normally used (when necessary) to convert an undefined key into a defined one.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une séquence de touches, dont la définition que vous souhaitez modifier. Cela fonctionne comme @ samp {k}, sauf qu&apos;il supprime, pour le dernier événement d&apos;entrée dans la séquence de touches, les conversions qui sont normalement utilisés (si nécessaire) pour convertir une clé définie en un sens.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! m</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>m</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! marker argument</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>argument marqueur</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The position of the mark, as an integer.  No I/O.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La position de la marque, comme un nombre entier. Pas d&apos;E / O.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! M</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>M</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Arbitrary text, read in the minibuffer using the current buffer&apos;s input method, and returned as a string (@pxref{Input Methods,,, emacs, The GNU Emacs Manual}).  Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Texte arbitraire, de lire dans le mini-tampon en utilisant la méthode d&apos;entrée du tampon courant, et revenaient comme une chaîne (@ {pxref des méthodes de saisie,, emacs, Le manuel de GNU Emacs}). Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! n</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>n</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A number, read with the minibuffer.  If the input is not a number, the user has to try again.  @samp{n} never uses the prefix argument.  Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un certain nombre, lu avec le mini-tampon. Si l&apos;entrée n&apos;est pas un nombre, l&apos;utilisateur doit essayer à nouveau. @ Samp {n} jamais utilise l&apos;argument de préfixe. Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! N</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>N</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The numeric prefix argument; but if there is no prefix argument, read a number as with @kbd{n}.  The value is always a number.  @xref{Prefix Command Arguments}.  Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument préfixe numérique, mais s&apos;il n&apos;y a pas d&apos;argument de préfixe, de lire un certain nombre comme @ kbd {n}. La valeur est toujours un nombre. @ Xref {Arguments préfixe de commande}. Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! p</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>p</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! numeric prefix argument usage</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>numérique utilisation de l&apos;argument de préfixe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The numeric prefix argument.  (Note that this @samp{p} is lower case.)  No I/O.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument préfixe numérique. (Notez que cette @ samp {p} est minuscule.) Pas d&apos;E / O.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! P</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>P</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! raw prefix argument usage</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>première utilisation de l&apos;argument préfixe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The raw prefix argument.  (Note that this @samp{P} is upper case.)  No I/O.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument préfixe brut. (Notez que cette @ samp {P} est une majuscule.) Pas d&apos;E / O.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! r</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>r</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! region argument</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>argument région</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Point and the mark, as two numeric arguments, smallest first.  This is the only code letter that specifies two successive arguments rather than one.  No I/O.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Point et la marque, deux arguments numériques, plus petite. C&apos;est la seule lettre de code qui spécifie deux arguments successifs plutôt qu&apos;un seul. Pas d&apos;E / O.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! s</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>s</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Arbitrary text, read in the minibuffer and returned as a string (@pxref{Text from Minibuffer}).  Terminate the input with either @kbd{C-j} or @key{RET}.  (@kbd{C-q} may be used to include either of these characters in the input.)  Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Texte arbitraire, de lire dans le mini-tampon et retourné comme une chaîne (@ pxref {texte de Minibuffer}). Mettre fin à l&apos;entrée soit avec @ kbd {Cj} ou @ key {RET}. (@ Kbd {Cq} peut être utilisée pour inclure l&apos;un de ces caractères dans l&apos;entrée.) Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! S</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>S</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! An interned symbol whose name is read in the minibuffer.  Any whitespace character terminates the input.  (Use @kbd{C-q} to include whitespace in the string.)  Other characters that normally terminate a symbol (e.g., parentheses and brackets) do not do so here.  Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un symbole internés dont le nom est lu dans le mini-tampon. Tout caractère blanc met fin à l&apos;entrée. (Utilisez @ kbd {Cq} pour inclure des espaces dans la chaîne.) Les autres caractères qui se terminent normalement un symbole (par exemple, les parenthèses et les crochets) ne le font pas ici. Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! U</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>U</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A key sequence or @code{nil}.  Can be used after a @samp{k} or @samp{K} argument to get the up-event that was discarded (if any)  after @samp{k} or @samp{K} read a down-event.  If no up-event has been discarded, @samp{U} provides @code{nil} as the argument.  No I/O.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une séquence de touches ou @ code {nil}. Peut être utilisé après un @ samp {k} ou @ samp {K} argument pour obtenir la mise à l&apos;événement qui a été rejeté (le cas échéant) après @ samp {k} ou @ samp {K} lire un bas-événement. Si aucune mise à l&apos;événement a été écartée, @ samp {U} fournit @ code {nil} comme argument. Pas d&apos;E / O.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! v</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>v</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A variable declared to be a user option (i.e., satisfying the predicate @code{user-variable-p}).  This reads the variable using @code{read-variable}.  @xref{Definition of read-variable}.  Existing, Completion, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une variable déclarée être un choix de l&apos;utilisateur (par exemple, satisfaire le prédicat @ code {user-variable p}). Ce lit la variable en utilisant @ code {lire la variable}. @ Xref {Définition de variable lu}. Existant, achèvement, Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! x</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>x</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A Lisp object, specified with its read syntax, terminated with a @kbd{C-j} or @key{RET}.  The object is not evaluated.  @xref{Object from Minibuffer}.  Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un objet Lisp, spécifié avec la syntaxe de lecture, terminé par un @ kbd {Cj} ou @ key {RET}. L&apos;objet n&apos;est pas évalué. @ Xref {objet de Minibuffer}. Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! X</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>X</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! evaluated expression argument</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>évalué argument expression</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A Lisp form&apos;s value.  @samp{X} reads as @samp{x} does, then evaluates the form so that its value becomes the argument for the command.  Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur d&apos;une forme Lisp. @ Samp {X} se lit comme @ samp {x} ne, puis évalue le formulaire afin que sa valeur devient l&apos;argument de la commande. Invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! z</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>z</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A coding system name (a symbol).  If the user enters null input, the argument value is @code{nil}.  @xref{Coding Systems}.  Completion, Existing, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un nom de système de codage (un symbole). Si l&apos;utilisateur saisit entrée nulle, la valeur de l&apos;argument est @ code {nil}. @ Xref {} systèmes de codage. Achèvement, existant, Prompt.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Z</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Z</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A coding system name (a symbol)---but only if this command has a prefix argument.  With no prefix argument, @samp{Z} provides @code{nil} as the argument value.  Completion, Existing, Prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un nom de système de codage (un symbole) --- mais seulement si cette commande a un argument de préfixe. Sans argument préfixe, @ samp {Z} fournit @ code {nil} comme la valeur d&apos;argument. Achèvement, existant, Prompt.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Examples of Using @code{interactive}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Exemples d&apos;utilisation de @ code {} interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! examples of using @code{interactive}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>exemples d&apos;utilisation de @ code {} interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{interactive}, examples of using</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ code {} interactives, des exemples d&apos;utilisation</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here are some examples of @code{interactive}:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici quelques exemples de code {@} interactive:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun foo1 ()              ; @r{@code{foo1} takes no arguments,}<ph x="1">&lt;x0/&gt;</ph>    (interactive)           ;   @r{just moves forward two words.}<ph x="2">&lt;x1/&gt;</ph>    (forward-word 2))<ph x="3">&lt;x2/&gt;</ph>     @result{} foo1<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun foo1 (); @ r {@ code {} foo1 prend pas d&apos;arguments,} <ph x="1">&lt;x0/&gt;</ph> (Interactive); @ r {déplace juste en avant deux mots.} <ph x="2">&lt;x1/&gt;</ph> (Forward-word 2)) <ph x="3">&lt;x2/&gt;</ph> @ Result {} foo1 <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun foo2 (n)             ; @r{@code{foo2} takes one argument,}<ph x="1">&lt;x0/&gt;</ph>    (interactive \&quot;p\&quot;)       ;   @r{which is the numeric prefix.}<ph x="2">&lt;x1/&gt;</ph>    (forward-word (* 2 n)))<ph x="3">&lt;x2/&gt;</ph>     @result{} foo2<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun foo2 (n); @ r {code} @ {foo2 prend un argument,} <ph x="1">&lt;x0/&gt;</ph> (Interactif \ &quot;p \&quot;); @ r {qui est le préfixe numérique.} <ph x="2">&lt;x1/&gt;</ph> (Forward-word (* 2 n))) <ph x="3">&lt;x2/&gt;</ph> @ Result {} foo2 <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun foo3 (n)             ; @r{@code{foo3} takes one argument,}<ph x="1">&lt;x0/&gt;</ph>    (interactive \&quot;nCount:\&quot;) ;   @r{which is read with the Minibuffer.}<ph x="2">&lt;x1/&gt;</ph>    (forward-word (* 2 n)))<ph x="3">&lt;x2/&gt;</ph>     @result{} foo3<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun foo3 (n); @ r {code} @ {foo3 prend un argument,} <ph x="1">&lt;x0/&gt;</ph> (\ Interactive &quot;nCount: \&quot;); @ r {. Qui est lu avec le Minibuffer} <ph x="2">&lt;x1/&gt;</ph> (Forward-word (* 2 n))) <ph x="3">&lt;x2/&gt;</ph> @ Result {} foo3 <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun three-b (b1 b2 b3)<ph x="1">&lt;x0/&gt;</ph>  \&quot;Select three existing buffers.<ph x="2">&lt;x1/&gt;</ph>Put them into three windows, selecting the last one.\&quot;<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun trois b (b1 b2 b3) <ph x="1">&lt;x0/&gt;</ph> \ &quot;Choisissez trois tampons existants. <ph x="2">&lt;x1/&gt;</ph> Mettez-les en trois fenêtres, choisissant la dernière. \ &quot; <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT!     (interactive \&quot;bBuffer1:\<ph x="1">&lt;x0/&gt;</ph>bBuffer2:\<ph x="2">&lt;x1/&gt;</ph>bBuffer3:\&quot;)<ph x="3">&lt;x2/&gt;</ph>    (delete-other-windows)<ph x="4">&lt;x3/&gt;</ph>    (split-window (selected-window) 8)<ph x="5">&lt;x4/&gt;</ph>    (switch-to-buffer b1)<ph x="6">&lt;x5/&gt;</ph>    (other-window 1)<ph x="7">&lt;x6/&gt;</ph>    (split-window (selected-window) 8)<ph x="8">&lt;x7/&gt;</ph>    (switch-to-buffer b2)<ph x="9">&lt;x8/&gt;</ph>    (other-window 1)<ph x="10">&lt;x9/&gt;</ph>    (switch-to-buffer b3))<ph x="11">&lt;x10/&gt;</ph>     @result{} three-b<ph x="12">&lt;x11/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(\ Interactive &quot;bBuffer1: \ <ph x="1">&lt;x0/&gt;</ph> bBuffer2: \ <ph x="2">&lt;x1/&gt;</ph> bBuffer3: \ &quot;) <ph x="3">&lt;x2/&gt;</ph> (Delete-autre-fenêtres) <ph x="4">&lt;x3/&gt;</ph> (Split-window (fenêtre sélectionnée) 8) <ph x="5">&lt;x4/&gt;</ph> (B1 switch-to-buffer) <ph x="6">&lt;x5/&gt;</ph> (Autre-fenêtre 1) <ph x="7">&lt;x6/&gt;</ph> (Split-window (fenêtre sélectionnée) 8) <ph x="8">&lt;x7/&gt;</ph> (B2 switch-to-buffer) <ph x="9">&lt;x8/&gt;</ph> (Autre-fenêtre 1) <ph x="10">&lt;x9/&gt;</ph> (B3 switch-to-buffer)) <ph x="11">&lt;x10/&gt;</ph> @ {} Résultat de trois b <ph x="12">&lt;x11/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (three-b \&quot;*scratch*\&quot; \&quot;declarations.texi\&quot; \&quot;*mail*\&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} nil<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Trois-b \ &quot;* scratch * \&quot; \ &quot;declarations.texi \&quot; \ &quot;* mail * \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ {} Résultat nul <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! interactive call</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>communication interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! After the command loop has translated a key sequence into a command it invokes that command using the function @code{command-execute}.  If the command is a function, @code{command-execute} calls @code{call-interactively}, which reads the arguments and calls the command.  You can also call these functions yourself.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Après la boucle de commande a traduit une séquence de touches dans un ordre, il invoque cette commande en utilisant la fonction @ code {commande} exécuter. Si la commande est une fonction, @ code {commande exécuter} appelle @ code {appeler interactive}, qui lit les arguments et appelle la commande. Vous pouvez également appeler ces fonctions vous-même.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! commandp object &amp;optional for-call-interactively</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>objet commandp et facultative pour appel interactive</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Returns @code{t} if @var{object} is suitable for calling interactively; that is, if @var{object} is a command.  Otherwise, returns @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retours @ code {t} si @ var {objet} est adapté pour appeler de manière interactive, c&apos;est, si @ var {objet} est une commande. Sinon, retourne @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The interactively callable objects include strings and vectors (treated as keyboard macros), lambda expressions that contain a top-level call to @code{interactive}, byte-code function objects made from such lambda expressions, autoload objects that are declared as interactive (non-@code{nil} fourth argument to @code{autoload}), and some of the primitive functions.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les objets interactivement remboursables comprennent des chaînes et des vecteurs (traités comme des macros de clavier), les expressions lambda qui contiennent un appel de haut niveau à @ code {interactive}, objets de fonction octets de code faits de ces expressions lambda, objets de chargement automatique qui sont déclarés comme interactive ( non @ code {nil} quatrième argument à @ code {} autoload), et quelques-unes des fonctions primitives.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A symbol satisfies @code{commandp} if its function definition satisfies @code{commandp}.  Keys and keymaps are not commands.  Rather, they are used to look up commands (@pxref{Keymaps}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un symbole satisfait @ code {} commandp si ses satisfait de définition de fonction @ code {} commandp. Touches et claviers ne sont pas les commandes. Au contraire, ils sont utilisés pour rechercher les commandes (@ pxref {} Keymaps).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{for-call-interactively} is non-@code{nil}, then @code{commandp} returns @code{t} only for objects that @code{call-interactively} could call---thus, not for keyboard macros.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {pour-appeler-interactive} est non @ code {nil}, puis sur @ code {} commandp retourne @ code {t} uniquement pour les objets que @ code {appeler interactive} pourrait appeler --- donc pas pour les macros de clavier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! See @code{documentation} in @ref{Accessing Documentation}, for a realistic example of using @code{commandp}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voir @ code {} documentation dans @ ref {} Accès à la documentation, un exemple réaliste d&apos;utiliser @ code {} commandp.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! call-interactively command &amp;optional record-flag keys</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>appeler interactive commander et touches record drapeau en option</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function calls the interactively callable function @var{command}, reading arguments according to its interactive calling specifications.  It returns whatever @var{command} returns.  An error is signaled if @var{command} is not a function or if it cannot be called interactively (i.e., is not a command).  Note that keyboard macros (strings and vectors) are not accepted, even though they are considered commands, because they are not functions.  If @var{command} is a symbol, then @code{call-interactively} uses its function definition.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction appelle la fonction interactive appelable @ var {commande}, la lecture des arguments selon ses spécifications d&apos;appel interactifs. Il renvoie ce qui a @ {commande} rendements var. Une erreur est signalée si @ var {commande} n&apos;est pas une fonction ou si elle ne peut pas être appelé de façon interactive (c&apos;est à dire, n&apos;est pas une commande). Notez que les macros de clavier (chaînes et des vecteurs) ne sont pas acceptées, même si elles sont considérées comme des commandes, car ils ne sont pas des fonctions. Si @ var {commande} est un symbole, alors @ code {appeler interactive} utilise sa définition de la fonction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! record command history</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>dossier historique des commandes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{record-flag} is non-@code{nil}, then this command and its arguments are unconditionally added to the list @code{command-history}.  Otherwise, the command is added only if it uses the minibuffer to read an argument.  @xref{Command History}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {enregistrement drapeau} est non @ code {nil}, cette commande et ses arguments sont sans condition ajoutés à la liste @ code {commande} histoire. Sinon, la commande est ajouté que si elle utilise le mini-tampon pour lire un argument. @ Xref {Historique des commandes}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The argument @var{keys}, if given, should be a vector which specifies the sequence of events to supply if the command inquires which events were used to invoke it.  If @var{keys} is omitted or @code{nil}, the default is the return value of @code{this-command-keys-vector}.  @xref{Definition of this-command-keys-vector}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument @ {var touches} est donné, doit être un vecteur qui spécifie la séquence des événements à fournir si les demandes de renseignements de commande dont les événements ont été utilisés pour l&apos;invoquent. Si @ var {touches} est omis ou @ code {nil}, la valeur par défaut est la valeur de retour de @ code {ce-commande-clés vecteur}. @ Xref {définition de ce commandant-clés vecteur}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! command-execute command &amp;optional record-flag keys special</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>commande et option touches record drapeau spéciaux commande exécuter</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! keyboard macro execution</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>clavier exécution de la macro</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function executes @var{command}.  The argument @var{command} must satisfy the @code{commandp} predicate; i.e., it must be an interactively callable function or a keyboard macro.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction exécute @ var {commande}. L&apos;argument @ var {commande} doit satisfaire le @ code {} commandp prédicat, c&apos;est à dire, il doit être une fonction interactive appelable ou une macro de clavier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A string or vector as @var{command} is executed with @code{execute-kbd-macro}.  A function is passed to @code{call-interactively}, along with the optional @var{record-flag} and @var{keys}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une chaîne ou un vecteur comme @ var {commande} est exécutée avec @ code {execute-kbd-macro}. Une fonction est passée à @ code {appeler interactive}, avec l&apos;option @ {var record drapeau} et {var @ touches}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A symbol is handled by using its function definition in its place.  A symbol with an @code{autoload} definition counts as a command if it was declared to stand for an interactively callable function.  Such a definition is handled by loading the specified library and then rechecking the definition of the symbol.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un symbole est traitée à l&apos;aide de la définition de la fonction à sa place. Un symbole avec un @ code {} autoload définition compte comme une commande si elle a été déclarée au repos pendant une fonction interactive appelable. Une telle définition est géré par le chargement de la bibliothèque spécifiée puis revérifier la définition du symbole.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The argument @var{special}, if given, means to ignore the prefix argument and not clear it.  This is used for executing special events (@pxref{Special Events}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument @ {var spécial} est donné, les moyens d&apos;ignorer l&apos;argument de préfixe et pas clair il. Il est utilisé pour l&apos;exécution d&apos;événements spéciaux (@ {pxref des événements spéciaux}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Command execute-extended-command prefix-argument</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Exécution de commande-extended-commande préfixe argument</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! read command name</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>lire le nom de la commande</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function reads a command name from the minibuffer using @code{completing-read} (@pxref{Completion}).  Then it uses @code{command-execute} to call the specified command.  Whatever that command returns becomes the value of @code{execute-extended-command}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction lit un nom de commande du mini-tampon en utilisant @ code {remplissant-lecture} (@ pxref {} achèvement). Puis il utilise @ code {commande} exécuter pour appeler la commande spécifiée. Quel que soit ce que les commandes de rentabilité devient la valeur de @ code {-commande exécuter étendu}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! execute with prefix argument</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>exécuter avec l&apos;argument de préfixe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the command asks for a prefix argument, it receives the value @var{prefix-argument}.  If @code{execute-extended-command} is called interactively, the current raw prefix argument is used for @var{prefix-argument}, and thus passed on to whatever command is run.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si la commande demande un argument préfixe, il reçoit la valeur @ var {prefix argument}. Si @ code {-commande exécuter étendu} est appelé de manière interactive, l&apos;argument courant de préfixe première est utilisée pour @ var {prefix argument}, et donc transmis à la commande ce qui est de fonctionner.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! M-x</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Mx</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{execute-extended-command} is the normal definition of @kbd{M-x}, so it uses the string @w{@samp{M-x }} as a prompt.  (It would be better to take the prompt from the events used to invoke @code{execute-extended-command}, but that is painful to implement.)  A description of the value of the prefix argument, if any, also becomes part of the prompt.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {exécuter-extended-command} est la définition normale de @ kbd {Mx}, il utilise la chaîne @ w {@ samp {Mx}} comme une invite. (Il serait préférable de prendre l&apos;invite des événements utilisés pour appeler @ code {-commande exécuter étendu}, mais qui est pénible à mettre en œuvre.) Une description de la valeur de l&apos;argument de préfixe, le cas échéant, devient également une partie de l&apos;invite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (execute-extended-command 3)<ph x="1">&lt;x0/&gt;</ph>---------- Buffer: Minibuffer ----------<ph x="2">&lt;x1/&gt;</ph>3 M-x forward-word RET<ph x="3">&lt;x2/&gt;</ph>---------- Buffer: Minibuffer ----------<ph x="4">&lt;x3/&gt;</ph>     @result{} t<ph x="5">&lt;x4/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(-Commande exécuter étendu 3) <ph x="1">&lt;x0/&gt;</ph> ---------- Tampon: Minibuffer ---------- <ph x="2">&lt;x1/&gt;</ph> 3 Mx forward-word RET <ph x="3">&lt;x2/&gt;</ph> ---------- Tampon: Minibuffer ---------- <ph x="4">&lt;x3/&gt;</ph> @ Result {} t <ph x="5">&lt;x4/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! interactive-p</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>interactive-p</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns @code{t} if the containing function (the one whose code includes the call to @code{interactive-p}) was called in direct response to user input.  This means that it was called with the function @code{call-interactively}, and that a keyboard macro is not running, and that Emacs is not running in batch mode.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne @ code {t} si la fonction contenant (celui dont le code comprend l&apos;appel à @ code {p} interactif) a été appelée en réponse directe à l&apos;entrée utilisateur. Cela signifie qu&apos;il a été appelé avec la fonction @ code {appeler interactive}, et qu&apos;une macro clavier ne fonctionne pas, et que Emacs n&apos;est pas en cours d&apos;exécution en mode batch.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the containing function was called by Lisp evaluation (or with @code{apply} or @code{funcall}), then it was not called interactively.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si la fonction contenant a été appelé par l&apos;évaluation Lisp (ou @ code {} s&apos;applique ou @ code {} funcall), il n&apos;a pas été appelé de façon interactive.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The most common use of @code{interactive-p} is for deciding whether to give the user additional visual feedback (such as by printing an informative message).  For example:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;utilisation la plus courante de @ code {p} interactif est pour décider de donner à l&apos;utilisateur une rétroaction visuelle supplémentaire (par exemple par l&apos;impression d&apos;un message d&apos;information). Par exemple:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ;; @r{Here&apos;s the usual way to use @code{interactive-p}.}<ph x="1">&lt;x0/&gt;</ph>(defun foo ()<ph x="2">&lt;x1/&gt;</ph>  (interactive)<ph x="3">&lt;x2/&gt;</ph>  (when (interactive-p)<ph x="4">&lt;x3/&gt;</ph>    (message \&quot;foo\&quot;)))<ph x="5">&lt;x4/&gt;</ph>     @result{} foo<ph x="6">&lt;x5/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>;; @ R {Voici la manière habituelle d&apos;utiliser @ code {p} interactif.} <ph x="1">&lt;x0/&gt;</ph> (Defun foo () <ph x="2">&lt;x1/&gt;</ph> (Interactif) <ph x="3">&lt;x2/&gt;</ph> (Quand (interactif-p) <ph x="4">&lt;x3/&gt;</ph> (Un message \ &quot;foo \&quot;))) <ph x="5">&lt;x4/&gt;</ph> @ Result {} foo <ph x="6">&lt;x5/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ;; @r{This function is just to illustrate the behavior.}<ph x="1">&lt;x0/&gt;</ph>(defun bar ()<ph x="2">&lt;x1/&gt;</ph>  (interactive)<ph x="3">&lt;x2/&gt;</ph>  (setq foobar (list (foo) (interactive-p))))<ph x="4">&lt;x3/&gt;</ph>     @result{} bar<ph x="5">&lt;x4/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>;; @ R {Cette fonction est juste pour illustrer le comportement.} <ph x="1">&lt;x0/&gt;</ph> (Barre de defun () <ph x="2">&lt;x1/&gt;</ph> (Interactif) <ph x="3">&lt;x2/&gt;</ph> (Setq foobar (liste (foo) (interactif-p)))) <ph x="4">&lt;x3/&gt;</ph> @ Result {} bar <ph x="5">&lt;x4/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ;; @r{Type @kbd{M-x foo}.}<ph x="1">&lt;x0/&gt;</ph>     @print{} foo<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>;; @ R {type @ kbd {Mx foo}.} <ph x="1">&lt;x0/&gt;</ph> @ Impression {} foo <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ;; @r{Type @kbd{M-x bar}.}<ph x="1">&lt;x0/&gt;</ph>;; @r{This does not display a message.}<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>;; @ R {. Type @ kbd {Mx bar}} <ph x="1">&lt;x0/&gt;</ph> ;; @ R {Ce n&apos;affiche pas un message.} <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! foobar<ph x="1">&lt;x0/&gt;</ph>     @result{} (nil t)<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>foobar <ph x="1">&lt;x0/&gt;</ph> @ Result {} (néant t) <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you want to test @emph{only} whether the function was called using @code{call-interactively}, add an optional argument @code{print-message} which should be non-@code{nil} in an interactive call, and use the @code{interactive} spec to make sure it is non-@code{nil}.  Here&apos;s an example:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous voulez tester @ emph {seulement} si la fonction a été appelée à l&apos;aide @ code {appeler interactive}, ajouter un argument optionnel @ code {print-message} qui devrait être non @ code {nil} dans une communication interactive, et utiliser le code de @ {} interactive spec pour s&apos;assurer qu&apos;il est non @ code {nil}. Voici un exemple:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun foo (&amp;optional print-message)<ph x="1">&lt;x0/&gt;</ph>  (interactive \&quot;p\&quot;)<ph x="2">&lt;x1/&gt;</ph>  (when print-message<ph x="3">&lt;x2/&gt;</ph>    (message \&quot;foo\&quot;)))<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun foo (&amp; option print-message) <ph x="1">&lt;x0/&gt;</ph> (Interactif \ &quot;p \&quot;) <ph x="2">&lt;x1/&gt;</ph> (Lors de l&apos;impression un message <ph x="3">&lt;x2/&gt;</ph> (Un message \ &quot;foo \&quot;))) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Defined in this way, the function does display the message when called from a keyboard macro.  We use @code{\&quot;p\&quot;} because the numeric prefix argument is never @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Définie de cette façon, la fonction fait afficher le message lorsqu&apos;il est appelé à partir d&apos;une macro de clavier. Nous utilisons @ code {\ &quot;p \&quot;} parce que l&apos;argument de préfixe numérique n&apos;est jamais @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! called-interactively-p</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>appelé interactive-p</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns @code{t} when the calling function was called using @code{call-interactively}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne @ code {t} lorsque la fonction d&apos;appel a été appelée à l&apos;aide @ code {appeler interactive}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When possible, instead of using this function, you should use the method in the example above; that method makes it possible for a caller to ``pretend&apos;&apos; that the function was called interactively.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque cela est possible, au lieu d&apos;utiliser cette fonction, vous devez utiliser la méthode dans l&apos;exemple ci-dessus, cette méthode permet à un appelant de prétendre ``&apos;&apos; que la fonction a été appelée de manière interactive.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Information from the Command Loop</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Informations du Commandement boucle</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The editor command loop sets several Lisp variables to keep status records for itself and for commands that are run.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La commande en boucle de l&apos;éditeur définit plusieurs variables Lisp de tenir des registres d&apos;état pour lui-même et pour les commandes qui sont exécutées.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! last-command</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>dernière commande</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable records the name of the previous command executed by the command loop (the one before the current command).  Normally the value is a symbol with a function definition, but this is not guaranteed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable enregistre le nom de la commande précédente exécuté par la boucle de commande (celui avant la commande en cours). Normalement, la valeur est un symbole avec une définition de fonction, mais ce n&apos;est pas garanti.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value is copied from @code{this-command} when a command returns to the command loop, except when the command has specified a prefix argument for the following command.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur est copiée de @ code {ce-commande} lorsqu&apos;une commande revient à la boucle de commande, sauf lorsque la commande a spécifié un argument préfixe pour la commande suivante.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable is always local to the current terminal and cannot be buffer-local.  @xref{Multiple Displays}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable est toujours locale à la prise de courant et ne peut pas être un tampon local. @ Xref {} affichages multiples.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! real-last-command</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>réel-dernière commande</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable is set up by Emacs just like @code{last-command}, but never altered by Lisp programs.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable est mis en place par Emacs comme @ code {dernière commande}, mais jamais altérée par les programmes Lisp.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! this-command</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>ce-commande</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! current command</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>commande en cours</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable records the name of the command now being executed by the editor command loop.  Like @code{last-command}, it is normally a symbol with a function definition.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable enregistre le nom de la commande en cours d&apos;exécution par la commande boucle de l&apos;éditeur. Comme @ code {dernière commande}, il est normalement un symbole avec une définition de fonction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The command loop sets this variable just before running a command, and copies its value into @code{last-command} when the command finishes (unless the command specified a prefix argument for the following command).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La boucle de commande définit cette variable juste avant d&apos;exécuter une commande, et des copies de sa valeur dans @ code {dernière commande} lorsque les finitions de commande (sauf si la commande a spécifié un argument préfixe pour la commande suivante).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! kill command repetition</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tuer répétition de commande</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Some commands set this variable during their execution, as a flag for whatever command runs next.  In particular, the functions for killing text set @code{this-command} to @code{kill-region} so that any kill commands immediately following will know to append the killed text to the previous kill.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Quelques commandes permettent de régler cette variable lors de leur exécution, comme un drapeau pour quelque commande s&apos;exécute prochaines. En particulier, les fonctions de tuer ensemble de texte @ code {} ce-commande à @ code {kill-région} de sorte que toute mise à mort commandes immédiatement après sauront ajouter du texte tué à la mise à mort précédente.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you do not want a particular command to be recognized as the previous command in the case where it got an error, you must code that command to prevent this.  One way is to set @code{this-command} to @code{t} at the beginning of the command, and set @code{this-command} back to its proper value at the end, like this:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous ne voulez pas une commande particulière d&apos;être reconnu comme la commande précédente dans le cas où il a obtenu une erreur, vous devez code qui commande pour empêcher cela. Une façon est de mettre @ code {} ce-commande à @ code {t} au début de la commande, et set @ code {} ce commandant à sa juste valeur à la fin, comme ceci:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun foo (args@dots{})<ph x="1">&lt;x0/&gt;</ph>  (interactive @dots{})<ph x="2">&lt;x1/&gt;</ph>  (let ((old-this-command this-command))<ph x="3">&lt;x2/&gt;</ph>    (setq this-command t)<ph x="4">&lt;x3/&gt;</ph>    @r{@dots{}do the work@dots{}}<ph x="5">&lt;x4/&gt;</ph>    (setq this-command old-this-command)))<ph x="6">&lt;x5/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun foo (args @ points {}) <ph x="1">&lt;x0/&gt;</ph> (@ Points interactifs {}) <ph x="2">&lt;x1/&gt;</ph> (Laisser ((vieux-ce-commande ce-commande)) <ph x="3">&lt;x2/&gt;</ph> (Setq cette commande-t) <ph x="4">&lt;x3/&gt;</ph> @ R @ {points {} faire le travail @ points {}} <ph x="5">&lt;x4/&gt;</ph> (Setq ce commandement ancien ce-commande))) <ph x="6">&lt;x5/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! We do not bind @code{this-command} with @code{let} because that would restore the old value in case of error---a feature of @code{let} which in this case does precisely what we want to avoid.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Nous ne lions pas les @ code {ce-commande} avec @ code {} laisser parce que ce serait de restaurer l&apos;ancienne valeur en cas d&apos;erreur --- une fonction de @ code {} laisser qui dans ce cas ne précisément ce que nous voulons éviter .</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! this-original-command</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>ce-originale-commande</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This has the same value as @code{this-command} except when command remapping occurs (@pxref{Remapping Commands}).  In that case, @code{this-command} gives the command actually run (the result of remapping), and @code{this-original-command} gives the command that was specified to run but remapped into another command.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cela a la même valeur que @ code {ce-commande} sauf lorsque la commande reconfiguration se produit (@ pxref {Commandes} remappage). Dans ce cas, @ code {} ce commandant donne l&apos;ordre réellement encourus (le résultat d&apos;un remappage), et @ code {ce-originale-commande} donne la commande qui a été spécifié pour fonctionner mais recartographiée dans une autre commande.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! this-command-keys</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>ce-commande-clés</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns a string or vector containing the key sequence that invoked the present command, plus any previous commands that generated the prefix argument for this command.  Any events read by the command using @code{read-event} without a timeout get tacked on to the end.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne une chaîne ou un vecteur contenant la séquence de touches qui a appelé la présente commande, plus les commandes précédentes qui ont généré l&apos;argument de préfixe pour cette commande. Tous les événements lus par la commande en utilisant @ code {lire événement} sans délai se cloué sur la fin.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! However, if the command has called @code{read-key-sequence}, it returns the last read key sequence.  @xref{Key Sequence Input}.  The value is a string if all events in the sequence were characters that fit in a string.  @xref{Input Events}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Toutefois, si la commande a appelé @ code {lecture séquence de touches}, elle retourne la dernière séquence de touches de lecture. @ Xref {d&apos;entrée de séquence de touches}. La valeur est une chaîne si tous les événements de la séquence étaient des personnages qui s&apos;inscrivent dans une chaîne. @ Xref {entrée} événements.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (this-command-keys)<ph x="1">&lt;x0/&gt;</ph>;; @r{Now use @kbd{C-u C-x C-e} to evaluate that.}<ph x="2">&lt;x1/&gt;</ph>     @result{} \&quot;^U^X^E\&quot;<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Ce-command-clés) <ph x="1">&lt;x0/&gt;</ph> ;; @ R {Maintenant, utilisez @ kbd {Cu Cx Ce} pour évaluer cela.} <ph x="2">&lt;x1/&gt;</ph> @ Result {} \ &quot;^ U ^ X ^ E \&quot; <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! this-command-keys-vector</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>ce-commande-clés vecteur</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Definition of this-command-keys-vector</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Définition de ce commandant-clés vecteur</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Like @code{this-command-keys}, except that it always returns the events in a vector, so you don&apos;t need to deal with the complexities of storing input events in a string (@pxref{Strings of Events}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comme @ code {ce-commande-clés}, sauf qu&apos;elle retourne toujours les événements dans un vecteur, de sorte que vous n&apos;avez pas besoin de composer avec les complexités de stocker les événements d&apos;entrée dans une chaîne (@ {pxref chaînes des événements}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! clear-this-command-keys &amp;optional keep-record</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>-cette-commande claire-clés et en option keep-dossier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function empties out the table of events for @code{this-command-keys} to return.  Unless @var{keep-record} is non-@code{nil}, it also empties the records that the function @code{recent-keys} (@pxref{Recording Input}) will subsequently return.  This is useful after reading a password, to prevent the password from echoing inadvertently as part of the next command in certain cases.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction se vide la table d&apos;événements pour @ code {ce-commande-clés} pour revenir. Sauf @ var {garder record} est non @ code {nil}, il se jette également les dossiers que la fonction @ code {dernières touches} (@ {pxref d&apos;entrée d&apos;enregistrement}) sera de retour suite. Ceci est utile, après avoir lu un mot de passe, pour éviter le mot de passe de l&apos;écho, par inadvertance, dans le cadre de la prochaine commande dans certains cas.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! last-nonmenu-event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>dernière nonmenu événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable holds the last input event read as part of a key sequence, not counting events resulting from mouse menus.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable contient le dernier événement d&apos;entrée lu dans le cadre d&apos;une séquence de touches, sans compter les événements résultant de menus de souris.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! One use of this variable is for telling @code{x-popup-menu} where to pop up a menu.  It is also used internally by @code{y-or-n-p} (@pxref{Yes-or-No Queries}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une utilisation de cette variable est de raconter @ code {-pop-up menu x} où pour faire apparaître un menu. Il est également utilisé en interne par @ code {y-ou-np} (@ pxref {Oui ou Non-requêtes}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! last-command-event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>dernière commande événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! last-command-char</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>dernière commande-char</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable is set to the last input event that was read by the command loop as part of a command.  The principal use of this variable is in @code{self-insert-command}, which uses it to decide which character to insert.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable est réglé sur le dernier événement d&apos;entrée qui a été lue par la boucle de commande en tant que partie d&apos;une commande. La principale utilisation de cette variable est @ code {auto-insert-command}, qui l&apos;utilise pour décider quel personnage à insérer.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! last-command-event<ph x="1">&lt;x0/&gt;</ph>;; @r{Now use @kbd{C-u C-x C-e} to evaluate that.}<ph x="2">&lt;x1/&gt;</ph>     @result{} 5<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>dernière commande événement <ph x="1">&lt;x0/&gt;</ph> ;; @ R {Maintenant, utilisez @ kbd {Cu Cx Ce} pour évaluer cela.} <ph x="2">&lt;x1/&gt;</ph> @ Result {} 5 <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The value is 5 because that is the @acronym{ASCII} code for @kbd{C-e}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur est 5 parce que c&apos;est l&apos;acronyme @ {ASCII} code @ kbd {} Ce.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The alias @code{last-command-char} exists for compatibility with Emacs version 18.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;alias @ code {dernière commande car} existe pour la compatibilité avec la version 18 d&apos;Emacs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! last-event-frame</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>dernier événement-cadre</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable records which frame the last input event was directed to.  Usually this is the frame that was selected when the event was generated, but if that frame has redirected input focus to another frame, the value is the frame to which the event was redirected.  @xref{Input Focus}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette enregistrements variables qui encadrent le dernier événement d&apos;entrée a été dirigé. Habituellement, c&apos;est le cadre qui a été sélectionné lors de l&apos;événement a été généré, mais si ce cadre a réorienté le focus d&apos;entrée à un autre cadre, la valeur est l&apos;image à laquelle l&apos;événement a été redirigé. @ Xref {Focus d&apos;entrée}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the last event came from a keyboard macro, the value is @code{macro}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si le dernier événement provient d&apos;une macro de clavier, la valeur est @ code {macro}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Adjusting Point After Commands</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Réglage de point après les commandes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! adjusting point</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>ajuster le point</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! invisible/intangible text, and point</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>texte invisible / intangible, et le point</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{display} property, and point display</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {display} la propriété, et le point d&apos;affichage</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{composition} property, and point display</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {} composition des biens et des points</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! It is not easy to display a value of point in the middle of a sequence of text that has the @code{display}, @code{composition} or @code{intangible} property, or is invisible.  Therefore, after a command finishes and returns to the command loop, if point is within such a sequence, the command loop normally moves point to the edge of the sequence.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il n&apos;est pas facile pour afficher une valeur de point au milieu d&apos;une séquence de texte qui a le code de @ {affichage}, @ code {} composition ou @ code {} immatériel propriété, ou est invisible. Par conséquent, après une fin de la commande et revient à la boucle de commande, si le point est dans une telle séquence, la boucle de commande se déplace normalement le point sur le bord de la séquence.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A command can inhibit this feature by setting the variable @code{disable-point-adjustment}:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une commande peut inhiber cette fonction en définissant la variable @ code {disable-point ajustement}:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! disable-point-adjustment</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>désactiver point de réglage</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If this variable is non-@code{nil} when a command returns to the command loop, then the command loop does not check for those text properties, and does not move point out of sequences that have them.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si cette variable est non @ code {nil} lorsqu&apos;une commande revient à la boucle de commande, puis la boucle de commande ne vérifie pas les propriétés du texte, et ne se déplace pas le point de séquences qui les ont.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The command loop sets this variable to @code{nil} before each command, so if a command sets it, the effect applies only to that command.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les ensembles de commande en boucle cette variable @ code {nil} avant chaque commande, de sorte que si une commande ensembles, l&apos;effet s&apos;applique uniquement à la commande.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! global-disable-point-adjustment</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>global-disable-point de réglage</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you set this variable to a non-@code{nil} value, the feature of moving point out of these sequences is completely turned off.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous définissez cette variable à un non-@ code {nil} valeur, la fonction de déplacer le point de ces séquences est complètement éteint.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! input events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>les événements d&apos;entrée</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The Emacs command loop reads a sequence of @dfn{input events} that represent keyboard or mouse activity.  The events for keyboard activity are characters or symbols; mouse events are always lists.  This section describes the representation and meaning of input events in detail.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La commande boucle Emacs lit une séquence de @ dfn {événements d&apos;entrée} qui représentent activité du clavier ou de la souris. Les événements de l&apos;activité du clavier sont des caractères ou des symboles; événements de souris sont toujours listes. Cette section décrit la représentation et la signification des événements d&apos;entrée dans le détail.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! eventp object</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>objet eventp</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns non-@code{nil} if @var{object} is an input event or event type.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne non @ code {nil} if @ var {objet} est un événement d&apos;entrée ou type d&apos;événement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Note that any symbol might be used as an event or an event type.  @code{eventp} cannot distinguish whether a symbol is intended by Lisp code to be used as an event.  Instead, it distinguishes whether the symbol has actually been used in an event that has been read as input in the current Emacs session.  If a symbol has not yet been so used, @code{eventp} returns @code{nil}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>A noter que tout symbole peut être utilisé comme un événement ou d&apos;un type d&apos;événement. @ Code {} eventp ne peut pas distinguer si un symbole est destiné par code Lisp pour être utilisé comme un événement. Au lieu de cela, il distingue si le symbole a été effectivement utilisée dans un événement qui a été lu comme entrée dans la session en cours Emacs. Si un symbole n&apos;a pas encore été employée, @ code {} eventp retourne @ code {nil}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Keyboard Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Événements de clavier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Ordinary characters--keys with symbols on them.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les caractères ordinaires - touches avec des symboles sur eux.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Function Keys</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Touches de fonction</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Function keys--keys with names, not symbols.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les touches de fonction - clés avec des noms, pas des symboles.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Mouse Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Événements de souris</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Overview of mouse events.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vue d&apos;ensemble des événements de la souris.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Click Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cliquez sur Événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Pushing and releasing a mouse button.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Appuyant et en relâchant le bouton de la souris.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Drag Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Faites glisser les événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Moving the mouse before releasing the button.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le déplacement de la souris avant de relâcher le bouton.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Button-Down Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Button-Bas Événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A button was pushed and not yet released.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un bouton a été poussé et pas encore diffusé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Repeat Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Répétez les événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Double and triple click (or drag, or down).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Double et triple clic (ou faire glisser, ou vers le bas).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Motion Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Mouvement Événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Just moving the mouse, not pushing a button.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tout en déplaçant la souris, pas appuyer sur un bouton.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Focus Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Concentrez événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Moving the mouse between frames.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Déplacer la souris entre les images.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Misc Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Evénements Divers</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Other events the system can generate.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>D&apos;autres événements du système peuvent générer.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Event Examples</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Exemples d&apos;événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Examples of the lists for mouse events.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Des exemples de listes pour les événements de souris.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Classifying Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Evénements classant</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Finding the modifier keys in an event symbol.  Event types.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Trouver les touches de modification dans un symbole de l&apos;événement. Les types d&apos;événements.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Accessing Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Evénements accès</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Functions to extract info from events.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Fonctions d&apos;extraire infos d&apos;événements.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Strings of Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Chaînes des événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Special considerations for putting</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Considérations particulières pour mettre</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! keyboard character events in a string.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événements de caractères du clavier dans une chaîne.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! keyboard events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événements de clavier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! There are two kinds of input you can get from the keyboard: ordinary keys, and function keys.  Ordinary keys correspond to characters; the events they generate are represented in Lisp as characters.  The event type of a character event is the character itself (an integer); see @ref{Classifying Events}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il existe deux types de contributions que vous pouvez obtenir à partir du clavier: les touches ordinaires, et les touches de fonction. Touches ordinaires correspondent à des personnages, les événements qu&apos;ils génèrent sont représentés en Lisp comme des caractères. Le type d&apos;un événement de caractère de l&apos;événement est le personnage lui-même (un entier); voir @ ref {} Classification des événements.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! modifier bits (of input character)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>les bits de modification (de caractère d&apos;entrée)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! basic code (of input character)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>code de base (de caractère d&apos;entrée)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! An input character event consists of a @dfn{basic code} between 0 and 524287, plus any or all of these @dfn{modifier bits}:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un événement de caractère d&apos;entrée se compose d&apos;une @ dfn {code} base comprise entre 0 et 524 287, ainsi que tout ou partie de ces @ dfn {bits de modification}:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! meta</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>méta</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @math<ph x="1">&lt;x0/&gt;</ph>}<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Mathématiques <ph x="1">&lt;x0/&gt;</ph> } <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! 2**27</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>2 ** 27</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bit in the character code indicates a character typed with the meta key held down.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>peu dans le code de caractère indique un caractère tapé avec la touche méta enfoncée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! control</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>contrôle</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @math<ph x="1">&lt;x0/&gt;</ph>}<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Mathématiques <ph x="1">&lt;x0/&gt;</ph> } <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! 2**26</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>2 ** 26</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bit in the character code indicates a non-@acronym{ASCII} control character.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>peu dans le code de caractère indique un non-@ acronyme {ASCII} caractère de contrôle.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @sc{ascii} control characters such as @kbd{C-a} have special basic codes of their own, so Emacs needs no special bit to indicate them.  Thus, the code for @kbd{C-a} is just 1.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ sc {caractères ascii} de contrôle tels que @ kbd {Ca} ont des codes de base spéciaux de leur propre chef, si Emacs doit pas peu spécial pour les indiquer. Ainsi, le code de @ kbd {Ca} est à seulement 1.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! But if you type a control combination not in @acronym{ASCII}, such as @kbd{%} with the control key, the numeric value you get is the code for @kbd{%} plus</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Mais si vous tapez une combinaison de commande pas à @ acronyme {ASCII}, comme @ kbd {%} avec la touche de commande, la valeur numérique que vous obtenez est le code de @ kbd {}%, plus</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (assuming the terminal supports non-@acronym{ASCII} control characters).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(En supposant que le terminal supporte non @ acronyme {ASCII} caractères de contrôle).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! shift</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>changement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @math<ph x="1">&lt;x0/&gt;</ph>}<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Mathématiques <ph x="1">&lt;x0/&gt;</ph> } <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! 2**25</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>2 ** 25</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bit in the character code indicates an @acronym{ASCII} control character typed with the shift key held down.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>peu dans le code de caractère indique un @ acronyme de caractères ASCII {} de commande tapé avec la touche shift enfoncée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For letters, the basic code itself indicates upper versus lower case; for digits and punctuation, the shift key selects an entirely different character with a different basic code.  In order to keep within the @acronym{ASCII} character set whenever possible, Emacs avoids using the</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour les lettres, le code de base lui-même indique majuscules contre inférieur; pour les chiffres et la ponctuation, la touche Maj sélectionne un caractère tout à fait différent avec un code de base différent. Afin de rester dans la @ {ASCII} acronyme de jeu de caractères à chaque fois que possible, Emacs évite d&apos;utiliser la</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bit for those characters.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>peu de ces personnages.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! However, @acronym{ASCII} provides no way to distinguish @kbd{C-A} from @kbd{C-a}, so Emacs uses the</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cependant, @ acronyme {ASCII} fournit aucun moyen de distinguer @ kbd {} CA de @ kbd {Ca}, si Emacs utilise le</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bit in @kbd{C-A} and not in @kbd{C-a}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>bit @ kbd {CA} et pas dans @ kbd {Ca}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! hyper</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>hyper</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @math<ph x="1">&lt;x0/&gt;</ph>}<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Mathématiques <ph x="1">&lt;x0/&gt;</ph> } <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! 2**24</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>2 ** 24</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bit in the character code indicates a character typed with the hyper key held down.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>peu dans le code de caractère indique un caractère tapé avec la touche hyper enfoncée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! super</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>superbe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @math<ph x="1">&lt;x0/&gt;</ph>}<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Mathématiques <ph x="1">&lt;x0/&gt;</ph> } <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! 2**23</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>2 ** 23</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bit in the character code indicates a character typed with the super key held down.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>peu dans le code de caractère indique un caractère tapé avec la touche de super enfoncée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! alt</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>alt</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @math<ph x="1">&lt;x0/&gt;</ph>}<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Mathématiques <ph x="1">&lt;x0/&gt;</ph> } <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! 2**22</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>2 ** 22</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bit in the character code indicates a character typed with the alt key held down.  (On some terminals, the key labeled @key{ALT} is actually the meta key.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>peu dans le code de caractère indique un caractère tapé avec la touche alt enfoncée. (Sur certains terminaux, la touche correspondant @ key {ALT} est en fait la clé méta.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! It is best to avoid mentioning specific bit numbers in your program.  To test the modifier bits of a character, use the function @code{event-modifiers} (@pxref{Classifying Events}).  When making key bindings, you can use the read syntax for characters with modifier bits (@samp{\\C-}, @samp{\\M-}, and so on).  For making key bindings with @code{define-key}, you can use lists such as @code{(control hyper ?x)} to specify the characters (@pxref{Changing Key Bindings}).  The function @code{event-convert-list} converts such a list into an event type (@pxref{Classifying Events}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il est préférable d&apos;éviter de mentionner les numéros de bits spécifiques dans votre programme. Pour tester les bits de modification d&apos;un caractère, utilisez la fonction @ code {événements modificateurs} (@ {pxref des événements Classification des}). Lors de raccourcis clavier, vous pouvez utiliser la syntaxe de lecture des caractères avec des morceaux de modification (@ samp {\ \ C-}, @ samp {\ \ M-}, et ainsi de suite). Pour faire des raccourcis clavier avec @ code {define-key}, vous pouvez utiliser des listes comme @ code {(contrôle hyper? X)} pour spécifier les caractères (@ pxref {Modification aux touches}). La fonction @ code {event-convert-list} convertit une telle liste dans un type d&apos;événement (@ de pxref {Evénements Classification des}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! function keys</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des touches de fonction</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Most keyboards also have @dfn{function keys}---keys that have names or symbols that are not characters.  Function keys are represented in Emacs Lisp as symbols; the symbol&apos;s name is the function key&apos;s label, in lower case.  For example, pressing a key labeled @key{F1} places the symbol @code{f1} in the input stream.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La plupart des claviers ont aussi @ dfn {touches de fonction} --- clés qui ont des noms ou des symboles qui ne sont pas des caractères. Les touches de fonction sont représentés dans Emacs Lisp comme des symboles, le nom de ce symbole est l&apos;étiquette de la touche de fonction, en minuscules. Par exemple, en appuyant sur une touche marquée @ key {F1} place le symbole @ code {f1} dans le flux d&apos;entrée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The event type of a function key event is the event symbol itself.  @xref{Classifying Events}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le type d&apos;un événement de touche de fonction de l&apos;événement est le symbole de l&apos;événement lui-même. @ Xref {} Classification des événements.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here are a few special cases in the symbol-naming convention for function keys:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici quelques cas particuliers de la convention de nommage symbole pour les touches de fonction:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{backspace}, @code{tab}, @code{newline}, @code{return}, @code{delete}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {} backspace, @ code {tab}, {@ code de saut de ligne}, @ code {return}, @ code {delete}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These keys correspond to common @acronym{ASCII} control characters that have special keys on most keyboards.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ces touches correspondent au bon @ acronyme {ASCII} caractères de contrôle qui ont des touches spéciales sur la plupart des claviers.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In @acronym{ASCII}, @kbd{C-i} and @key{TAB} are the same character.  If the terminal can distinguish between them, Emacs conveys the distinction to Lisp programs by representing the former as the integer 9, and the latter as the symbol @code{tab}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Dans @ acronyme {ASCII}, @ kbd {Ci} et @ key {TAB} sont le même caractère. Si le terminal ne peut les distinguer, Emacs transmet la distinction de programmes Lisp en représentant l&apos;ancien comme l&apos;entier 9, et celui-ci comme le symbole @ code {tab}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Most of the time, it&apos;s not useful to distinguish the two.  So normally @code{function-key-map} (@pxref{Translation Keymaps}) is set up to map @code{tab} into 9.  Thus, a key binding for character code 9 (the character @kbd{C-i}) also applies to @code{tab}.  Likewise for the other symbols in this group.  The function @code{read-char} likewise converts these events into characters.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La plupart du temps, il n&apos;est pas utile de distinguer les deux. Donc, normalement, @ code {function-key-carte} (@ pxref {Traduction Keymaps}) est mis en place pour la carte @ code {tab} en 9. Ainsi, une liaison pour le code de caractère 9 (le caractère @ kbd {Ci}) clé s&apos;applique également à @ code {tab}. De même pour les autres symboles de ce groupe. La fonction @ code {lecture car} convertit également ces événements en caractères.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In @acronym{ASCII}, @key{BS} is really @kbd{C-h}.  But @code{backspace} converts into the character code 127 (@key{DEL}), not into code 8 (@key{BS}).  This is what most users prefer.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Dans @ acronyme {ASCII}, @ key {BS} est vraiment @ kbd {Ch}. Mais @ code {} backspace convertit dans le code de caractère 127 (@ key {DEL}), pas en code 8 (@ key {BS}). C&apos;est ce que préfèrent la plupart des utilisateurs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{left}, @code{up}, @code{right}, @code{down}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {} gauche, @ code {up}, @ code {right}, @ code {down}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Cursor arrow keys</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Curseur touches fléchées</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{kp-add}, @code{kp-decimal}, @code{kp-divide}, @dots{}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {kp-add}, @ code {kp-décimal}, @ code {kp-fracture}, @ points {}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Keypad keys (to the right of the regular keyboard).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>touches du clavier (à la droite du clavier régulier).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{kp-0}, @code{kp-1}, @dots{}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {kp-0}, @ code {kp-1}, @ points {}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Keypad keys with digits.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les touches du clavier avec des chiffres.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{kp-f1}, @code{kp-f2}, @code{kp-f3}, @code{kp-f4}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {kp-f1}, @ code {kp-f2}, @ code {kp-f3}, @ code {kp-f4}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Keypad PF keys.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Touches du clavier PF.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{kp-home}, @code{kp-left}, @code{kp-up}, @code{kp-right}, @code{kp-down}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {kp-home}, @ code {kp-gauche}, @ code {kp-up}, @ code {kp droite}, @ code {kp-down}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Keypad arrow keys.  Emacs normally translates these into the corresponding non-keypad keys @code{home}, @code{left}, @dots{}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Clavier touches fléchées. Emacs se traduit normalement ces derniers dans les touches non-clavier correspondant @ code {} la maison, @ code {} gauche, @ points {}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{kp-prior}, @code{kp-next}, @code{kp-end}, @code{kp-begin}, @code{kp-insert}, @code{kp-delete}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {kp-avant}, @ code {kp prochaine}, @ code {kp-end}, @ code {kp-begin}, @ code {kp-insert}, @ code {kp-delete}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Additional keypad duplicates of keys ordinarily found elsewhere.  Emacs normally translates these into the like-named non-keypad keys.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Doublons de clavier supplémentaires de touches habituellement trouvés ailleurs. Emacs se traduit normalement ces derniers dans les touches non-clavier de même nom.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You can use the modifier keys @key{ALT}, @key{CTRL}, @key{HYPER}, @key{META}, @key{SHIFT}, and @key{SUPER} with function keys.  The way to represent them is with prefixes in the symbol name:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous pouvez utiliser les touches de modification @ key {ALT}, @ key {CTRL}, @ key {HYPER}, @ key {META}, @ key {MAJ} et @ key {} SUPER avec les touches de fonction. La façon de les représenter est avec des préfixes dans le nom du symbole:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A-</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>A-</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The alt modifier.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le modificateur alt.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! C-</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C-</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The control modifier.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le modificateur de commande.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! H-</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>H-</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The hyper modifier.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le modificateur hyper.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! M-</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>M-</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The meta modifier.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La méta modificateur.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! S-</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>S-</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The shift modifier.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le modificateur de changement de vitesse.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! s-</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>s-</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The super modifier.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le modificateur superbe.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Thus, the symbol for the key @key{F3} with @key{META} held down is @code{M-f3}.  When you use more than one prefix, we recommend you write them in alphabetical order; but the order does not matter in arguments to the key-binding lookup and modification functions.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ainsi, le symbole de la touche @ key {F3} avec @ key {META} enfoncée est @ code {M-f3}. Lorsque vous utilisez plus d&apos;un préfixe, nous vous recommandons de les écrire dans l&apos;ordre alphabétique, mais l&apos;ordre n&apos;a pas d&apos;importance dans les arguments pour les fonctions clés de liaison correspondances et de modification.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs supports four kinds of mouse events: click events, drag events, button-down events, and motion events.  All mouse events are represented as lists.  The @sc{car} of the list is the event type; this says which mouse button was involved, and which modifier keys were used with it.  The event type can also distinguish double or triple button presses (@pxref{Repeat Events}).  The rest of the list elements give position and time information.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs prend en charge quatre types d&apos;événements de la souris: cliquez sur les événements, les événements de déplacement, les événements bouton en bas, et les événements de mouvement. Tous les événements de souris sont représentées sous forme de listes. Le @ sc {} voiture de la liste est le type d&apos;événement, ce qui explique bouton de la souris a été impliqué, et touches de modification ont été utilisés avec elle. Le type d&apos;événement peut également distinguer pressions de boutons doubles ou triples (@ pxref {}) Répéter les événements. Le reste des éléments de la liste donne la position et l&apos;heure.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For key lookup, only the event type matters: two events of the same type necessarily run the same command.  The command can access the full values of these events using the @samp{e} interactive code.  @xref{Interactive Codes}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour la recherche de clés, seuls les sujets de type d&apos;événement: deux événements du même type vont nécessairement la même commande. La commande peut accéder à l&apos;ensemble des valeurs de ces événements en utilisant le @ samp {e} interactive du code. @ Xref {} codes interactifs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A key sequence that starts with a mouse event is read using the keymaps of the buffer in the window that the mouse was in, not the current buffer.  This does not imply that clicking in a window selects that window or its buffer---that is entirely under the control of the command binding of the key sequence.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une séquence de touches qui commence par un événement de souris est lue en utilisant les plans de codage de la mémoire tampon dans la fenêtre qui était dans la souris, ne le tampon courant. Cela ne signifie pas qu&apos;en cliquant dans une fenêtre sélectionne cette fenêtre ou son tampon --- qui est entièrement sous le contrôle de la liaison de la séquence de touches de commande.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! click event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>cliquez sur l&apos;événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! mouse click event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>clic de souris événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When the user presses a mouse button and releases it at the same location, that generates a @dfn{click} event.  All mouse click event share the same format:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque l&apos;utilisateur appuie sur un bouton et le libère au même endroit souris, qui génère une @ dfn {} cliquez sur l&apos;événement. Tout clic de souris cas partagent le même format:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (@var{event-type} @var{position} @var{click-count})<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(@ Var {type d&apos;événement} @ var {position} @ {var cliquez-count}) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! event-type</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>type d&apos;événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is a symbol that indicates which mouse button was used.  It is one of the symbols @code{mouse-1}, @code{mouse-2}, @dots{}, where the buttons are numbered left to right.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il s&apos;agit d&apos;un symbole qui indique le bouton de la souris a été utilisé. Il est l&apos;un des symboles @ code {1}-souris, @ code {2}-souris, @ points {}, où les touches sont numérotées de gauche à droite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! You can also use prefixes @samp{A-}, @samp{C-}, @samp{H-}, @samp{M-}, @samp{S-} and @samp{s-} for modifiers alt, control, hyper, meta, shift and super, just as you would with function keys.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Vous pouvez aussi utiliser les préfixes @ samp {A-}, @ samp {C}-, @ samp {H-}, @ samp {M-}, @ samp {S-} et @ samp {s-} modificateurs alt pour, contrôle, hyper, méta, décalage et super, tout comme vous le feriez avec des touches de fonction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This symbol also serves as the event type of the event.  Key bindings describe events by their types; thus, if there is a key binding for @code{mouse-1}, that binding would apply to all events whose @var{event-type} is @code{mouse-1}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce symbole est aussi le type de l&apos;événement de l&apos;événement. Raccourcis clavier décrivent des événements par leurs types, donc, si il ya une liaison pour @ code {1} souris touche, que la liaison s&apos;appliquerait à tous les événements dont var @ {event-type} est @ code {souris 1}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>position</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the position where the mouse click occurred.  The actual format of @var{position} depends on what part of a window was clicked on.  The various formats are described below.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est l&apos;endroit où le clic a eu lieu. Le format actuel de @ var {position} dépend de quelle partie d&apos;une fenêtre a été cliqué. Les divers formats sont décrits ci-dessous.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! click-count</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>cliquez-compte</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the number of rapid repeated presses so far of the same mouse button.  @xref{Repeat Events}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ceci est le nombre de pressions successives rapides de la mesure de la même bouton de la souris. @ Xref {} Répéter événements.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For mouse click events in the text area, mode line, header line, or in the marginal areas, @var{position} has this form:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Clic de souris pour les événements dans la zone de texte, ligne de mode, ligne d&apos;en-tête, ou dans les zones marginales, @ var {position} a cette forme:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (@var{window} @var{pos-or-area} (@var{x} . @var{y}) @var{timestamp}<ph x="1">&lt;x0/&gt;</ph> @var{object} @var{text-pos} (@var{col} . @var{row})<ph x="2">&lt;x1/&gt;</ph> @var{image} (@var{dx} . @var{dy}) (@var{width} . @var{height}))<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(@ Var {fenêtre} @ {var pos-ou-zone} (@ var {x}. @ Var {y}) @ {var horodatage} <ph x="1">&lt;x0/&gt;</ph> @ Var {objet} @ var {text-pos} (@ var {col}. @ Var {ligne}) <ph x="2">&lt;x1/&gt;</ph> @ Var {image} (@ var {dx}. @ Var {dy}) (@ var {width}. @ Var {hauteur})) <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! window</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>fenêtre</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the window in which the click occurred.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est la fenêtre dans laquelle le clic a eu lieu.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! pos-or-area</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>pos-ou-zone</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the buffer position of the character clicked on in the text area, or if clicked outside the text area, it is the window area in which the click occurred.  It is one of the symbols @code{mode-line}, @code{header-line}, @code{vertical-line}, @code{left-margin}, @code{right-margin}, @code{left-fringe}, or @code{right-fringe}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ceci est la position de la mémoire tampon du caractère cliqué sur dans la zone de texte, ou s&apos;il est cliqué en dehors de la zone de texte, c&apos;est la zone de la fenêtre dans laquelle le clic a eu lieu. Il est l&apos;un des symboles @ code {mode ligne}, @ code {header-line}, @ code {vertical-ligne}, @ code {gauche marge}, @ code {droit marge}, @ code {gauche franges} ou @ code {} frange droite.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @var{x}, @var{y}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Var {x}, @ var {y}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These are the pixel-denominated coordinates of the click, relative to the top left corner of @var{window}, which is @code{(0 . 0)}.  For the mode or header line, @var{y} does not have meaningful data.  For the vertical line, @var{x} does not have meaningful data.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce sont les coordonnées de pixels libellés du clic, par rapport au coin supérieur gauche de la fenêtre @ var {}, qui est @ code {(0. 0)}. Pour le mode ou la ligne d&apos;en-tête, @ var {y} ne dispose pas de données significatives. Pour la ligne verticale, @ var {x} ne pas disposer de données significatives.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! timestamp</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>horodatage</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the time at which the event occurred, in milliseconds.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ceci est l&apos;heure à laquelle l&apos;événement s&apos;est produit, en millisecondes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! object</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>objet</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the object on which the click occurred.  It is either @code{nil} if there is no string property, or it has the form (@var{string} . @var{string-pos}) when there is a string-type text property at the click position.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est l&apos;objet sur lequel le clic a eu lieu. Il est soit @ code {nil} s&apos;il n&apos;y a pas propriété de la chaîne, ou il a la forme (@ var {string}. @ Var {string-pos}) quand il s&apos;agit d&apos;une propriété de texte de type chaîne à la position du clic.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! string</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>chaîne</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the string on which the click occurred, including any properties.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il s&apos;agit de la chaîne sur laquelle le clic a eu lieu, y compris les propriétés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! string-pos</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>chaîne pôles</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the position in the string on which the click occurred, relevant if properties at the click need to be looked up.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est la position de la chaîne sur laquelle le clic a eu lieu, si pertinent propriétés au clic doivent être regardé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! text-pos</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>texte pôles</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For clicks on a marginal area or on a fringe, this is the buffer position of the first visible character in the corresponding line in the window.  For other events, it is the current buffer position in the window.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour clique sur une zone marginale ou sur une frange, c&apos;est la position de la mémoire tampon du premier caractère visible dans la ligne correspondante dans la fenêtre. Pour les autres cas, c&apos;est la position de tampon courante dans la fenêtre.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @var{col}, @var{row}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Var {col}, @ var {ligne}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These are the actual coordinates of the glyph under the @var{x}, @var{y} position, possibly padded with default character width glyphs if @var{x} is beyond the last glyph on the line.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce sont les coordonnées réelles du glyphe dans le cadre du @ var {x}, la position @ var {y}, peut-être rembourré avec des glyphes de largeur de caractères par défaut si @ var {x} est au-delà du dernier glyphe sur la ligne.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! image</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>image</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the image object on which the click occurred.  It is either @code{nil} if there is no image at the position clicked on, or it is an image object as returned by @code{find-image} if click was in an image.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est l&apos;objet de l&apos;image sur laquelle le clic a eu lieu. Il s&apos;agit soit d&apos;@ code {nil} si aucune image à la position cliqué sur, ou il est un objet d&apos;image renvoyée par @ code {trouver l&apos;image} si clic était dans une image.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @var{dx}, @var{dy}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Var {dx}, @ var {dy}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These are the pixel-denominated coordinates of the click, relative to the top left corner of @var{object}, which is @code{(0 . 0)}.  If @var{object} is @code{nil}, the coordinates are relative to the top left corner of the character glyph clicked on.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce sont les coordonnées de pixels libellés du clic, par rapport au coin supérieur gauche de @ var {objet}, qui est @ code {(0. 0)}. Si @ var {objet} est @ code {nil}, les coordonnées sont relatives au coin supérieur gauche de la glyphe de caractère cliqué.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For mouse clicks on a scroll-bar, @var{position} has this form:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour clics de souris sur une barre de défilement, @ var {position} a cette forme:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (@var{window} @var{area} (@var{portion} . @var{whole}) @var{timestamp} @var{part})<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(@ Var {fenêtre} @ {var zone} (@ var {} partie. @ {Var tout}) @ {var timestamp} @ {var} partie) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the window whose scroll-bar was clicked on.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il s&apos;agit de la fenêtre dont la barre de défilement a été cliqué.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! area</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>région</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the scroll bar where the click occurred.  It is one of the symbols @code{vertical-scroll-bar} or @code{horizontal-scroll-bar}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il s&apos;agit de la barre de défilement où le clic a eu lieu. Il est l&apos;un des symboles @ code {-barre de défilement vertical} ou {@ code-barre de défilement horizontale}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! portion</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>partie</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the distance of the click from the top or left end of the scroll bar.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est la distance du clic de l&apos;extrémité supérieure ou à gauche de la barre de défilement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! whole</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>tout</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the length of the entire scroll bar.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Il s&apos;agit de la longueur de la barre de défilement entier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! part</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>partie</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is the part of the scroll-bar which was clicked on.  It is one of the symbols @code{above-handle}, @code{handle}, @code{below-handle}, @code{up}, @code{down}, @code{top}, @code{bottom}, and @code{end-scroll}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est la partie de la barre de défilement qui a été cliqué. Il est l&apos;un des symboles @ code {ci-dessus poignée}, @ code {poignée}, @ code {ci-dessous poignée}, @ code {up}, @ code {bas}, @ code {top}, @ code {fond } et @ code {fin} défilement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In one special case, @var{buffer-pos} is a list containing a symbol (one of the symbols listed above) instead of just the symbol.  This happens after the imaginary prefix keys for the event are inserted into the input stream.  @xref{Key Sequence Input}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Dans un cas particulier, @ var {tampon-pos} est une liste contenant un symbole (un des symboles listés ci-dessus) au lieu de simplement le symbole. Ceci se produit après que les touches de préfixe imaginaires pour l&apos;événement sont insérées dans le flux d&apos;entrée. @ Xref {d&apos;entrée de séquence de touches}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! drag event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événement de glissement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! mouse drag event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événement de glisser la souris</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! With Emacs, you can have a drag event without even changing your clothes.  A @dfn{drag event} happens every time the user presses a mouse button and then moves the mouse to a different character position before releasing the button.  Like all mouse events, drag events are represented in Lisp as lists.  The lists record both the starting mouse position and the final position, like this:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Avec Emacs, vous pouvez avoir un événement de glisser sans même changer vos vêtements. A @ dfn {de} événement de glissement se produit chaque fois que l&apos;utilisateur appuie sur un bouton de la souris, puis déplace la souris à une position de caractère différent avant de relâcher le bouton. Comme tous les événements de la souris, faites glisser les événements sont représentés en Lisp sous forme de listes. Les listes d&apos;enregistrer à la fois la position de la souris de départ et la position finale, comme ceci:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (@var{event-type}<ph x="1">&lt;x0/&gt;</ph> (@var{window1} @var{buffer-pos1} (@var{x1} . @var{y1}) @var{timestamp1})<ph x="2">&lt;x1/&gt;</ph> (@var{window2} @var{buffer-pos2} (@var{x2} . @var{y2}) @var{timestamp2})<ph x="3">&lt;x2/&gt;</ph> @var{click-count})<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(@ Var {type d&apos;événement} <ph x="1">&lt;x0/&gt;</ph> (@ Var {fenêtre1} @ {var tampon-pos1} (@ var {x1}. @ Var {y1}) @ {var timestamp1}) <ph x="2">&lt;x1/&gt;</ph> (@ Var {window2} @ {var tampon-pos2} (@ var {x2}. @ Var {y2}) @ {var estampille2}) <ph x="3">&lt;x2/&gt;</ph> @ Var {cliquez-count}) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For a drag event, the name of the symbol @var{event-type} contains the prefix @samp{drag-}.  For example, dragging the mouse with button 2 held down generates a @code{drag-mouse-2} event.  The second and third elements of the event give the starting and ending position of the drag.  Aside from that, the data have the same meanings as in a click event (@pxref{Click Events}).  You can access the second element of any mouse event in the same way, with no need to distinguish drag events from others.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour un événement de glissement, le nom du symbole @ var {-type d&apos;événement} contient le préfixe @ samp {} glisser. Par exemple, en faisant glisser la souris avec le bouton 2 enfoncé génère un @ code {glisser la souris 2} événement. Les deuxième et troisième éléments de l&apos;événement donnent la position de départ et de fin de la traînée. Mis à part cela, les données ont les mêmes significations que dans un événement click (@ pxref {Cliquez événements}). Vous pouvez accéder au deuxième élément de tout événement de la souris de la même manière, sans avoir besoin de distinguer les événements de glisser des autres.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The @samp{drag-} prefix follows the modifier key prefixes such as @samp{C-} and @samp{M-}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le @ samp {} glisser-préfixe suit les préfixes de touches de modification telles que @ samp {C-} et @ samp {M-}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @code{read-key-sequence} receives a drag event that has no key binding, and the corresponding click event does have a binding, it changes the drag event into a click event at the drag&apos;s starting position.  This means that you don&apos;t have to distinguish between click and drag events unless you want to.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ code {lecture séquence de touches} reçoit un événement de glissement qui n&apos;a pas de liaison clé, et l&apos;événement de clic correspondant a une liaison, il change l&apos;événement de glisser dans un événement de clic à la position de départ de la traînée. Cela signifie que vous n&apos;avez pas à faire la distinction entre un clic et événements de déplacement sauf si vous voulez.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! button-down event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événement button-down</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Click and drag events happen when the user releases a mouse button.  They cannot happen earlier, because there is no way to distinguish a click from a drag until the button is released.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cliquez et faites glisser les événements se produisent lorsque l&apos;utilisateur relâche un bouton de la souris. Ils ne peuvent pas se produire plus tôt, parce qu&apos;il n&apos;y a aucun moyen de distinguer un clic à partir d&apos;un glisser jusqu&apos;à ce que le bouton est relâché.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you want to take action as soon as a button is pressed, you need to handle @dfn{button-down} events.@footnote{Button-down is the conservative antithesis of drag.} These occur as soon as a button is pressed.  They are represented by lists that look exactly like click events (@pxref{Click Events}), except that the @var{event-type} symbol name contains the prefix @samp{down-}.  The @samp{down-} prefix follows modifier key prefixes such as @samp{C-} and @samp{M-}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous voulez prendre des mesures dès qu&apos;une touche est pressée, vous devez gérer @ dfn {button-down} événements. @ Footnote {button-down est l&apos;antithèse conservatrice de glisser.} Ils se produisent dès qu&apos;un bouton est pressé . Ils sont représentés par des listes qui ressemblent exactement comme les événements de clic (@ pxref {} Cliquez événements), sauf que le @ {var-type d&apos;événement} nom de symbole contient le préfixe @ samp {vers le bas}. Le @ samp {vers le bas} préfixe suit modificateurs préfixes clés tels que @ samp {C-} et @ samp {M-}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{read-key-sequence} ignores any button-down events that don&apos;t have command bindings; therefore, the Emacs command loop ignores them too.  This means that you need not worry about defining button-down events unless you want them to do something.  The usual reason to define a button-down event is so that you can track mouse motion (by reading motion events) until the button is released.  @xref{Motion Events}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code de la fonction @ {lecture séquence de touches} ignore les événements bouton en bas qui n&apos;ont pas liaisons de commande, par conséquent, la commande boucle Emacs les ignore trop. Cela signifie que vous ne devez pas vous soucier de la définition des événements bouton en bas, sauf si vous voulez faire quelque chose. La raison habituelle pour définir un événement de bouton vers le bas est de sorte que vous pouvez suivre le mouvement de la souris (par la lecture des événements de mouvement) jusqu&apos;à ce que le bouton est relâché. @ Xref {mouvement Evénements}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! repeat events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>des événements récurrents</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! double-click events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>double-cliquez sur événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! triple-click events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>triple-clic événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! mouse events, repeated</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événements souris, répétée</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you press the same mouse button more than once in quick succession without moving the mouse, Emacs generates special @dfn{repeat} mouse events for the second and subsequent presses.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous appuyez sur le bouton de la souris même plus d&apos;une fois en succession rapide sans déplacer la souris, Emacs génère spéciale @ dfn {} répétition des événements de souris pour les deuxième et ultérieures presses.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The most common repeat events are @dfn{double-click} events.  Emacs generates a double-click event when you click a button twice; the event happens when you release the button (as is normal for all click events).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les événements de répétition les plus courants sont @ dfn {double-clic} événements. Emacs génère un événement double-clic lorsque vous cliquez deux fois sur un bouton, l&apos;événement se produit lorsque vous relâchez le bouton (ce qui est normal pour tous les événements de clic).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The event type of a double-click event contains the prefix @samp{double-}.  Thus, a double click on the second mouse button with @key{meta} held down comes to the Lisp program as @code{M-double-mouse-2}.  If a double-click event has no binding, the binding of the corresponding ordinary click event is used to execute it.  Thus, you need not pay attention to the double click feature unless you really want to.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le type d&apos;un événement double-clic événement contient le préfixe @ samp {double}. Ainsi, un double-clic sur le deuxième bouton de la souris avec @ key {méta} enfoncée vient le programme Lisp comme @ code {M-double-souris 2}. Si un événement double-clic n&apos;a pas de liaison, la liaison de l&apos;événement click ordinaire correspondant est utilisé pour l&apos;exécuter. Ainsi, vous ne devez pas payer attention à la double fonction de clic, sauf si vous voulez vraiment.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When the user performs a double click, Emacs generates first an ordinary click event, and then a double-click event.  Therefore, you must design the command binding of the double click event to assume that the single-click command has already run.  It must produce the desired results of a double click, starting from the results of a single click.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque l&apos;utilisateur effectue un double clic, Emacs génère d&apos;abord un clic événement ordinaire, puis un événement double-clic. Par conséquent, vous devez concevoir la commande de liaison de la double-clic cas de supposer que la commande simple clic a déjà exécuté. Il doit produire les résultats escomptés d&apos;un double-clic, à partir des résultats d&apos;un seul clic.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is convenient, if the meaning of a double click somehow ``builds on&apos;&apos; the meaning of a single click---which is recommended user interface design practice for double clicks.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est pratique, si le sens d&apos;un double clic en quelque sorte `` s&apos;appuie sur&apos;&apos; le sens d&apos;un simple clic --- ce qui est recommandé pratique de conception d&apos;interface utilisateur pour les doubles-clics.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you click a button, then press it down again and start moving the mouse with the button held down, then you get a @dfn{double-drag} event when you ultimately release the button.  Its event type contains @samp{double-drag} instead of just @samp{drag}.  If a double-drag event has no binding, Emacs looks for an alternate binding as if the event were an ordinary drag.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous cliquez sur un bouton, puis appuyez à nouveau et commencer à bouger la souris avec le bouton enfoncé, puis vous obtenez une @ dfn {double-glisser} événement lorsque vous relâchez le bouton en fin de compte. Son type d&apos;événement contient @ samp {double-glisser} au lieu de simplement @ samp {} glisser. Si un événement de double-traînée n&apos;a pas de liaison, Emacs attend pour une autre liaison que si l&apos;événement était une traînée ordinaire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Before the double-click or double-drag event, Emacs generates a @dfn{double-down} event when the user presses the button down for the second time.  Its event type contains @samp{double-down} instead of just @samp{down}.  If a double-down event has no binding, Emacs looks for an alternate binding as if the event were an ordinary button-down event.  If it finds no binding that way either, the double-down event is ignored.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Avant le double-clic ou double-glisser cas, Emacs génère une @ dfn {double-down} événement lorsque l&apos;utilisateur appuie sur le bouton vers le bas pour la deuxième fois. Son type d&apos;événement contient @ samp {double-down} au lieu de simplement @ samp {down}. Si un événement de double-bas n&apos;a pas de liaison, Emacs attend pour une liaison autre comme si l&apos;événement était un événement ordinaire button-down. S&apos;il ne trouve pas de liaison de cette façon soit, l&apos;événement double-bas est ignoré.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To summarize, when you click a button and then press it again right away, Emacs generates a down event and a click event for the first click, a double-down event when you press the button again, and finally either a double-click or a double-drag event.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour résumer, lorsque vous cliquez sur un bouton, puis appuyez de nouveau tout de suite, Emacs génère un événement vers le bas et un événement de clic pour le premier clic, un double événement-bas quand vous appuyez de nouveau sur le bouton, et enfin d&apos;une double-cliquez ou un événement double-glisser.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you click a button twice and then press it again, all in quick succession, Emacs generates a @dfn{triple-down} event, followed by either a @dfn{triple-click} or a @dfn{triple-drag}.  The event types of these events contain @samp{triple} instead of @samp{double}.  If any triple event has no binding, Emacs uses the binding that it would use for the corresponding double event.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous cliquez sur un bouton deux fois, puis appuyez de nouveau, tout en succession rapide, Emacs génère une @ dfn {triple-down} événement, suivi par soit un @ dfn {triple-clic} ou un @ dfn {triple-glisser}. Les types de ces événements d&apos;événements contiennent @ samp {} au lieu de triple @ samp {} doubles. Si un événement triple a pas de liaison, Emacs utilise la liaison qu&apos;il utiliserait pour le double événement correspondant.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If you click a button three or more times and then press it again, the events for the presses beyond the third are all triple events.  Emacs does not have separate event types for quadruple, quintuple, etc.@: events.  However, you can look at the event list to find out precisely how many times the button was pressed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si vous cliquez sur un bouton trois fois ou plus, puis appuyez à nouveau, les événements pour les presses au-delà de la troisième sont tous des événements triples. Emacs n&apos;a pas les types d&apos;événements distincts pour quadruple, quintuple, etc @: les événements. Cependant, vous pouvez consulter la liste des événements pour savoir précisément combien de bouton a été pressé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! event-click-count event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événement événement cliquez-compte</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the number of consecutive button presses that led up to @var{event}.  If @var{event} is a double-down, double-click or double-drag event, the value is 2.  If @var{event} is a triple event, the value is 3 or greater.  If @var{event} is an ordinary mouse event (not a repeat event), the value is 1.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le nombre de clics consécutifs qui ont conduit à @ var {even}. Si @ var {even} est un double-down, double-cliquez ou double événement-glisser, la valeur est 2. Si @ var {} événement est un événement triple, la valeur est de 3 ou plus. Si @ var {} événement est un événement de la souris ordinaire (pas un événement de répétition), la valeur est 1.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To generate repeat events, successive mouse button presses must be at approximately the same screen position.  The value of @code{double-click-fuzz} specifies the maximum number of pixels the mouse may be moved (horizontally or vertically) between two successive clicks to make a double-click.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour générer des événements récurrents, successives appuie sur un bouton de la souris doit être à peu près la même position de l&apos;écran. La valeur de @ code {double-cliquez-fuzz} spécifie le nombre maximal de pixels de la souris peut être déplacée (horizontalement ou verticalement) entre deux clics successifs pour faire un double-clic.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable is also the threshold for motion of the mouse to count as a drag.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable est également le seuil pour le mouvement de la souris pour compter comme un frein.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To generate repeat events, the number of milliseconds between successive button presses must be less than the value of @code{double-click-time}.  Setting @code{double-click-time} to @code{nil} disables multi-click detection entirely.  Setting it to @code{t} removes the time limit; Emacs then detects multi-clicks by position only.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour générer des événements de répétition, le nombre de millisecondes entre pressions de boutons successives doit être inférieure à la valeur de @ code {-temps double-cliquez sur}. Cadre @ code {double-cliquez-temps} à @ code {nil} désactive la détection multi-cliquez sur tout. Réglage à @ code {t} supprime le délai; Emacs détecte alors multi-clics par poste seulement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! motion event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événement de mouvement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! mouse motion events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événements de mouvement de souris</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs sometimes generates @dfn{mouse motion} events to describe motion of the mouse without any button activity.  Mouse motion events are represented by lists that look like this:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs génère parfois @ dfn {mouvement de la souris} événements pour décrire le mouvement de la souris sans activité de la touche. Événements de mouvement de souris sont représentés par des listes qui ressemblent à ceci:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (mouse-movement (@var{window} @var{buffer-pos} (@var{x} . @var{y}) @var{timestamp}))<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Souris mouvement (@ var {fenêtre} @ {var tampon-pos} (@ var {x}. @ Var {y}) @ {var timestamp})) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The second element of the list describes the current position of the mouse, just as in a click event (@pxref{Click Events}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le deuxième élément de la liste décrit la position actuelle de la souris, comme dans un événement click (@ pxref {Cliquez événements}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The special form @code{track-mouse} enables generation of motion events within its body.  Outside of @code{track-mouse} forms, Emacs does not generate events for mere motion of the mouse, and these events do not appear.  @xref{Mouse Tracking}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La forme spéciale @ code {titre} de la souris permet de générer des événements de mouvement au sein de son corps. En dehors de @ code {formes piste-souris}, Emacs ne génère pas d&apos;événements pour un simple déplacement de la souris, et ces événements ne semblent pas. @ Xref {} suivi de souris.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! focus event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>concentrer événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Window systems provide general ways for the user to control which window gets keyboard input.  This choice of window is called the @dfn{focus}.  When the user does something to switch between Emacs frames, that generates a @dfn{focus event}.  The normal definition of a focus event, in the global keymap, is to select a new frame within Emacs, as the user would expect.  @xref{Input Focus}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Systèmes de fenêtres fournissent des moyens généraux pour l&apos;utilisateur de contrôler la fenêtre qui reçoit l&apos;entrée au clavier. Ce choix de la fenêtre est appelé @ dfn {} accent. Lorsque l&apos;utilisateur fait quelque chose pour passer d&apos;un cadre Emacs, qui génère une @ dfn {de} événement de focus. La définition normale d&apos;un événement de mise au point, dans le plan de codage global, est de sélectionner un nouveau cadre dans Emacs, comme on l&apos;attend. @ Xref {Focus d&apos;entrée}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Focus events are represented in Lisp as lists that look like this:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événements de discussion sont représentés en Lisp que des listes qui ressemblent à ceci:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (switch-frame @var{new-frame})<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Commutateur-cadre @ var {nouveau-frame}) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! where @var{new-frame} is the frame switched to.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>où @ var {new-frame} est le cadre commuté.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Most X window managers are set up so that just moving the mouse into a window is enough to set the focus there.  Emacs appears to do this, because it changes the cursor to solid in the new frame.  However, there is no need for the Lisp program to know about the focus change until some other kind of input arrives.  So Emacs generates a focus event only when the user actually types a keyboard key or presses a mouse button in the new frame; just moving the mouse between frames does not generate a focus event.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La plupart des gestionnaires de fenêtres X sont mis en place afin que tout en déplaçant la souris dans une fenêtre suffit à mettre l&apos;accent là-bas. Emacs semble le faire, parce que le curseur change de solide dans le nouveau cadre. Cependant, il n&apos;est pas nécessaire pour le programme Lisp savoir sur le changement de mise au point jusqu&apos;à ce qu&apos;un autre type d&apos;entrée arrive. Donc Emacs génère un événement de mise au point que lorsque l&apos;utilisateur en fait un des types de touche de clavier ou appuie sur un bouton de la souris dans le nouveau cadre, juste en déplaçant la souris entre les cadres ne génère pas un événement de mise au point.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A focus event in the middle of a key sequence would garble the sequence.  So Emacs never generates a focus event in the middle of a key sequence.  If the user changes focus in the middle of a key sequence---that is, after a prefix key---then Emacs reorders the events so that the focus event comes either before or after the multi-event key sequence, and not within it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Un événement de mise au point au milieu d&apos;une séquence clé serait brouiller la séquence. Donc, Emacs ne génère un événement de mise au point au milieu d&apos;une séquence de touches. Si l&apos;utilisateur change concentrent au milieu d&apos;une séquence clé --- qui est, après une touche préfixe --- alors Emacs réordonne les événements pour que l&apos;événement de mise au point vient avant ou après la séquence de touches multi-cas, et pas dans il.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Miscellaneous System Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Système Divers événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! A few other event types represent occurrences within the system.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Quelques autres types d&apos;événements représentent des occurrences au sein du système.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{delete-frame} event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {delete-frame} événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (delete-frame (@var{frame}))</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Delete-cadre (@ var {frame}))</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This kind of event indicates that the user gave the window manager a command to delete a particular window, which happens to be an Emacs frame.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce genre d&apos;événement indique que l&apos;utilisateur a donné le gestionnaire de fenêtre une commande pour supprimer une fenêtre particulière, qui se trouve être un cadre Emacs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The standard definition of the @code{delete-frame} event is to delete @var{frame}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La définition standard de la @ code {delete-frame} événement est de supprimer @ var {frame}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{iconify-frame} event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {iconify-frame} événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (iconify-frame (@var{frame}))</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Iconify-cadre (@ var {frame}))</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This kind of event indicates that the user iconified @var{frame} using the window manager.  Its standard definition is @code{ignore}; since the frame has already been iconified, Emacs has no work to do.  The purpose of this event type is so that you can keep track of such events if you want to.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce genre d&apos;événement indique que l&apos;utilisateur iconifiée @ var {frame} en utilisant le gestionnaire de fenêtres. Sa définition standard est @ code {} ignorer, puisque le cadre a déjà été iconified, Emacs n&apos;a pas de travail à faire. Le but de ce type d&apos;événement est de sorte que vous pouvez garder une trace de ces événements si vous voulez.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{make-frame-visible} event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {make-frame-visible} événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (make-frame-visible (@var{frame}))</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Faire-frame-visible (@ var {frame}))</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This kind of event indicates that the user deiconified @var{frame} using the window manager.  Its standard definition is @code{ignore}; since the frame has already been made visible, Emacs has no work to do.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce genre d&apos;événement indique que l&apos;utilisateur deiconified @ var {frame} en utilisant le gestionnaire de fenêtres. Sa définition standard est @ code {} ignorer, puisque le cadre a déjà été rendue visible, Emacs n&apos;a pas de travail à faire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{wheel-up} event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {roue-up} événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{wheel-down} event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {roue-down} événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (wheel-up @var{position})</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Roue-up @ var {position})</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (wheel-down @var{position})</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Roue vers le bas @ var {position})</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These kinds of event are generated by moving a mouse wheel.  Their usual meaning is a kind of scroll or zoom.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ces types d&apos;événements sont générés par le déplacement d&apos;une molette de la souris. Leur signification habituelle est une sorte de défilement ou de zoom.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The element @var{position} is a list describing the position of the event, in the same format as used in a mouse-click event.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;élément @ var {position} est une liste décrivant la position de l&apos;événement, dans le même format que celui utilisé dans un événement clic de souris.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This kind of event is generated only on some kinds of systems. On some systems, @code{mouse-4} and @code{mouse-5} are used instead.  For portable code, use the variables @code{mouse-wheel-up-event} and @code{mouse-wheel-down-event} defined in @file{mwheel.el} to determine what event types to expect for the mouse wheel.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce genre d&apos;événement est généré uniquement sur certains types de systèmes. Sur certains systèmes, @ code {souris 4} et @ code {5}-souris sont utilisées à la place. Pour le code portable, utiliser les variables @ code {molette de la souris-up événement} et @ code {molette de la souris vers le bas-événement} défini dans @ file {} mwheel.el pour déterminer quel événement types de s&apos;attendre pour la molette de la souris .</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{drag-n-drop} event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {drag-n-drop} événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (drag-n-drop @var{position} @var{files})</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Drag-n-drop @ var {position} @ {var fichiers})</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This kind of event is generated when a group of files is selected in an application outside of Emacs, and then dragged and dropped onto an Emacs frame.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce genre d&apos;événement est généré lorsqu&apos;un groupe de fichiers est sélectionné dans une application en dehors d&apos;Emacs, puis glissé et collé sur un cadre Emacs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The element @var{position} is a list describing the position of the event, in the same format as used in a mouse-click event, and @var{files} is the list of file names that were dragged and dropped.  The usual way to handle this event is by visiting these files.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;élément @ var {position} est une liste décrivant la position de l&apos;événement, dans le même format que celui utilisé dans un événement clic de souris, et @ var {} fichiers est la liste des noms de fichiers qui ont été glissés et déposés. La manière habituelle de gérer cet événement est de visiter ces fichiers.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This kind of event is generated, at present, only on some kinds of systems.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce genre d&apos;événement est généré, à l&apos;heure actuelle, seulement sur certains types de systèmes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{help-echo} event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {} echo aide-événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! help-echo</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>aide-écho</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This kind of event is generated when a mouse pointer moves onto a portion of buffer text which has a @code{help-echo} text property.  The generated event has this form:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ce genre d&apos;événement est généré lorsque le pointeur de la souris se déplace sur une partie du texte du tampon qui a une propriété @ code {aide écho} texte. L&apos;événement a généré ce formulaire:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (help-echo @var{frame} @var{help} @var{window} @var{object} @var{pos})<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Aide-écho @ var {frame} @ {var aide} @ {var fenêtre} @ {var objet} @ {var pos}) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The precise meaning of the event parameters and the way these parameters are used to display the help-echo text are described in @ref{Text help-echo}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La signification précise des paramètres d&apos;événement et la façon dont ces paramètres sont utilisés pour afficher le texte d&apos;aide-écho sont décrits dans @ ref {texte aide écho}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{sigusr1} event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {} sigusr1 événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{sigusr2} event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {} SIGUSR2 événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! user signals</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>signaux d&apos;utilisateur</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! sigusr1</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>sigusr1</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! sigusr2</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>SIGUSR2</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These events are generated when the Emacs process receives the signals @code{SIGUSR1} and @code{SIGUSR2}.  They contain no additional data because signals do not carry additional information.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ces événements sont générés lorsque le processus Emacs reçoit les signaux @ code {SIGUSR1} et @ code {} SIGUSR2. Ils ne contiennent pas de données supplémentaires parce que les signaux ne portent pas d&apos;informations supplémentaires.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To catch a user signal, bind the corresponding event to an interactive command in the @code{special-event-map} (@pxref{Active Keymaps}).  The command is called with no arguments, and the specific signal event is available in @code{last-input-event}.  For example:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour attraper un signal d&apos;utilisateur, lier l&apos;événement correspondant à une commande interactive dans le code de @ {d&apos;événements spéciaux-carte} (@ pxref {active Keymaps}). La commande est appelée sans arguments, et l&apos;événement de signal spécifique est disponible dans @ code {dernière d&apos;événements d&apos;entrée}. Par exemple:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun sigusr-handler ()<ph x="1">&lt;x0/&gt;</ph>  (interactive)<ph x="2">&lt;x1/&gt;</ph>  (message \&quot;Caught signal %S\&quot; last-input-event))<ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun sigusr-gestionnaire () <ph x="1">&lt;x0/&gt;</ph> (Interactif) <ph x="2">&lt;x1/&gt;</ph> (Un message \ &quot;Caught signal de% S \&quot; dernière entrée-événement)) <ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (define-key special-event-map [sigusr1] &apos;sigusr-handler)<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Define-key d&apos;événements spéciaux-carte [sigusr1] &apos;sigusr-gestionnaire) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To test the signal handler, you can make Emacs send a signal to itself:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour tester le gestionnaire de signal, vous pouvez faire Emacs envoyer un signal à lui-même:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (signal-process (emacs-pid) &apos;sigusr1)<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Signal processus (emacs-pid) &apos;sigusr1) <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If one of these events arrives in the middle of a key sequence---that is, after a prefix key---then Emacs reorders the events so that this event comes either before or after the multi-event key sequence, not within it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si l&apos;un de ces événements arrive au milieu d&apos;une séquence de touches --- c&apos;est, après une touche de préfixe --- alors Emacs réordonne les événements de sorte que cet événement vient avant ou après la séquence de touches multi-cas, pas dans ce .</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the user presses and releases the left mouse button over the same location, that generates a sequence of events like this:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si les presses et libère le bouton gauche de la souris sur le même emplacement utilisateur, qui génère une séquence d&apos;événements comme celui-ci:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (down-mouse-1 (#&lt;window 18 on NEWS&gt; 2613 (0 . 38) -864320))<ph x="1">&lt;x0/&gt;</ph>(mouse-1      (#&lt;window 18 on NEWS&gt; 2613 (0 . 38) -864180))<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(En bas de la souris 1 (# &lt;window 18 sur NEWS&gt; 2613 (0. 38) -864320)) <ph x="1">&lt;x0/&gt;</ph> (Souris-1 (# &lt;window 18 sur NEWS&gt; 2613 (0. 38) -864180)) <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! While holding the control key down, the user might hold down the second mouse button, and drag the mouse from one line to the next.  That produces two events, as shown here:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tout en maintenant la touche de commande, l&apos;utilisateur peut appuyez sur le deuxième bouton de la souris et faites glisser la souris d&apos;une ligne à l&apos;autre. Qui produit deux événements, comme indiqué ici:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (C-down-mouse-2 (#&lt;window 18 on NEWS&gt; 3440 (0 . 27) -731219))<ph x="1">&lt;x0/&gt;</ph>(C-drag-mouse-2 (#&lt;window 18 on NEWS&gt; 3440 (0 . 27) -731219)<ph x="2">&lt;x1/&gt;</ph>                (#&lt;window 18 on NEWS&gt; 3510 (0 . 28) -729648))<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(C-down-mouse-2 (# 18 &lt;window sur NEWS&gt; 3440 (0. 27) -731219)) <ph x="1">&lt;x0/&gt;</ph> (C-glisser de la souris 2 (# 18 &lt;window sur NEWS&gt; 3440 (0. 27) -731219) <ph x="2">&lt;x1/&gt;</ph> (# &lt;window 18 sur NEWS&gt; 3510 (0. 28) -729648)) <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! While holding down the meta and shift keys, the user might press the second mouse button on the window&apos;s mode line, and then drag the mouse into another window.  That produces a pair of events like these:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Tout en maintenant les touches meta et décalage, l&apos;utilisateur peut appuyer sur le second bouton de la souris sur la ligne de mode de la fenêtre, puis faites glisser la souris dans une autre fenêtre. Cela produit une paire d&apos;événements de ce genre:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (M-S-down-mouse-2 (#&lt;window 18 on NEWS&gt; mode-line (33 . 31) -457844))<ph x="1">&lt;x0/&gt;</ph>(M-S-drag-mouse-2 (#&lt;window 18 on NEWS&gt; mode-line (33 . 31) -457844)<ph x="2">&lt;x1/&gt;</ph>                  (#&lt;window 20 on carlton-sanskrit.tex&gt; 161 (33 . 3)<ph x="3">&lt;x2/&gt;</ph>                   -453816))<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(MS-bas-souris-2 (# 18 &lt;window sur NEWS&gt; le mode en ligne (33. 31) -457844)) <ph x="1">&lt;x0/&gt;</ph> (MS-glisser de la souris 2 (# 18 &lt;window sur NEWS&gt; le mode en ligne (33. 31) -457844) <ph x="2">&lt;x1/&gt;</ph> (# 20 sur &lt;window carlton-sanskrit.tex&gt; 161 (33. 3) <ph x="3">&lt;x2/&gt;</ph> -453,816)) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To handle a SIGUSR1 signal, define an interactive function, and bind it to the @code{signal usr1} event sequence:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour gérer un signal SIGUSR1, définir une fonction interactive, et le lier à l&apos;@ code {} de signaux usr1 séquence d&apos;événements:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun usr1-handler ()<ph x="1">&lt;x0/&gt;</ph>  (interactive)<ph x="2">&lt;x1/&gt;</ph>  (message \&quot;Got USR1 signal\&quot;))<ph x="3">&lt;x2/&gt;</ph>(global-set-key [signal usr1] &apos;usr1-handler)<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun usr1-gestionnaire () <ph x="1">&lt;x0/&gt;</ph> (Interactif) <ph x="2">&lt;x1/&gt;</ph> (Un message \ &quot;Got USR1 signal de \&quot;)) <ph x="3">&lt;x2/&gt;</ph> (Global-set-key [signaux usr1] &apos;usr1-gestionnaire) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! event type</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>type d&apos;événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Every event has an @dfn{event type}, which classifies the event for key binding purposes.  For a keyboard event, the event type equals the event value; thus, the event type for a character is the character, and the event type for a function key symbol is the symbol itself.  For events that are lists, the event type is the symbol in the @sc{car} of the list.  Thus, the event type is always a symbol or a character.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Chaque événement a une @ dfn {type d&apos;événement}, qui classe l&apos;événement à des fins d&apos;assignation des touches. Pour un évènement clavier, le type d&apos;événement est égale à la valeur de l&apos;événement, ainsi, le type d&apos;événement d&apos;un caractère est le caractère et le type d&apos;événement d&apos;un symbole de touche de fonction est le symbole lui-même. Pour les événements qui sont des listes, le type d&apos;événement est le symbole de la sc @ {} voiture de la liste. Ainsi, le type d&apos;événement est toujours un symbole ou un caractère.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Two events of the same type are equivalent where key bindings are concerned; thus, they always run the same command.  That does not necessarily mean they do the same things, however, as some commands look at the whole event to decide what to do.  For example, some commands use the location of a mouse event to decide where in the buffer to act.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Deux événements du même type sont équivalentes où les raccourcis clavier sont concernés; ainsi, ils courent toujours le même commande. Cela ne signifie pas nécessairement qu&apos;ils font les mêmes choses, cependant, que certaines commandes regardent ensemble l&apos;événement pour décider quoi faire. Par exemple, certaines commandes utilisent la localisation d&apos;un événement de souris pour déterminer où dans le tampon d&apos;agir.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Sometimes broader classifications of events are useful.  For example, you might want to ask whether an event involved the @key{META} key, regardless of which other key or mouse button was used.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Parfois classifications plus larges d&apos;événements sont utiles. Par exemple, vous voudrez peut-être se demander si un événement a impliqué la touche @ key {META}, quel que soit autre touche du clavier ou de la souris a été utilisé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The functions @code{event-modifiers} and @code{event-basic-type} are provided to get such information conveniently.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions @ code {événements modificateurs} et @ code {-type d&apos;événement de base-} sont fournis pour obtenir ces informations facilement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! event-modifiers event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événements modificateurs événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns a list of the modifiers that @var{event} has.  The modifiers are symbols; they include @code{shift}, @code{control}, @code{meta}, @code{alt}, @code{hyper} and @code{super}.  In addition, the modifiers list of a mouse event symbol always contains one of @code{click}, @code{drag}, and @code{down}.  For double or triple events, it also contains @code{double} or @code{triple}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne une liste des modificateurs @ var {even} a. Les modificateurs sont des symboles, ils comprennent @ code {shift}, @ code {} contrôle, @ code {} méta, @ code {alt}, @ code {} hyper et @ code {super}. En outre, la liste des modificateurs d&apos;un symbole de l&apos;événement de la souris contient toujours un de @ code {} cliquez sur, @ code {} glisser, et @ code {down}. Pour les événements doubles ou triples, il contient également @ code {} à double ou triple @ code {}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The argument @var{event} may be an entire event object, or just an event type.  If @var{event} is a symbol that has never been used in an event that has been read as input in the current Emacs session, then @code{event-modifiers} can return @code{nil}, even when @var{event} actually has modifiers.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument @ var {} événement peut être un objet de l&apos;événement en entier ou seulement un type d&apos;événement. Si @ var {} événement est un symbole qui n&apos;a jamais été utilisée dans un événement qui a été lu comme entrée dans la session en cours Emacs, alors @ code {} événements modificateurs peuvent retourner @ code {nil}, même si @ var { événement} a effectivement modificateurs.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here are some examples:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici quelques exemples:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (event-modifiers ?a)<ph x="1">&lt;x0/&gt;</ph>     @result{} nil<ph x="2">&lt;x1/&gt;</ph>(event-modifiers ?A)<ph x="3">&lt;x2/&gt;</ph>     @result{} (shift)<ph x="4">&lt;x3/&gt;</ph>(event-modifiers ?\\C-a)<ph x="5">&lt;x4/&gt;</ph>     @result{} (control)<ph x="6">&lt;x5/&gt;</ph>(event-modifiers ?\\C-%)<ph x="7">&lt;x6/&gt;</ph>     @result{} (control)<ph x="8">&lt;x7/&gt;</ph>(event-modifiers ?\\C-\\S-a)<ph x="9">&lt;x8/&gt;</ph>     @result{} (control shift)<ph x="10">&lt;x9/&gt;</ph>(event-modifiers &apos;f5)<ph x="11">&lt;x10/&gt;</ph>     @result{} nil<ph x="12">&lt;x11/&gt;</ph>(event-modifiers &apos;s-f5)<ph x="13">&lt;x12/&gt;</ph>     @result{} (super)<ph x="14">&lt;x13/&gt;</ph>(event-modifiers &apos;M-S-f5)<ph x="15">&lt;x14/&gt;</ph>     @result{} (meta shift)<ph x="16">&lt;x15/&gt;</ph>(event-modifiers &apos;mouse-1)<ph x="17">&lt;x16/&gt;</ph>     @result{} (click)<ph x="18">&lt;x17/&gt;</ph>(event-modifiers &apos;down-mouse-1)<ph x="19">&lt;x18/&gt;</ph>     @result{} (down)<ph x="20">&lt;x19/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Événements modificateurs? A) <ph x="1">&lt;x0/&gt;</ph> @ {} Résultat nul <ph x="2">&lt;x1/&gt;</ph> (Événements modificateurs? A) <ph x="3">&lt;x2/&gt;</ph> @ Result {} (décalage) <ph x="4">&lt;x3/&gt;</ph> (Événements modificateurs? \ \ Ca) <ph x="5">&lt;x4/&gt;</ph> @ Result {} (contrôle) <ph x="6">&lt;x5/&gt;</ph> (Événements modificateurs? \ \ C-%) <ph x="7">&lt;x6/&gt;</ph> @ Result {} (contrôle) <ph x="8">&lt;x7/&gt;</ph> (Événements modificateurs? \ \ C-\ \ Sa) <ph x="9">&lt;x8/&gt;</ph> @ Result {} (changement de contrôle) <ph x="10">&lt;x9/&gt;</ph> (Événements modificateurs &apos;f5) <ph x="11">&lt;x10/&gt;</ph> @ {} Résultat nul <ph x="12">&lt;x11/&gt;</ph> («Événements modificateurs s-f5) <ph x="13">&lt;x12/&gt;</ph> @ Result {} (super) <ph x="14">&lt;x13/&gt;</ph> (Événements modificateurs &apos;MS-f5) <ph x="15">&lt;x14/&gt;</ph> @ Result {} (méta changement) <ph x="16">&lt;x15/&gt;</ph> (Souris 1 &apos;événements modificateurs) <ph x="17">&lt;x16/&gt;</ph> @ Result {} (clic) <ph x="18">&lt;x17/&gt;</ph> (Événements modificateurs &apos;down-mouse-1) <ph x="19">&lt;x18/&gt;</ph> @ Result {} (vers le bas) <ph x="20">&lt;x19/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The modifiers list for a click event explicitly contains @code{click}, but the event symbol name itself does not contain @samp{click}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La liste des modificateurs pour un événement click contient explicitement @ code {} cliquez sur, mais le nom du symbole de l&apos;événement lui-même ne contient pas de @ samp {} cliquez sur.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! event-basic-type event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>type d&apos;événement de base-événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the key or mouse button that @var{event} describes, with all modifiers removed.  The @var{event} argument is as in @code{event-modifiers}.  For example:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne le bouton de la souris ou du clavier que @ var {} événement décrit, avec tous les modificateurs supprimé. Le @ var {even} argument est que dans @ code {événements modificateurs}. Par exemple:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (event-basic-type ?a)<ph x="1">&lt;x0/&gt;</ph>     @result{} 97<ph x="2">&lt;x1/&gt;</ph>(event-basic-type ?A)<ph x="3">&lt;x2/&gt;</ph>     @result{} 97<ph x="4">&lt;x3/&gt;</ph>(event-basic-type ?\\C-a)<ph x="5">&lt;x4/&gt;</ph>     @result{} 97<ph x="6">&lt;x5/&gt;</ph>(event-basic-type ?\\C-\\S-a)<ph x="7">&lt;x6/&gt;</ph>     @result{} 97<ph x="8">&lt;x7/&gt;</ph>(event-basic-type &apos;f5)<ph x="9">&lt;x8/&gt;</ph>     @result{} f5<ph x="10">&lt;x9/&gt;</ph>(event-basic-type &apos;s-f5)<ph x="11">&lt;x10/&gt;</ph>     @result{} f5<ph x="12">&lt;x11/&gt;</ph>(event-basic-type &apos;M-S-f5)<ph x="13">&lt;x12/&gt;</ph>     @result{} f5<ph x="14">&lt;x13/&gt;</ph>(event-basic-type &apos;down-mouse-1)<ph x="15">&lt;x14/&gt;</ph>     @result{} mouse-1<ph x="16">&lt;x15/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Type d&apos;événement-base? A) <ph x="1">&lt;x0/&gt;</ph> @ Result {} 97 <ph x="2">&lt;x1/&gt;</ph> (Type d&apos;événement-base? A) <ph x="3">&lt;x2/&gt;</ph> @ Result {} 97 <ph x="4">&lt;x3/&gt;</ph> (Type d&apos;événement-base? \ \ Ca) <ph x="5">&lt;x4/&gt;</ph> @ Result {} 97 <ph x="6">&lt;x5/&gt;</ph> (Type d&apos;événement-base? \ \ C-\ \ Sa) <ph x="7">&lt;x6/&gt;</ph> @ Result {} 97 <ph x="8">&lt;x7/&gt;</ph> (Type d&apos;événement-base »f5) <ph x="9">&lt;x8/&gt;</ph> @ Result {} f5 <ph x="10">&lt;x9/&gt;</ph> (Type de base-événement &apos;s-f5) <ph x="11">&lt;x10/&gt;</ph> @ Result {} f5 <ph x="12">&lt;x11/&gt;</ph> (Cas-type de base &apos;MS-f5) <ph x="13">&lt;x12/&gt;</ph> @ Result {} f5 <ph x="14">&lt;x13/&gt;</ph> (Type d&apos;événement-base »en bas de la souris 1) <ph x="15">&lt;x14/&gt;</ph> @ Result {} souris-1 <ph x="16">&lt;x15/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! mouse-movement-p object</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>objet souris mouvement-p</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns non-@code{nil} if @var{object} is a mouse movement event.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne non @ code {nil} if @ var {objet} est un événement de mouvement de la souris.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! event-convert-list list</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>la liste des manifestations-convert-liste</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function converts a list of modifier names and a basic event type to an event type which specifies all of them.  The basic event type must be the last element of the list.  For example,</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction convertit une liste de noms de modificateur et un type d&apos;événement de base pour un type d&apos;événement qui spécifie toutes. Le type d&apos;événement de base doit être le dernier élément de la liste. Par exemple,</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (event-convert-list &apos;(control ?a))<ph x="1">&lt;x0/&gt;</ph>     @result{} 1<ph x="2">&lt;x1/&gt;</ph>(event-convert-list &apos;(control meta ?a))<ph x="3">&lt;x2/&gt;</ph>     @result{} -134217727<ph x="4">&lt;x3/&gt;</ph>(event-convert-list &apos;(control super f1))<ph x="5">&lt;x4/&gt;</ph>     @result{} C-s-f1<ph x="6">&lt;x5/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Cas-convert-list &apos;(contrôle? A)) <ph x="1">&lt;x0/&gt;</ph> @ Result {} 1 <ph x="2">&lt;x1/&gt;</ph> (Cas-convert-list &apos;(contrôle méta? A)) <ph x="3">&lt;x2/&gt;</ph> @ Result {} -134,217,727 <ph x="4">&lt;x3/&gt;</ph> (Cas-convert-list &apos;(contrôle superbe f1)) <ph x="5">&lt;x4/&gt;</ph> @ Result {} Cs-f1 <ph x="6">&lt;x5/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! mouse events, data in</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événements souris, les données en</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This section describes convenient functions for accessing the data in a mouse button or motion event.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette section décrit les fonctions pratiques pour accéder aux données dans un bouton de la souris ou d&apos;un événement de mouvement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These two functions return the starting or ending position of a mouse-button event, as a list of this form:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ces deux fonctions renvoient la position de départ ou de fin d&apos;un événement bouton de la souris, comme une liste de ce formulaire:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! event-start event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>EVENT début</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This returns the starting position of @var{event}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cela renvoie la position de départ de @ var {even}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{event} is a click or button-down event, this returns the location of the event.  If @var{event} is a drag event, this returns the drag&apos;s starting position.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {} événement est un clic ou d&apos;un événement de bouton vers le bas, cela renvoie le lieu de l&apos;événement. Si @ var {} événement est un événement de glisser, cela renvoie la position de départ de la traînée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! event-end event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événement event-end</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This returns the ending position of @var{event}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cela renvoie la position de fin de @ var {even}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{event} is a drag event, this returns the position where the user released the mouse button.  If @var{event} is a click or button-down event, the value is actually the starting position, which is the only position such events have.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {} événement est un événement de glisser, cela renvoie la position où l&apos;utilisateur a relâché le bouton de la souris. Si @ var {} événement est un clic ou d&apos;un événement de bouton vers le bas, la valeur est en fait la position de départ, qui est la seule position de tels événements ont.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! mouse position list, accessing</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>liste des positions souris, l&apos;accès</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These functions take a position list as described above, and return various parts of it.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ces fonctions prennent une liste de position, comme décrit ci-dessus, et de retour les différentes parties de celui-ci.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-window position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>poste POSTE-fenêtre</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the window that @var{position} is in.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Rétablir la fenêtre que @ var {position} est po</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-area position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>poste POSTE-zone</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the window area recorded in @var{position}.  It returns @code{nil} when the event occurred in the text area of the window; otherwise, it is a symbol identifying the area in which the event occurred.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retour de la zone de fenêtre enregistrée dans @ var {position}. Il retourne @ code {nil} lorsque l&apos;événement s&apos;est produit dans la zone de texte de la fenêtre, sinon, c&apos;est un symbole d&apos;identification de la zone dans laquelle l&apos;événement s&apos;est produit.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-point position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>poste POSTE point</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the buffer position in @var{position}.  When the event occurred in the text area of the window, in a marginal area, or on a fringe, this is an integer specifying a buffer position.  Otherwise, the value is undefined.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retourne la position de la mémoire tampon dans @ var {position}. Lorsque l&apos;événement s&apos;est produit dans la zone de texte de la fenêtre, dans une zone marginale, ou sur une frange, il s&apos;agit d&apos;un entier spécifiant une position de la mémoire tampon. Sinon, la valeur est undefined.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-x-y position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>position POSTE-xy</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the pixel-based x and y coordinates in @var{position}, as a cons cell @code{(@var{x} . @var{y})}.  These coordinates are relative to the window given by @code{posn-window}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retour x base de pixels et les coordonnées y dans @ var {position}, comme un code contre cellule @ {(@ var {x}. @ Var {y})}. Ces coordonnées sont relatives à la fenêtre donnée par @ code {POSTE-fenêtre}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This example shows how to convert these window-relative coordinates into frame-relative coordinates:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cet exemple montre comment convertir ces coordonnées de la fenêtre-rapport en coordonnées de cadre relative:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (defun frame-relative-coordinates (position)<ph x="1">&lt;x0/&gt;</ph>  \&quot;Return frame-relative coordinates from POSITION.\&quot;<ph x="2">&lt;x1/&gt;</ph>  (let* ((x-y (posn-x-y position))<ph x="3">&lt;x2/&gt;</ph>         (window (posn-window position))<ph x="4">&lt;x3/&gt;</ph>         (edges (window-inside-pixel-edges window)))<ph x="5">&lt;x4/&gt;</ph>    (cons (+ (car x-y) (car edges))<ph x="6">&lt;x5/&gt;</ph>          (+ (cdr x-y) (cadr edges)))))<ph x="7">&lt;x6/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Defun cadre relatif coordonnées (position) <ph x="1">&lt;x0/&gt;</ph> \ &quot;Retour coordonnées de cadre relatif de la position. \&quot; <ph x="2">&lt;x1/&gt;</ph> (Let * ((xy (position POSTE-xy)) <ph x="3">&lt;x2/&gt;</ph> (Une fenêtre (position POSTE-fenêtre)) <ph x="4">&lt;x3/&gt;</ph> (bords de fenêtres (window-intérieur-pixels-bords))) <ph x="5">&lt;x4/&gt;</ph> (contre (+ voiture (xy) (bords de voiture)) <ph x="6">&lt;x5/&gt;</ph> (+ (Cdr xy) (bords de CADR))))) <ph x="7">&lt;x6/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-col-row position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>poste POSTE-col-ligne</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the row and column (in units of the frame&apos;s default character height and width) of @var{position}, as a cons cell @code{(@var{col} .  @var{row})}.  These are computed from the @var{x} and @var{y} values actually found in @var{position}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retour de la ligne et de la colonne (en unités de caractères par défaut pour la hauteur et la largeur de l&apos;image) de @ var {position}, comme un code contre cellule @ {(@ var {col}. @ Var {ligne})}. Celles-ci sont calculées à partir de la @ var {x} et @ var {y} valeurs effectivement trouvé dans @ var {position}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-actual-col-row position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>poste POSTE-réelle-col-ligne</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the actual row and column in @var{position}, as a cons cell @code{(@var{col} . @var{row})}.  The values are the actual row number in the window, and the actual character number in that row.  It returns @code{nil} if @var{position} does not include actual positions values.  You can use @code{posn-col-row} to get approximate values.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retour de la ligne et de la colonne réelle dans @ var {position}, comme un code contre cellule @ {(@ var {col}. @ Var {ligne})}. Les valeurs sont le nombre de lignes réel dans la fenêtre, et le nombre de caractère réel de cette ligne. Il retourne @ code {nil} if @ var {position} ne comprend pas les valeurs de positions réelles. Vous pouvez utiliser @ code {POSTE-col-ligne} pour obtenir des valeurs approximatives.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-string position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>poste POSTE-chaîne</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the string object in @var{position}, either @code{nil}, or a cons cell @code{(@var{string} . @var{string-pos})}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retourne l&apos;objet de chaîne dans @ var {position}, soit @ code {nil}, ou une contre cellule @ code {(@ var {string}. @ {Var string-pos})}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-image position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>poste POSTE image</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the image object in @var{position}, either @code{nil}, or an image @code{(image ...)}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retourne l&apos;objet de l&apos;image dans @ var {position}, soit @ code {nil}, ou une image @ code {(l&apos;image ...)}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-object position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>poste POSTE-objet</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the image or string object in @var{position}, either @code{nil}, an image @code{(image ...)}, or a cons cell @code{(@var{string} . @var{string-pos})}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retour de l&apos;image ou de l&apos;objet de chaîne dans @ var {position}, soit @ code {nil}, une image @ code {(l&apos;image ...)}, ou une contre cellule @ code {(@ var {string}. @ {Var chaîne-pos})}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-object-x-y position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>POSTE-objet-xy poste</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the pixel-based x and y coordinates relative to the upper left corner of the object in @var{position} as a cons cell @code{(@var{dx} . @var{dy})}.  If the @var{position} is a buffer position, return the relative position in the character at that position.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retour x et y à base de pixels coordonnées par rapport au coin supérieur gauche de l&apos;objet dans @ var {position} comme une contre cellule @ code {(@ var {dx}. @ Var {dy})}. Si l&apos;@ var {position} est une position de tampon, retourner la position relative dans le caractère à cette position.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-object-width-height position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>poste POSTE-objet-largeur-hauteur</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the pixel width and height of the object in @var{position} as a cons cell @code{(@var{width} . @var{height})}.  If the @var{position} is a buffer position, return the size of the character at that position.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retour la largeur en pixels et la hauteur de l&apos;objet dans @ var {position} comme une contre cellule @ code {(@ var {width}. @ Var {hauteur})}. Si l&apos;@ var {position} est une position de tampon, retourner la taille du caractère à cette position.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! timestamp of a mouse event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>horodatage d&apos;un événement de souris</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-timestamp position</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>poste POSTE horodatage</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Return the timestamp in @var{position}.  This is the time at which the event occurred, in milliseconds.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Retour à l&apos;horodatage @ var {position}. Ceci est l&apos;heure à laquelle l&apos;événement s&apos;est produit, en millisecondes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These functions compute a position list given particular buffer position or screen position.  You can access the data in this position list with the functions described above.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ces fonctions calculent une liste de position donnée notamment la position de tampon ou de la position de l&apos;écran. Vous pouvez accéder aux données de cette liste de position avec les fonctions décrites ci-dessus.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-at-point &amp;optional pos window</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>POSTE-à-point &amp; fenêtre optionnel pos</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns a position list for position @var{pos} in @var{window}.  @var{pos} defaults to point in @var{window}; @var{window} defaults to the selected window.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne une liste de position pour la position @ var {pos} {var @ dans la fenêtre}. @ Var {pos} par défaut à signaler dans @ {var} fenêtre; @ var {} fenêtre par défaut la fenêtre sélectionnée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{posn-at-point} returns @code{nil} if @var{pos} is not visible in @var{window}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {POSTE-à-Point} retourne @ code {nil} if @ var {pos} n&apos;est pas visible dans @ {var} fenêtre.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! posn-at-x-y x y &amp;optional frame-or-window whole</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>xy et facultatif cadre ou fenêtre tout POSTE-à-xy</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns position information corresponding to pixel coordinates @var{x} and @var{y} in a specified frame or window, @var{frame-or-window}, which defaults to the selected window.  The coordinates @var{x} and @var{y} are relative to the frame or window used.  If @var{whole} is @code{nil}, the coordinates are relative to the window text area, otherwise they are relative to the entire window area including scroll bars, margins and fringes.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne des informations de position correspondant à des coordonnées en pixels @ var {x} et @ var {y} dans un cadre ou à la fenêtre, @ var {frame ou fenêtre}, qui est par défaut la fenêtre sélectionnée. Les coordonnées @ var {x} et @ var {y} sont par rapport au cadre ou une fenêtre utilisée. Si @ var {} tout est @ code {nil}, les coordonnées sont relatives à la fenêtre zone de texte, sinon ils sont liés à la surface de la fenêtre entière, y compris les barres de défilement, les marges et les franges.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! These functions are useful for decoding scroll bar events.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Ces fonctions sont utiles pour des événements de barre de défilement de décodage.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! scroll-bar-event-ratio event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>bar défiler événement ratio événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function returns the fractional vertical position of a scroll bar event within the scroll bar.  The value is a cons cell @code{(@var{portion} . @var{whole})} containing two integers whose ratio is the fractional position.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction retourne la position verticale fractionnée d&apos;un événement de barre de défilement dans la barre de défilement. La valeur est une contre cellule @ code {(@ var {} partie. @ {Var tout})} contenant deux entiers dont le rapport est la position fractionnaire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! scroll-bar-scale ratio total</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>ratio-bar défiler échelle</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function multiplies (in effect) @var{ratio} by @var{total}, rounding the result to an integer.  The argument @var{ratio} is not a number, but rather a pair @code{(@var{num} . @var{denom})}---typically a value returned by @code{scroll-bar-event-ratio}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction multiplie (en effet) @ {var} par rapport @ var {total}, en arrondissant le résultat à un nombre entier. L&apos;argument @ {var} rapport n&apos;est pas un nombre, mais plutôt une paire @ code {(@ var {nombre}. @ Var {denom})} --- généralement une valeur retournée par @ code {-bar scroll-événement rapport}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function is handy for scaling a position on a scroll bar into a buffer position.  Here&apos;s how to do that:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction est pratique pour l&apos;échelle d&apos;une position sur une barre de défilement dans une position de tampon. Voici comment faire:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (+ (point-min)<ph x="1">&lt;x0/&gt;</ph>   (scroll-bar-scale<ph x="2">&lt;x1/&gt;</ph>      (posn-x-y (event-start event))<ph x="3">&lt;x2/&gt;</ph>      (- (point-max) (point-min))))<ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(+ (Point min) <ph x="1">&lt;x0/&gt;</ph> (Scroll-bar-échelle <ph x="2">&lt;x1/&gt;</ph> (POSTE-xy (cas de démarrage événement)) <ph x="3">&lt;x2/&gt;</ph> (- (Point max) (point min)))) <ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Recall that scroll bar events have two integers forming a ratio, in place of a pair of x and y coordinates.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Rappelons que les événements de la barre de défilement ont deux entiers formant un rapport, au lieu d&apos;une paire de coordonnées x et y.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Putting Keyboard Events in Strings</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Mettre des événements du clavier dans les chaînes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! keyboard events in strings</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événements de clavier dans les chaînes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! strings with keyboard events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>cordes avec les événements de clavier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In most of the places where strings are used, we conceptualize the string as containing text characters---the same kind of characters found in buffers or files.  Occasionally Lisp programs use strings that conceptually contain keyboard characters; for example, they may be key sequences or keyboard macro definitions.  However, storing keyboard characters in a string is a complex matter, for reasons of historical compatibility, and it is not always possible.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Dans la plupart des endroits où les chaînes sont utilisées, de conceptualiser la chaîne comme contenant des caractères de texte --- le même genre de caractères contenus dans des tampons ou des fichiers. Programmes à l&apos;occasion Lisp utilisent des chaînes qui contiennent conceptuellement caractères du clavier, par exemple, ils peuvent être des séquences de touches ou clavier définitions de macros. Cependant, le stockage des caractères de clavier dans une chaîne est un sujet complexe, pour des raisons de compatibilité de l&apos;historique, et il n&apos;est pas toujours possible.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! We recommend that new programs avoid dealing with these complexities by not storing keyboard events in strings.  Here is how to do that:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Nous recommandons que les nouveaux programmes éviter de surmonter ces difficultés en ne stockant pas les événements de clavier dans les chaînes. Voici comment faire:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Use vectors instead of strings for key sequences, when you plan to use them for anything other than as arguments to @code{lookup-key} and @code{define-key}.  For example, you can use @code{read-key-sequence-vector} instead of @code{read-key-sequence}, and @code{this-command-keys-vector} instead of @code{this-command-keys}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Utilisez vecteurs au lieu de chaînes de séquences de touches, lorsque vous prévoyez de les utiliser pour autre chose que comme arguments à @ code {lookup-clé} et @ code {définir-clé} rien. Par exemple, vous pouvez utiliser @ code {lire la clé de séquence de vecteur} au lieu de @ code {lecture séquence de touches} et @ code {ce-commande-clés vecteur} au lieu de @ code {ce-commande touches}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Use vectors to write key sequence constants containing meta characters, even when passing them directly to @code{define-key}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Utilisez vecteurs d&apos;écrire des constantes de séquences clés contenant des caractères meta, même en les passant directement à @ code {define-key}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When you have to look at the contents of a key sequence that might be a string, use @code{listify-key-sequence} (@pxref{Event Input Misc})  first, to convert it to a list.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque vous avez à regarder le contenu d&apos;une séquence de touches qui pourraient être une chaîne, utilisez @ code {listify-séquence de touches} (@ pxref {entrée de l&apos;événement Divers}) d&apos;abord, pour le convertir en une liste.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The complexities stem from the modifier bits that keyboard input characters can include.  Aside from the Meta modifier, none of these modifier bits can be included in a string, and the Meta modifier is allowed only in special cases.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les complexités proviennent les bits de modification que les caractères d&apos;entrée au clavier peuvent comprendre. Mis à part le modificateur Meta, aucune de ces bits de modification peut être inclus dans une chaîne, et le modificateur Meta n&apos;est autorisée que dans des cas particuliers.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The earliest GNU Emacs versions represented meta characters as codes in the range of 128 to 255.  At that time, the basic character codes ranged from 0 to 127, so all keyboard character codes did fit in a string.  Many Lisp programs used @samp{\\M-} in string constants to stand for meta characters, especially in arguments to @code{define-key} and similar functions, and key sequences and sequences of events were always represented as strings.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les premières versions de GNU Emacs représentés méta-caractères comme les codes de l&apos;ordre de 128 à 255. A cette époque, les codes de caractères de base allaient de 0 à 127, de sorte que tous les codes de caractères du clavier ne s&apos;inscrivent dans une chaîne. Beaucoup de programmes Lisp utilisés @ samp {\ \ M-} dans les constantes de chaîne de se présenter aux méta-caractères, en particulier dans les arguments de @ code {define-key} et des fonctions similaires, et les séquences et les séquences d&apos;événements clés ont toujours été représentés comme des chaînes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When we added support for larger basic character codes beyond 127, and additional modifier bits, we had to change the representation of meta characters.  Now the flag that represents the Meta modifier in a character is</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque nous avons ajouté le support pour les codes plus grandes base de caractères au-delà de 127, et des morceaux de modification supplémentaires, nous avons dû changer la représentation des méta-caractères. Maintenant, le drapeau qui représente le modificateur Meta dans un personnage est</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! and such numbers cannot be included in a string.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>et ces chiffres ne peuvent pas être inclus dans une chaîne.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! To support programs with @samp{\\M-} in string constants, there are special rules for including certain meta characters in a string.  Here are the rules for interpreting a string as a sequence of input characters:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour soutenir les programmes avec @ samp {\ \ M-} dans les constantes de chaîne, il ya des règles spéciales pour inclure certains caractères meta dans une chaîne. Voici les règles pour l&apos;interprétation d&apos;une chaîne comme une séquence de caractères d&apos;entrée:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the keyboard character value is in the range of 0 to 127, it can go in the string unchanged.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si la valeur du caractère de clavier se trouve dans la plage de 0 à 127, il peut aller dans la chaîne inchangé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The meta variants of those characters, with codes in the range of</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les méta variantes de ces caractères, avec les codes de l&apos;ordre de</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @math<ph x="1">&lt;x0/&gt;</ph> + 127},<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Mathématiques <ph x="1">&lt;x0/&gt;</ph> + 127}, <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! 2**27+127,</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>2 ** 27 127,</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! can also go in the string, but you must change their numeric values.  You must set the</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>peut aussi aller dans la chaîne, mais vous devez modifier leurs valeurs numériques. Vous devez définir la</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @math<ph x="1">&lt;x0/&gt;</ph>}<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Mathématiques <ph x="1">&lt;x0/&gt;</ph> } <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! 2**7</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>2 ** 7</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bit instead of the</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>bit au lieu de l&apos;</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! bit, resulting in a value between 128 and 255.  Only a unibyte string can include these codes.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>bits, résultant en une valeur comprise entre 128 et 255. Seule une chaîne de unibyte peut inclure ces codes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Non-@acronym{ASCII} characters above 256 can be included in a multibyte string.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Non @ acronyme {ASCII} caractères ci-dessus 256 peuvent être inclus dans une chaîne de caractères multi-octets.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Other keyboard character events cannot fit in a string.  This includes keyboard events in the range of 128 to 255.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>D&apos;autres événements de caractères du clavier ne peuvent pas s&apos;inscrire dans une chaîne. Cela comprend les événements de clavier dans la gamme de 128 à 255.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Functions such as @code{read-key-sequence} that construct strings of keyboard input characters follow these rules: they construct vectors instead of strings, when the events won&apos;t fit in a string.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions telles que @ code {lecture séquence de touches} qui construisent des chaînes de caractères d&apos;entrée au clavier suivre ces règles: ils construisent des vecteurs au lieu de cordes, lorsque les événements ne rentre pas dans une chaîne.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When you use the read syntax @samp{\\M-} in a string, it produces a code in the range of 128 to 255---the same code that you get if you modify the corresponding keyboard event to put it in the string.  Thus, meta events in strings work consistently regardless of how they get into the strings.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque vous utilisez la syntaxe de lecture @ samp {\ \ M-} dans une chaîne, il produit un code dans la gamme de 128 à 255 --- le même code que vous obtenez si vous modifiez le cas du clavier correspondant à le mettre dans le chaîne. Ainsi, méta-événements dans les chaînes fonctionnent toujours, peu importe la façon dont ils entrent dans les cordes.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! However, most programs would do well to avoid these issues by following the recommendations at the beginning of this section.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cependant, la plupart des programmes feraient bien d&apos;éviter ces problèmes en suivant les recommandations au début de cette section.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! read input</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>lire l&apos;entrée</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! keyboard input</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>l&apos;entrée au clavier</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The editor command loop reads key sequences using the function @code{read-key-sequence}, which uses @code{read-event}.  These and other functions for event input are also available for use in Lisp programs.  See also @code{momentary-string-display} in @ref{Temporary Displays}, and @code{sit-for} in @ref{Waiting}.  @xref{Terminal Input}, for functions and variables for controlling terminal input modes and debugging terminal input.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La commande en boucle de l&apos;éditeur lit séquences clés en utilisant la fonction @ code {lecture séquence de touches}, qui utilise @ code {lire événement}. Ceux-ci et d&apos;autres fonctions pour l&apos;entrée de l&apos;événement sont également disponibles pour une utilisation dans les programmes Lisp. Voir aussi @ code {momentané-string-écran} dans @ ref {Affiche temporaires} et @ code {sit-for} dans @ ref {} en attente. @ Xref {de} Terminal d&apos;entrée, pour les fonctions et les variables de contrôle des modes d&apos;entrée du terminal et le débogage borne d&apos;entrée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For higher-level input facilities, see @ref{Minibuffers}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Pour les installations d&apos;entrée de niveau supérieur, voir @ ref {} Minibuffers.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Key Sequence Input</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Entrée de séquence de touches</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How to read one key sequence.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment lire une séquence clé.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Reading One Event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Une lecture de l&apos;événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How to read just one event.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment lire un seul événement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Event Mod</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Mod événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How Emacs modifies events as they are read.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment Emacs modifie les événements tels qu&apos;ils sont lus.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Invoking the Input Method</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Invoquer la méthode de saisie</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How reading an event uses the input method.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment lire un événement utilise la méthode d&apos;entrée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Quoted Character Input</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Saisie de caractères Cité</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Asking the user to specify a character.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Demandant à l&apos;utilisateur de spécifier un caractère.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Event Input Misc</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Entrée de l&apos;événement Divers</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! How to reread or throw away input events.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Comment relire ou jeter des événements d&apos;entrée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! key sequence input</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>entrée de séquence de touches</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The command loop reads input a key sequence at a time, by calling @code{read-key-sequence}.  Lisp programs can also call this function; for example, @code{describe-key} uses it to read the key to describe.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La boucle de commande lit l&apos;entrée une séquence de touches à la fois, en appelant @ code {lecture séquence de touches}. Programmes Lisp peuvent également appeler cette fonction, par exemple, @ code {describe-key} utilise pour lire la clé de décrire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! read-key-sequence prompt &amp;optional continue-echo dont-downcase-last switch-frame-ok command-loop</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>lecture séquence de touches rapides et facultatif continuer écho dont-downcase-dernier commutateur-cadre ok commande en boucle</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function reads a key sequence and returns it as a string or vector.  It keeps reading events until it has accumulated a complete key sequence; that is, enough to specify a non-prefix command using the currently active keymaps.  (Remember that a key sequence that starts with a mouse event is read using the keymaps of the buffer in the window that the mouse was in, not the current buffer.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction lit une séquence de touches et la renvoie sous forme de chaîne ou d&apos;un vecteur. Il continue à lire les événements jusqu&apos;à ce qu&apos;il ait accumulé une séquence de touches complet, c&apos;est suffisant pour spécifier une commande non-préfixe en utilisant les claviers actuellement actifs. (Rappelez-vous que une séquence de touches qui commence par un événement de souris est lu en utilisant les claviers de la mémoire tampon dans la fenêtre que la souris était, pas le tampon courant.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the events are all characters and all can fit in a string, then @code{read-key-sequence} returns a string (@pxref{Strings of Events}).  Otherwise, it returns a vector, since a vector can hold all kinds of events---characters, symbols, and lists.  The elements of the string or vector are the events in the key sequence.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si les événements sont tous les caractères et tous peuvent entrer dans une chaîne, puis @ code {lecture séquence de touches} retourne une chaîne (@ {pxref chaînes des événements}). Sinon, elle renvoie un vecteur, depuis un vecteur peut contenir toutes sortes d&apos;événements --- caractères, des symboles et des listes. Les éléments de la chaîne ou vecteur sont les événements dans la séquence de touches.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Reading a key sequence includes translating the events in various ways.  @xref{Translation Keymaps}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La lecture d&apos;une séquence de touches qui comprend la traduction des événements de diverses manières. @ Xref {} mappages de traduction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The argument @var{prompt} is either a string to be displayed in the echo area as a prompt, or @code{nil}, meaning not to display a prompt.  The argument @var{continue-echo}, if non-@code{nil}, means to echo this key as a continuation of the previous key.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument @ {var invite} est soit une chaîne à afficher dans la zone écho comme un code rapide, ou @ {nil}, ce qui signifie ne pas afficher une invite. L&apos;argument @ {var continuer écho}, si non @ code {nil}, signifie faire l&apos;écho de cette clé comme une continuation de la clé précédente.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Normally any upper case event is converted to lower case if the original event is undefined and the lower case equivalent is defined.  The argument @var{dont-downcase-last}, if non-@code{nil}, means do not convert the last event to lower case.  This is appropriate for reading a key sequence to be defined.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Normalement tout cas majuscule est converti en minuscules si l&apos;événement d&apos;origine n&apos;est pas définie et le cas équivalent inférieure est définie. L&apos;argument @ {var dont-downcase-dernière}, si non @ code {nil}, les moyens ne convertissent pas le dernier événement en minuscules. Ceci est approprié pour la lecture d&apos;une séquence de touches à définir.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The argument @var{switch-frame-ok}, if non-@code{nil}, means that this function should process a @code{switch-frame} event if the user switches frames before typing anything.  If the user switches frames in the middle of a key sequence, or at the start of the sequence but @var{switch-frame-ok} is @code{nil}, then the event will be put off until after the current key sequence.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument @ var {switch-cadre ok}, si non @ code {nil}, signifie que cette fonction doit traiter un @ code {switch-frame} cas si l&apos;utilisateur bascule cadres avant de taper quoi que ce soit. Si l&apos;utilisateur passe cadres au milieu d&apos;une séquence de touches, ou au début de la séquence, mais @ var {switch-cadre ok} est @ code {nil}, l&apos;événement sera reporté jusqu&apos;à ce que la séquence de touches courant .</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The argument @var{command-loop}, if non-@code{nil}, means that this key sequence is being read by something that will read commands one after another.  It should be @code{nil} if the caller will read just one key sequence.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>L&apos;argument @ {var commande en boucle}, si non @ code {nil}, signifie que cette séquence de touches est lu par quelque chose qui va lire ses commandes un après l&apos;autre. Il devrait être @ code {nil} si l&apos;appelant va lire une seule séquence de touches.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In the following example, Emacs displays the prompt @samp{?} in the echo area, and then the user types @kbd{C-x C-f}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Dans l&apos;exemple suivant, Emacs affiche l&apos;invite @ samp {?} Dans la zone écho, puis les types de @ kbd {Cx Cf} utilisateur.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (read-key-sequence \&quot;?\&quot;)<ph x="1">&lt;x0/&gt;</ph><ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Lecture séquence de touches \ &quot;? \&quot;) <ph x="1">&lt;x0/&gt;</ph><ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ---------- Echo Area ----------<ph x="1">&lt;x0/&gt;</ph>?@kbd{C-x C-f}<ph x="2">&lt;x1/&gt;</ph>---------- Echo Area ----------<ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>---------- ---------- Zone Echo <ph x="1">&lt;x0/&gt;</ph> ? @ Kbd {Cx Cf} <ph x="2">&lt;x1/&gt;</ph> ---------- ---------- Zone Echo <ph x="3">&lt;x2/&gt;</ph><ph x="4">&lt;x3/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT!      @result{} \&quot;^X^F\&quot;<ph x="1">&lt;x0/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Result {} \ &quot;^ X ^ F \&quot; <ph x="1">&lt;x0/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{read-key-sequence} suppresses quitting: @kbd{C-g} typed while reading with this function works like any other character, and does not set @code{quit-flag}.  @xref{Quitting}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Le code de la fonction @ {lecture séquence de touches} supprime quitter: @ kbd {Cg} tapé lors de la lecture avec cette fonction fonctionne comme n&apos;importe quel autre caractère, et ne fixe pas de @ code {quitter drapeau}. @ Xref {Quitter}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! read-key-sequence-vector prompt &amp;optional continue-echo dont-downcase-last switch-frame-ok command-loop</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>lecture séquence de touches vecteur rapide et facultatif continuer écho dont-downcase-dernier commutateur-cadre ok commande en boucle</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This is like @code{read-key-sequence} except that it always returns the key sequence as a vector, never as a string.  @xref{Strings of Events}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>C&apos;est comme @ code {lecture séquence de touches} sauf qu&apos;il retourne toujours la séquence de touches comme un vecteur, jamais comme une chaîne. @ Xref {Strings des événements}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! upper case key sequence</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>séquence de touches majuscules</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! downcasing in @code{lookup-key}</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>en minuscules dans @ code {lookup-clé}</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If an input character is upper-case (or has the shift modifier) and has no key binding, but its lower-case equivalent has one, then @code{read-key-sequence} converts the character to lower case.  Note that @code{lookup-key} does not perform case conversion in this way.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si un caractère d&apos;entrée est en majuscule (ou a le modificateur de décalage) et n&apos;a pas de clé de liaison, mais son minuscule équivalent a un, puis @ code {lecture séquence de touches} convertit le caractère en minuscule. Notez que @ code {lookup-clé} n&apos;effectue pas la conversion de cas de cette manière.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The function @code{read-key-sequence} also transforms some mouse events.  It converts unbound drag events into click events, and discards unbound button-down events entirely.  It also reshuffles focus events and miscellaneous window events so that they never appear in a key sequence with any other events.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La fonction @ code {lecture séquence de touches} transforme aussi des événements de souris. Il convertit des événements de glisser non liés à des événements de clic, et ignore les événements bouton en bas non liés entièrement. Il remanie aussi des événements discussion et événements de fenêtre divers afin qu&apos;ils n&apos;apparaissent jamais dans une séquence de touches avec d&apos;autres événements.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{header-line} prefix key</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {header-ligne} touche de préfixe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{mode-line} prefix key</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {mode en ligne} touche de préfixe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{vertical-line} prefix key</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {vertical-ligne} touche de préfixe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{horizontal-scroll-bar} prefix key</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {horizontal-scroll-bar} touche de préfixe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{vertical-scroll-bar} prefix key</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {vertical-scroll-bar} touche de préfixe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! @code{menu-bar} prefix key</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>@ Code {menu-bar} touche de préfixe</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! mouse events, in special parts of frame</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>événements souris, dans des pièces spéciales de cadre</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When mouse events occur in special parts of a window, such as a mode line or a scroll bar, the event type shows nothing special---it is the same symbol that would normally represent that combination of mouse button and modifier keys.  The information about the window part is kept elsewhere in the event---in the coordinates.  But @code{read-key-sequence} translates this information into imaginary ``prefix keys,&apos;&apos; all of which are symbols: @code{header-line}, @code{horizontal-scroll-bar}, @code{menu-bar}, @code{mode-line}, @code{vertical-line}, and @code{vertical-scroll-bar}.  You can define meanings for mouse clicks in special window parts by defining key sequences using these imaginary prefix keys.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lorsque les événements de souris se produisent dans des pièces spéciales d&apos;une fenêtre, comme une ligne de mode ou une barre de défilement, le type d&apos;événement montre rien de spécial --- c&apos;est le même symbole qui représenterait normalement la combinaison de bouton de la souris et des touches de modification. Les informations sur la partie de la fenêtre est maintenue ailleurs dans le cas --- dans les coordonnées. Mais @ code {lecture séquence de touches} traduit cette information en touches préfixe `` imaginaires,&apos;&apos; qui sont tous des symboles: @ code {header-line}, @ code {horizontal-scroll-bar}, @ code {menu -bar}, @ code {mode en ligne}, @ code {vertical-ligne} et {@ code-barre de défilement vertical}. Vous pouvez définir les significations pour les clics de souris dans des pièces spéciales de la fenêtre en définissant les séquences de touches à utiliser les touches de préfixe imaginaires.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! For example, if you call @code{read-key-sequence} and then click the mouse on the window&apos;s mode line, you get two events, like this:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Par exemple, si vous appelez @ code {lecture séquence de touches} et puis cliquez sur la souris sur la ligne de mode de la fenêtre, vous obtenez deux événements, comme ceci:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (read-key-sequence \&quot;Click on the mode line: \&quot;)<ph x="1">&lt;x0/&gt;</ph>     @result{} [mode-line<ph x="2">&lt;x1/&gt;</ph>         (mouse-1<ph x="3">&lt;x2/&gt;</ph>          (#&lt;window 6 on NEWS&gt; mode-line<ph x="4">&lt;x3/&gt;</ph>           (40 . 63) 5959987))]<ph x="5">&lt;x4/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Lecture séquence de touches \ &quot;Cliquez sur la ligne de mode: \&quot;) <ph x="1">&lt;x0/&gt;</ph> @ Result {} [Mode en ligne <ph x="2">&lt;x1/&gt;</ph> (Souris 1 <ph x="3">&lt;x2/&gt;</ph> (# &lt;window 6 sur NEWS&gt; le mode en ligne <ph x="4">&lt;x3/&gt;</ph> (40. 63) 5959987))] <ph x="5">&lt;x4/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! num-input-keys</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>num-entrée-clés</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable&apos;s value is the number of key sequences processed so far in this Emacs session.  This includes key sequences read from the terminal and key sequences read from keyboard macros being executed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>La valeur de cette variable est le nombre de séquences de touches traitées jusqu&apos;à présent dans cette session Emacs. Cela inclut des séquences de clé de lecture du terminal et des séquences clés de lecture de macros clavier cours d&apos;exécution.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! reading a single event</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>la lecture d&apos;un seul événement</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! event, reading only one</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>cas, la lecture seule</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! The lowest level functions for command input are those that read a single event.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Les fonctions plus bas niveau pour l&apos;entrée de commande sont ceux qui lisent un seul événement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! None of the three functions below suppresses quitting.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Aucun des trois fonctions ci-dessous supprime cesser de fumer.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! read-event &amp;optional prompt inherit-input-method seconds</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>lecture événement et invite option héritent-input-method secondes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function reads and returns the next event of command input, waiting if necessary until an event is available.  Events can come directly from the user or from a keyboard macro.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction lit et retourne le prochain événement de l&apos;entrée de commande, en attendant si nécessaire jusqu&apos;à ce qu&apos;un événement est disponible. Les événements peuvent venir directement de l&apos;utilisateur ou d&apos;une macro de clavier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If the optional argument @var{prompt} is non-@code{nil}, it should be a string to display in the echo area as a prompt.  Otherwise, @code{read-event} does not display any message to indicate it is waiting for input; instead, it prompts by echoing: it displays descriptions of the events that led to or were read by the current command.  @xref{The Echo Area}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si l&apos;argument optionnel @ var {} est rapide non @ code {nil}, il devrait être une chaîne à afficher dans la zone écho comme une invite. Sinon, @ code {lire événement} n&apos;affiche pas de message pour indiquer qu&apos;il est en attente d&apos;entrée, au contraire, il invite par écho: il affiche les descriptions des événements qui ont mené ou ont été lus par la commande en cours. @ Xref {La zone Echo}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{inherit-input-method} is non-@code{nil}, then the current input method (if any) is employed to make it possible to enter a non-@acronym{ASCII} character.  Otherwise, input method handling is disabled for reading this event.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {héritent-input-method} est non @ code {nil}, alors la méthode d&apos;entrée de courant (le cas échéant) est utilisé pour permettre de saisir un non-@ acronyme {ASCII} caractère. Sinon, la méthode de saisie manipulation est désactivée pour la lecture de ce cas.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @code{cursor-in-echo-area} is non-@code{nil}, then @code{read-event} moves the cursor temporarily to the echo area, to the end of any message displayed there.  Otherwise @code{read-event} does not move the cursor.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ code {curseur en écho zone} est non @ code {nil}, alors @ code {lire événement} déplace le curseur temporairement à la zone d&apos;écho, à la fin d&apos;un message, il s&apos;affiche. Sinon @ code {lire événement} ne déplace pas le curseur.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{seconds} is non-@code{nil}, it should be a number specifying the maximum time to wait for input, in seconds.  If no input arrives within that time, @code{read-event} stops waiting and returns @code{nil}.  A floating-point value for @var{seconds} means to wait for a fractional number of seconds.  Some systems support only a whole number of seconds; on these systems, @var{seconds} is rounded down.  If @var{seconds} is @code{nil}, @code{read-event} waits as long as necessary for input to arrive.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {} secondes est non @ code {nil}, il devrait être un nombre spécifiant le délai maximum d&apos;attente pour l&apos;entrée, en quelques secondes. Si aucune entrée arrive dans ce délai, @ code {lire événement} s&apos;arrête attente et retourne @ code {nil}. Une valeur à virgule flottante pour @ var {} secondes signifie d&apos;attendre un nombre fractionnaire de secondes. Certains systèmes ne supportent qu&apos;un nombre entier de secondes, sur ces systèmes, @ var {} secondes sont arrondies vers le bas. Si @ var {} secondes est @ code {nil}, @ code {lire événement} attend aussi longtemps que nécessaire pour l&apos;entrée à arriver.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @var{seconds} is @code{nil}, Emacs is considered idle while waiting for user input to arrive.  Idle timers---those created with @code{run-with-idle-timer} (@pxref{Idle Timers})---can run during this period.  However, if @var{seconds} is non-@code{nil}, the state of idleness remains unchanged.  If Emacs is non-idle when @code{read-event} is called, it remains non-idle throughout the operation of @code{read-event}; if Emacs is idle (which can happen if the call happens inside an idle timer), it remains idle.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ var {} secondes est @ code {nil}, Emacs est considéré comme inactif en attendant l&apos;entrée d&apos;utilisateur à arriver. Minuteries Idle --- ceux créés avec @ code {run-avec-idle-timer} (@ pxref {Timers Idle}) --- peuvent fonctionner pendant cette période. Toutefois, si @ var {} secondes est non @ code {nil}, l&apos;état de l&apos;oisiveté reste inchangé. Si Emacs est non-ralenti quand @ code {lire événement} est appelée, elle reste non-ralenti tout au long de l&apos;opération de @ code {lire événement}, si Emacs est inactif (ce qui peut arriver si l&apos;appel passe à l&apos;intérieur d&apos;un minuteur d&apos;inactivité ), il reste inactif.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @code{read-event} gets an event that is defined as a help character, then in some cases @code{read-event} processes the event directly without returning.  @xref{Help Functions}.  Certain other events, called @dfn{special events}, are also processed directly within @code{read-event} (@pxref{Special Events}).</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ code {lire événement} devient un événement qui est défini comme un caractère d&apos;aide, alors dans certains cas, @ code {lire événement} traite l&apos;événement directement sans retour. @ Xref {Aide} Fonctions. Certains autres événements, appelés @ dfn {} événements spéciaux, sont également traitées directement dans @ code {lire événement} (@ {pxref des événements spéciaux}).</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here is what happens if you call @code{read-event} and then press the right-arrow function key:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici ce qui arrive si vous appelez @ code {lire événement}, puis appuyez sur la touche de fonction droite-flèche:</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (read-event)<ph x="1">&lt;x0/&gt;</ph>     @result{} right<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Lire l&apos;événement) <ph x="1">&lt;x0/&gt;</ph> @ Result {} droit <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! read-char &amp;optional prompt inherit-input-method seconds</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>lire-char et facultatifs invite héritent-input-method secondes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function reads and returns a character of command input.  If the user generates an event which is not a character (i.e. a mouse click or function key event), @code{read-char} signals an error.  The arguments work as in @code{read-event}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction lit et retourne un caractère de l&apos;entrée de commande. Si l&apos;utilisateur génère un événement qui n&apos;est pas un caractère (par exemple un clic ou d&apos;une fonction souris événement clé), @ code {lecture car} signale une erreur. Les arguments fonctionnent comme dans @ code {lire événement}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! In the first example, the user types the character @kbd<ph x="1">&lt;x0/&gt;</ph> (@acronym{ASCII} code 49).  The second example shows a keyboard macro definition that calls @code{read-char} from the minibuffer using @code{eval-expression}.  @code{read-char} reads the keyboard macro&apos;s very next character, which is @kbd<ph x="2">&lt;x1/&gt;</ph>.  Then @code{eval-expression} displays its return value in the echo area.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Dans le premier exemple, les types de caractères l&apos;utilisateur @ kbd <ph x="1">&lt;x0/&gt;</ph> (@ Acronyme {ASCII} Code 49). Le deuxième exemple montre une définition de macro de clavier qui appelle @ code {lire-char} dans le mini-tampon en utilisant @ code {eval-expression}. Code {lecture car} @ lit très prochain caractère de la macro de clavier, qui est @ kbd <ph x="2">&lt;x1/&gt;</ph> . Puis code {eval-expression} @ affiche sa valeur de retour dans la zone écho.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (read-char)<ph x="1">&lt;x0/&gt;</ph>     @result{} 49<ph x="2">&lt;x1/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Lire-char) <ph x="1">&lt;x0/&gt;</ph> @ Result {} 49 <ph x="2">&lt;x1/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! ;; @r{We assume here you use @kbd{M-:} to evaluate this.}<ph x="1">&lt;x0/&gt;</ph>(symbol-function &apos;foo)<ph x="2">&lt;x1/&gt;</ph>     @result{} \&quot;^[:(read-char)^M1\&quot;<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>;; @ R {Nous supposons ici que vous utilisez @ kbd {M-:} à évaluer ce produit.} <ph x="1">&lt;x0/&gt;</ph> (Symbole fonction &apos;foo) <ph x="2">&lt;x1/&gt;</ph> @ Result {} \ &quot;^ [: (lu-char) ^ M1 ​​\&quot; <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! (execute-kbd-macro &apos;foo)<ph x="1">&lt;x0/&gt;</ph>     @print{} 49<ph x="2">&lt;x1/&gt;</ph>     @result{} nil<ph x="3">&lt;x2/&gt;</ph></seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>(Execute-kbd-macro &apos;foo) <ph x="1">&lt;x0/&gt;</ph> @ Impression {} 49 <ph x="2">&lt;x1/&gt;</ph> @ {} Résultat nul <ph x="3">&lt;x2/&gt;</ph></seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! read-char-exclusive &amp;optional prompt inherit-input-method seconds</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>lire-char-exclusif et facultatif héritent-input-method invite secondes</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function reads and returns a character of command input.  If the user generates an event which is not a character, @code{read-char-exclusive} ignores it and reads another event, until it gets a character.  The arguments work as in @code{read-event}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction lit et retourne un caractère de l&apos;entrée de commande. Si l&apos;utilisateur génère un événement qui n&apos;est pas un caractère, @ code {lire-char-exclusif} ignore et lit un autre événement, jusqu&apos;à ce qu&apos;il obtienne un caractère. Les arguments fonctionnent comme dans @ code {lire événement}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! num-nonmacro-input-events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>num-nonmacro-entrée-événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable holds the total number of input events received so far from the terminal---not counting those generated by keyboard macros.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable contient le nombre total d&apos;événements d&apos;entrée reçues à ce jour à partir du terminal --- sans compter ceux générés par les macros de clavier.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Modifying and Translating Input Events</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Modification et Traduire entrée événements</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Emacs modifies every event it reads according to @code{extra-keyboard-modifiers}, then translates it through @code{keyboard-translate-table} (if applicable), before returning it from @code{read-event}.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Emacs modifie tous les cas, il lit selon @ code {extra-clavier-modificateurs}, puis le traduit par @ code {clavier traduire table} (le cas échéant), avant de les retourner @ code {lire événement}.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! extra-keyboard-modifiers</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>extra-clavier-modificateurs</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable lets Lisp programs ``press&apos;&apos; the modifier keys on the keyboard.  The value is a character.  Only the modifiers of the character matter.  Each time the user types a keyboard key, it is altered as if those modifier keys were held down.  For instance, if you bind @code{extra-keyboard-modifiers} to @code{?\\C-\\M-a}, then all keyboard input characters typed during the scope of the binding will have the control and meta modifiers applied to them.  The character @code{?\\C-@@}, equivalent to the integer 0, does not count as a control character for this purpose, but as a character with no modifiers.  Thus, setting @code{extra-keyboard-modifiers} to zero cancels any modification.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable permet de programmes Lisp `` de presse&apos;&apos; sur les touches de modification du clavier. La valeur est un personnage. Seuls les modificateurs de la question de caractère. Chaque fois que les types de clés de clavier de l&apos;utilisateur, il est modifié comme si ces touches de modification ont été enfoncées. Par exemple, si vous liez @ code {extra-clavier-modificateurs} à @ code {? \ \ C-\ \ Ma}, alors tous les caractères d&apos;entrée de clavier tapées au cours de la portée de la liaison aura le contrôle et la méta modificateurs appliqués à eux. Le caractère @ code {? \ \ C-@ @}, ce qui équivaut à l&apos;entier 0, ne compte pas comme un caractère de contrôle à cette fin, mais comme un personnage sans modificateurs. Ainsi, le réglage @ code {extra-clavier-modificateurs} à zéro annule toute modification.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! When using a window system, the program can ``press&apos;&apos; any of the modifier keys in this way.  Otherwise, only the @key{CTL} and @key{META} keys can be virtually pressed.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Lors de l&apos;utilisation d&apos;un système de fenêtre, le programme peut `` presse&apos;&apos; l&apos;une des touches de modification de cette façon. Sinon, seule la touche @ {CTL} et @ touches clés {META} peuvent être pratiquement pressés.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Note that this variable applies only to events that really come from the keyboard, and has no effect on mouse events or any other events.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Notez que cette variable ne s&apos;applique qu&apos;aux événements qui viennent vraiment à partir du clavier, et n&apos;a aucun effet sur les événements de souris ou tout autre événement.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! keyboard-translate-table</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>clavier traduire table</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This variable is the translate table for keyboard characters.  It lets you reshuffle the keys on the keyboard without changing any command bindings.  Its value is normally a char-table, or else @code{nil}.  (It can also be a string or vector, but this is considered obsolete.)</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette variable est la table pour traduire les caractères du clavier. Il vous permet de rebattre les touches du clavier sans modifier les liaisons de commandement. Sa valeur est normalement un caractère table, ou bien @ code {nil}. (Il peut également être une chaîne ou un vecteur, mais cela est considéré comme obsolète.)</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! If @code{keyboard-translate-table} is a char-table (@pxref{Char-Tables}), then each character read from the keyboard is looked up in this char-table.  If the value found there is non-@code{nil}, then it is used instead of the actual input character.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Si @ code {clavier traduire table} est un caractère table (@ pxref {Char-Tables}), alors chaque caractère lu à partir du clavier est recherché dans ce ca-table. Si la valeur qui s&apos;y trouve est non @ code {nil}, alors il est utilisé à la place du caractère réel d&apos;entrée.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Note that this translation is the first thing that happens to a character after it is read from the terminal.  Record-keeping features such as @code{recent-keys} and dribble files record the characters after translation.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>A noter que cette définition est la première chose qui arrive à un caractère après qu&apos;il a été lu à partir du terminal. caractéristiques de la tenue des dossiers tels que @ code {dernières touches} et les fichiers dribble enregistrer les caractères après traduction.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Note also that this translation is done before the characters are supplied to input methods (@pxref{Input Methods}).  Use @code{translation-table-for-input} (@pxref{Translation of Characters}), if you want to translate characters after input methods operate.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Notez aussi que cette traduction est faite avant que les personnages sont livrés à des méthodes de saisie (@ pxref {Méthodes de saisie}). Utilisez @ code {traduction-table-pour-entrée} (@ pxref {Traduction de caractères}), si vous voulez convertir les caractères après les méthodes d&apos;entrée fonctionnent.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! keyboard-translate from to</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>clavier traduire du au</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! This function modifies @code{keyboard-translate-table} to translate character code @var{from} into character code @var{to}.  It creates the keyboard translate table if necessary.</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Cette fonction modifie @ code {clavier traduire table} pour traduire le code caractère @ var {} dans le code de caractère @ var {} à. Il crée le clavier table de traduction si nécessaire.</seg></tuv>
</tu>
<tu>
<tuv xml:lang="en-us"><seg>MT! Here&apos;s an example of using the @code{keyboard-translate-table} to make @kbd{C-x}, @kbd{C-c} and @kbd{C-v} perform the cut, copy and paste operations:</seg></tuv>
<tuv xml:lang="fr-fr" creationid="MT!"><seg>Voici un exemple d&apos;utilisation du code @ {clavier traduire table} pour faire @ kbd {Cx}, @ kbd {CC} et @ kbd {} Cv effectuer le couper, copier et coller des opérations:</seg></tuv>
</tu>
</body>
</tmx>